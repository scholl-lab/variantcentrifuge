---
phase: 21-pure-python-skat-backend
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - variantcentrifuge/association/backends/python_backend.py
  - variantcentrifuge/association/backends/__init__.py
  - variantcentrifuge/association/tests/skat_python.py
  - variantcentrifuge/association/tests/__init__.py
  - variantcentrifuge/association/engine.py
autonomous: true

must_haves:
  truths:
    - "PythonSKATBackend fits a null model using statsmodels GLM with response residuals"
    - "test_gene computes score statistic Q and eigenvalues matching R formulation"
    - "Eigenvalue decomposition uses scipy.linalg.eigh(driver='evr') matching R DSYEVR"
    - "Rank check is performed on full eigenvalue set BEFORE filtering"
    - "Genes with rank < 2 return p_value=None with skip_reason='rank_deficient'"
    - "SKAT-O searches the fixed rho grid [0, 0.01, 0.04, 0.09, 0.25, 0.5, 1.0]"
    - "get_skat_backend('python') returns PythonSKATBackend instance"
    - "PurePythonSKATTest wraps PythonSKATBackend following RSKATTest pattern"
    - "--skat-backend python selects PurePythonSKATTest via engine registry"
    - "p_method and p_converged are included in TestResult.extra"
  artifacts:
    - path: "variantcentrifuge/association/backends/python_backend.py"
      provides: "PythonSKATBackend implementing SKATBackend ABC"
      exports: ["PythonSKATBackend"]
    - path: "variantcentrifuge/association/tests/skat_python.py"
      provides: "PurePythonSKATTest wrapping PythonSKATBackend"
      exports: ["PurePythonSKATTest"]
    - path: "variantcentrifuge/association/backends/__init__.py"
      provides: "Updated get_skat_backend with 'python' support"
    - path: "variantcentrifuge/association/engine.py"
      provides: "Updated registry with 'skat_python' entry"
  key_links:
    - from: "variantcentrifuge/association/backends/python_backend.py"
      to: "variantcentrifuge/association/backends/davies.py"
      via: "compute_pvalue() call in test_gene()"
      pattern: "from.*davies import compute_pvalue"
    - from: "variantcentrifuge/association/backends/python_backend.py"
      to: "statsmodels.api.GLM"
      via: "fit_null_model GLM fitting"
      pattern: "sm\\.GLM.*family="
    - from: "variantcentrifuge/association/tests/skat_python.py"
      to: "variantcentrifuge/association/backends/python_backend.py"
      via: "PythonSKATBackend instantiation"
      pattern: "PythonSKATBackend"
    - from: "variantcentrifuge/association/backends/__init__.py"
      to: "variantcentrifuge/association/backends/python_backend.py"
      via: "get_skat_backend('python') import"
      pattern: "from.*python_backend import PythonSKATBackend"
    - from: "variantcentrifuge/association/engine.py"
      to: "variantcentrifuge/association/tests/skat_python.py"
      via: "_build_registry 'skat_python' entry"
      pattern: "skat_python.*PurePythonSKATTest"
---

<objective>
Implement PythonSKATBackend (the pure Python SKAT backend) and PurePythonSKATTest (the engine
wrapper), then wire them into the factory and engine registry so that `--skat-backend python`
works end-to-end without R.

Purpose: This is the core deliverable of Phase 21 -- users without R can now run SKAT/SKAT-O.
The backend uses the p-value layer from Plan 21-01 (davies.py) for all p-value computation.

Output: Working PythonSKATBackend + PurePythonSKATTest, factory updated, registry updated.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-pure-python-skat-backend/21-RESEARCH.md
@.planning/phases/21-pure-python-skat-backend/21-CONTEXT.md
@.planning/phases/21-pure-python-skat-backend/21-01-SUMMARY.md
@variantcentrifuge/association/backends/base.py
@variantcentrifuge/association/backends/__init__.py
@variantcentrifuge/association/backends/r_backend.py
@variantcentrifuge/association/tests/skat_r.py
@variantcentrifuge/association/engine.py
@variantcentrifuge/association/weights.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PythonSKATBackend — null model, score test, SKAT-O</name>
  <files>
    variantcentrifuge/association/backends/python_backend.py
  </files>
  <action>
Create `variantcentrifuge/association/backends/python_backend.py` implementing `SKATBackend` ABC.

**Class: PythonSKATBackend(SKATBackend)**

1. **`detect_environment()`**: Import numpy, scipy, statsmodels to verify availability.
   Call `_try_load_davies()` from davies.py; if unavailable, log INFO "Davies C extension
   unavailable; will use saddlepoint/Liu fallback". Never raises — Python deps always present.

2. **`log_environment()`**: Log versions of numpy, scipy, statsmodels at INFO level.
   Log whether Davies C extension is available.

3. **`fit_null_model(phenotype, covariates, trait_type) -> NullModelResult`**:
   - Use `statsmodels.api.GLM` with `families.Binomial()` for binary, `families.Gaussian()`
     for quantitative
   - Add intercept via `sm.add_constant(covariates)` or `np.ones((n, 1))` if covariates is None
   - Extract `result.resid_response` (y - mu_hat) — NOT resid_deviance or resid_pearson
   - For quantitative traits: compute `sigma2 = np.var(residuals, ddof=1)`
   - For binary traits: `sigma2 = 1.0` (convention)
   - Store residuals and sigma2 in NullModelResult.extra:
     `extra={"residuals": residuals, "sigma2": sigma2, "mu_hat": result.fittedvalues}`
   - Return NullModelResult with model=result, trait_type, n_samples, adjustment=False

4. **`test_gene(gene, genotype_matrix, null_model, method, weights_beta) -> dict`**:
   Route to `_test_skat()`, `_test_burden()`, or `_test_skato()` based on `method`.

5. **`_test_skat(gene, Z, null_model, weights_beta) -> dict`**:
   - Compute MAFs from genotype matrix: `mafs = Z.mean(axis=0) / 2.0`
   - Compute weights: `beta_maf_weights(mafs, a=a1, b=a2)` (from weights.py)
   - Weighted genotype matrix: `ZW = Z * weights[np.newaxis, :]` (broadcast, not diag @ matmul)
   - **Rank check BEFORE eigenvalue filtering**: `np.linalg.matrix_rank(Z)`. If < 2, return
     `{"p_value": None, "skip_reason": "rank_deficient", "p_method": None, "p_converged": False, ...}`
   - Score statistic: `Zr = ZW.T @ residuals; Q = float(Zr @ Zr) / 2.0`
   - Kernel eigenvalues: `K = ZW @ ZW.T; lambdas_all = scipy.linalg.eigh(K / (2.0 * sigma2), eigvals_only=True, driver='evr')`
   - Eigenvalue filtering (match R exactly):
     ```
     pos = lambdas_all[lambdas_all >= 0]
     threshold = pos.mean() / 100_000.0
     lambdas = lambdas_all[lambdas_all > threshold]
     ```
   - Call `compute_pvalue(Q, lambdas)` from davies.py
   - Return dict with p_value, rho=None, n_variants, n_marker_test, warnings, p_method, p_converged

6. **`_test_burden(gene, Z, null_model, weights_beta) -> dict`**:
   - Burden statistic: weighted sum of variants per sample, then score test
   - `burden = Z @ weights` — collapse to single burden score per sample
   - Score: `T = residuals @ burden`; Variance: `V = sigma2 * (burden @ burden)`
   - p-value: `2 * norm.sf(abs(T / sqrt(V)))` (two-sided)
   - Return with p_method="analytical", p_converged=True

7. **`_test_skato(gene, Z, null_model, weights_beta) -> dict`**:
   - Fixed rho grid: `[0.0, 0.01, 0.04, 0.09, 0.25, 0.5, 1.0]`
   - For each rho: `Q_rho = (1-rho)*Q_skat + rho*Q_burden`
   - Compute p-value for each rho using optimal combination of eigenvalues
   - For each rho, the kernel is `(1-rho)*K_skat + rho*K_burden` which changes eigenvalues
   - Eigenvalues for each rho: `lambdas_rho = (1-rho)*lambdas_skat + rho*lambda_burden`
     where lambda_burden is the single burden eigenvalue
   - Use `compute_pvalue(Q_rho, lambdas_rho)` for each rho
   - Optimal rho: rho with minimum p-value
   - SKAT-O omnibus p: `scipy.integrate.quad` over the minimum-p distribution
     (Davies' method on the correlated minimum; epsabs=1.49e-8)
   - If integration is complex, use the simpler min-p with Bonferroni-like correction
     (acceptable for initial implementation; can refine later)
   - Return with optimal rho, p_method from the optimal rho's computation

8. **`cleanup()`**: No-op (no external resources to release). Log DEBUG "Python SKAT cleanup (no-op)".

CRITICAL implementation details (from CONTEXT.md and RESEARCH.md):
- Use `scipy.linalg.eigh(driver='evr')` — matches R's DSYEVR
- Use `resid_response` — NOT resid_deviance or resid_pearson
- Eigenvalue threshold: `mean(positive_lambdas) / 100_000`
- Rank check on FULL matrix, BEFORE eigenvalue filtering
- Weight application via broadcasting `Z * w[np.newaxis, :]`, NOT `Z @ np.diag(w)` (memory)
- sigma2 = np.var(residuals, ddof=1) for quantitative; 1.0 for binary
  </action>
  <verify>
    Run: `python -c "from variantcentrifuge.association.backends.python_backend import PythonSKATBackend; b = PythonSKATBackend(); b.detect_environment(); print('OK')"` — must print OK.
    Run: `python -c "
import numpy as np
from variantcentrifuge.association.backends.python_backend import PythonSKATBackend
b = PythonSKATBackend()
b.detect_environment()
# Simple test: 20 samples, 3 variants, binary trait
rng = np.random.default_rng(42)
pheno = np.array([0]*10 + [1]*10, dtype=float)
nm = b.fit_null_model(pheno, None, 'binary')
Z = rng.choice([0,1,2], size=(20,3), p=[0.7,0.2,0.1]).astype(float)
result = b.test_gene('TEST', Z, nm, 'SKAT', (1.0, 25.0))
print(f'p={result[\"p_value\"]}, method={result.get(\"p_method\")}, rho={result.get(\"rho\")}')
"` — must print a valid p-value.
  </verify>
  <done>
    - PythonSKATBackend implements all 4 abstract methods from SKATBackend ABC
    - fit_null_model uses statsmodels GLM with response residuals
    - test_gene routes to SKAT, Burden, or SKAT-O based on method parameter
    - Eigenvalues computed with scipy.linalg.eigh(driver='evr')
    - Rank check happens before eigenvalue filtering
    - Rank-deficient genes return p_value=None + skip_reason
    - SKAT-O searches the 7-element rho grid
    - p_method and p_converged included in return dict
  </done>
</task>

<task type="auto">
  <name>Task 2: PurePythonSKATTest wrapper + factory/registry wiring</name>
  <files>
    variantcentrifuge/association/tests/skat_python.py
    variantcentrifuge/association/tests/__init__.py
    variantcentrifuge/association/backends/__init__.py
    variantcentrifuge/association/engine.py
  </files>
  <action>
1. **Create `variantcentrifuge/association/tests/skat_python.py`** — PurePythonSKATTest class
   following the exact same pattern as RSKATTest (skat_r.py):

   - `class PurePythonSKATTest(AssociationTest):`
   - `name` property returns `"skat"` (same test name — it IS the SKAT test, just different backend)
   - `check_dependencies()`: calls `get_skat_backend("python")`, then `detect_environment()` + `log_environment()`
   - `effect_column_names()`: same as RSKATTest — all None (SKAT has no effect size)
   - `prepare(gene_count)`: log interval setup, start message (simpler than RSKATTest — no R heap monitoring)
   - `finalize()`: timing summary, backend cleanup
   - `run(gene, contingency_data, config) -> TestResult`:
     - Extract genotype_matrix, phenotype_vector, covariate_matrix from contingency_data
     - Guard: no geno matrix or empty -> return TestResult with p_value=None
     - Lazy null model fit on first call (cache as self._null_model)
     - Parse weights_beta from config.variant_weights (reuse `_parse_weights_beta` from skat_r.py
       OR import it — prefer import to avoid duplication)
     - Call backend.test_gene()
     - Pack into TestResult with extra keys:
       `skat_o_rho`, `skat_warnings`, `skat_method`, `skat_n_marker_test`,
       `skat_p_method`, `skat_p_converged`, `skat_skip_reason`
     - Progress logging every log_interval genes

   IMPORTANT: The `_parse_weights_beta` function is currently in skat_r.py. Either:
   (a) Move it to a shared location (e.g., `variantcentrifuge/association/tests/__init__.py`
       or a new `variantcentrifuge/association/tests/_utils.py`), OR
   (b) Import it from skat_r — but this would import rpy2 transitively.
   Best approach: (a) move to __init__.py or _utils.py to avoid rpy2 dependency.
   Update skat_r.py to import from the shared location.

2. **Update `variantcentrifuge/association/backends/__init__.py`**:
   - Replace the NotImplementedError for `"python"` with:
     ```python
     if backend_name == "python":
         from variantcentrifuge.association.backends.python_backend import PythonSKATBackend
         return PythonSKATBackend()
     ```
   - Update `"auto"` mode: after R fails, try Python backend:
     ```python
     from variantcentrifuge.association.backends.python_backend import PythonSKATBackend
     return PythonSKATBackend()
     ```
   - Update docstring to reflect Python backend is now implemented

3. **Update `variantcentrifuge/association/engine.py`**:
   - In `_build_registry()`, add conditional registration:
     ```python
     # Register skat_python as an alias when Python backend is requested
     # The "skat" key stays mapped to RSKATTest (R backend)
     from variantcentrifuge.association.tests.skat_python import PurePythonSKATTest
     ```
   - Add `"skat_python": PurePythonSKATTest` to the registry dict
   - NOTE: The CLI arg `--skat-backend python` controls which backend the "skat" test uses.
     The engine registry key "skat_python" is for when `--association-tests skat_python` is
     explicitly requested. The standard `--association-tests skat` with `--skat-backend python`
     should select PurePythonSKATTest instead of RSKATTest. This routing happens at the
     engine/registry level — check how `_build_registry` and `from_names` interact with
     `AssociationConfig.skat_backend` and wire accordingly. The cleanest approach:
     in `_build_registry()`, check `config.skat_backend` and swap the "skat" entry accordingly.
     Since _build_registry currently takes no args, either pass config or handle it in from_names.

4. **Update `variantcentrifuge/association/tests/__init__.py`** if moving _parse_weights_beta there.

Run `make lint` and `make format` after all changes.
  </action>
  <verify>
    Run: `python -c "from variantcentrifuge.association.backends import get_skat_backend; b = get_skat_backend('python'); b.detect_environment(); print('OK')"` — must print OK.
    Run: `python -c "from variantcentrifuge.association.tests.skat_python import PurePythonSKATTest; t = PurePythonSKATTest(); print(t.name)"` — must print "skat".
    Run: `make lint` — must pass.
    Run: `pytest -m unit -x -q --timeout=60 2>&1 | tail -5` — must pass with no regressions.
  </verify>
  <done>
    - PurePythonSKATTest exists and follows RSKATTest pattern
    - get_skat_backend("python") returns PythonSKATBackend (no NotImplementedError)
    - get_skat_backend("auto") falls back to Python when R unavailable
    - Engine registry includes skat_python entry
    - _parse_weights_beta is shared (no duplication)
    - All existing tests pass (no regressions from registry/factory changes)
  </done>
</task>

</tasks>

<verification>
1. `get_skat_backend("python")` returns a PythonSKATBackend instance
2. `get_skat_backend("auto")` falls back to Python when R/rpy2 is absent
3. PythonSKATBackend.test_gene() returns valid p-values for SKAT method
4. PythonSKATBackend.test_gene() returns valid p-values + optimal rho for SKATO method
5. PurePythonSKATTest.run() returns TestResult with p_method/p_converged in extra
6. Rank-deficient genes get p_value=None + skip_reason
7. `make lint` passes, `pytest -m unit -x -q` passes
</verification>

<success_criteria>
- PythonSKATBackend is a complete SKATBackend implementation using only numpy/scipy/statsmodels
- SKAT, Burden, and SKAT-O methods all produce valid results
- Factory and registry wiring allows --skat-backend python to work end-to-end
- Eigenvalue computation matches R formulation (eigh driver='evr', correct threshold)
- Response residuals (not deviance/Pearson) used throughout
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/21-pure-python-skat-backend/21-02-SUMMARY.md`
</output>
