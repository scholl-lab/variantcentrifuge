---
phase: 24-pure-python-coast-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - variantcentrifuge/association/backends/coast_python.py
  - variantcentrifuge/association/tests/allelic_series_python.py
autonomous: true

must_haves:
  truths:
    - "PythonCOASTBackend computes 6 burden p-values (3 models x 2 encodings) and 1 allelic SKAT p-value"
    - "PythonCOASTBackend combines 7 p-values via Cauchy with weights [1,1,1,1,1,1,6]"
    - "PurePythonCOASTTest declares parallel_safe=True"
    - "PurePythonCOASTTest.name returns 'coast' (same as COASTTest for registry swap)"
    - "PurePythonCOASTTest reuses classify_variants() from allelic_series.py"
  artifacts:
    - path: "variantcentrifuge/association/backends/coast_python.py"
      provides: "PythonCOASTBackend with test_gene(), _aggregate_by_category(), burden tests, allelic SKAT"
      min_lines: 120
    - path: "variantcentrifuge/association/tests/allelic_series_python.py"
      provides: "PurePythonCOASTTest wrapping PythonCOASTBackend"
      min_lines: 80
  key_links:
    - from: "variantcentrifuge/association/tests/allelic_series_python.py"
      to: "variantcentrifuge/association/backends/coast_python.py"
      via: "PurePythonCOASTTest delegates to PythonCOASTBackend.test_gene()"
      pattern: "PythonCOASTBackend"
    - from: "variantcentrifuge/association/backends/coast_python.py"
      to: "variantcentrifuge/association/backends/python_backend.py"
      via: "Reuses PythonSKATBackend.fit_null_model() and _compute_eigenvalues_filtered()"
      pattern: "PythonSKATBackend"
    - from: "variantcentrifuge/association/backends/coast_python.py"
      to: "variantcentrifuge/association/tests/acat.py"
      via: "cauchy_combination() for omnibus p-value"
      pattern: "cauchy_combination"
    - from: "variantcentrifuge/association/tests/allelic_series_python.py"
      to: "variantcentrifuge/association/tests/allelic_series.py"
      via: "Imports classify_variants() for BMV/DMV/PTV annotation"
      pattern: "classify_variants"
---

<objective>
Implement PythonCOASTBackend (pure math layer) and PurePythonCOASTTest (AssociationTest wrapper) for the COAST allelic series test without R/rpy2 dependency.

Purpose: Enable COAST analysis without R installed, with parallel_safe=True for multi-threaded gene analysis.
Output: Two new Python files implementing the full COAST algorithm using existing infrastructure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/PURE_PYTHON_COAST_PLAN.md
@.planning/phases/24-pure-python-coast-backend/24-RESEARCH.md

# Key source files to study for patterns:
@variantcentrifuge/association/backends/python_backend.py
@variantcentrifuge/association/tests/skat_python.py
@variantcentrifuge/association/tests/allelic_series.py
@variantcentrifuge/association/tests/acat.py
@variantcentrifuge/association/base.py
@variantcentrifuge/association/backends/davies.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PythonCOASTBackend — pure math layer</name>
  <files>variantcentrifuge/association/backends/coast_python.py</files>
  <action>
Create `variantcentrifuge/association/backends/coast_python.py` implementing `PythonCOASTBackend`.

The class implements the COAST algorithm (McCaw et al., AJHG 2023) decomposed into 3 layers:

**Layer 1 — 6 burden tests (3 models x 2 encodings):**

Helper function `_aggregate_by_category(geno, anno_codes, weights, indicator=False, method="none")`:
- For each category (BMV=1, DMV=2, PTV=3): sum genotype dosages across variants in that category per sample
- If `indicator=True`, convert per-category allele counts to 0/1 carrier indicators
- `method="none"`: return 3-column matrix (n_samples, 3) for baseline 3-df test
- `method="sum"`: return weighted sum as (n_samples, 1) column
- `method="max"`: return max weighted value as (n_samples, 1) column

Helper function `_run_burden_test(predictor, phenotype, covariates, trait_type)`:
- `predictor` is either (n_samples, 3) for baseline or (n_samples, 1) for sum/max
- Build design matrix: `sm.add_constant(predictor)`, then append covariates if present
- For `trait_type == "quantitative"`:
  - Fit `sm.OLS(phenotype, design).fit()`
  - If 1-df (predictor has 1 column): return `fit.pvalues[1]`
  - If 3-df (baseline, predictor has 3 columns): use `fit.f_test()` with restriction matrix selecting the 3 burden coefficients (indices 1,2,3). Return `float(f_test.pvalue)`.
- For `trait_type == "binary"`:
  - Build null_design: intercept + covariates only (no burden predictor)
  - `null_fit = sm.Logit(phenotype, null_design).fit(disp=False, method='bfgs', maxiter=100)`
  - `full_fit = sm.Logit(phenotype, design).fit(disp=False, method='bfgs', maxiter=100)`
  - LRT: `lrt = 2 * (full_fit.llf - null_fit.llf)`, df = number of burden predictor columns
  - Return `float(scipy.stats.chi2.sf(max(lrt, 0), df=df))`
  - Wrap in try/except — on convergence failure return None

**CRITICAL pitfalls for burden tests (from 24-RESEARCH.md):**
- Baseline uses UNIFORM weights [1,1,1], NOT coast_weights. Only sum and max use coast_weights.
- Burden tests use fresh OLS/Logit regression, NOT SKAT null model residuals.
- Max model: compute `max(w1*N1, w2*N2, w3*N3)` per sample FIRST, then fit regression on that scalar. It's a standard 1-df regression.

**Layer 2 — Allelic SKAT (1 test):**

Helper function `_compute_allelic_skat_weights(geno_filtered, anno_codes_filtered, coast_weights)`:
- `aaf = geno_filtered.mean(axis=0) / 2.0` — alternate allele frequency per variant
- Clip aaf to [1e-8, 1-1e-8] to prevent division by zero
- Map coast_weights to per-variant: `w[anno == cat] = coast_weights[cat_index]`
- `v = aaf * (1 - aaf)` — NOTE: NOT 2*aaf*(1-aaf). This matches AllelicSeries R source.
- Return `np.sqrt(w / v)`

Method `_run_allelic_skat(geno_filtered, skat_weights, null_model)`:
- Apply weights: `geno_weighted = geno_filtered * skat_weights[np.newaxis, :]`
- Score statistic: `score_vec = geno_weighted.T @ null_model.extra["residuals"]`; `q_stat = (score_vec @ score_vec) / 2.0`
- Eigenvalues via `PythonSKATBackend._compute_eigenvalues_filtered(geno_weighted, null_model)` — instantiate a PythonSKATBackend internally for this
- If no eigenvalues above threshold, return 1.0
- P-value via `compute_pvalue(q_stat, lambdas)` from `backends/davies.py`
- Return float p-value

**Layer 3 — Cauchy omnibus:**

In `test_gene()`:
- Collect 6 burden p-values in order: base_count, base_ind, sum_count, sum_ind, max_count, max_ind
- Collect 1 SKAT p-value
- Call `cauchy_combination(all_7_pvals, weights=[1,1,1,1,1,1,6])` from `tests/acat.py`
- Return dict with keys: `p_value` (omnibus), `burden_p_values` (list of 6), `skat_p_value`, `burden_labels` (list of 6 names)

**Class structure:**

```python
class PythonCOASTBackend:
    def __init__(self):
        self._skat_backend = None  # Lazy init

    def _ensure_skat_backend(self):
        if self._skat_backend is None:
            from variantcentrifuge.association.backends.python_backend import PythonSKATBackend
            self._skat_backend = PythonSKATBackend()
            self._skat_backend.detect_environment()

    def test_gene(self, gene, geno_filtered, anno_codes_filtered, phenotype,
                  covariates, coast_weights, trait_type, null_model):
        # ... run all 7 components, combine, return dict
```

The `null_model` is passed in from PurePythonCOASTTest (which fits it lazily). The SKAT backend is only used for `_compute_eigenvalues_filtered()`.

Ruff: 100 char line length, Python 3.10+ target. Use `from __future__ import annotations`.
  </action>
  <verify>
`python -c "from variantcentrifuge.association.backends.coast_python import PythonCOASTBackend; print('OK')"` succeeds.
`ruff check variantcentrifuge/association/backends/coast_python.py` passes.
  </verify>
  <done>
PythonCOASTBackend class exists with test_gene() that computes 6 burden + 1 SKAT p-values and combines via Cauchy. All helper functions implemented with correct weight conventions (uniform for baseline, coast_weights for sum/max, aaf*(1-aaf) for SKAT variance).
  </done>
</task>

<task type="auto">
  <name>Task 2: PurePythonCOASTTest — AssociationTest wrapper</name>
  <files>variantcentrifuge/association/tests/allelic_series_python.py</files>
  <action>
Create `variantcentrifuge/association/tests/allelic_series_python.py` implementing `PurePythonCOASTTest`.

Follow the EXACT structural pattern of `PurePythonSKATTest` in `tests/skat_python.py`:

```python
class PurePythonCOASTTest(AssociationTest):
    parallel_safe: bool = True  # Thread-safe -- no rpy2

    def __init__(self):
        self._backend = None       # PythonCOASTBackend, lazy
        self._null_model = None    # NullModelResult, lazy
        # Lifecycle tracking
        self._total_genes = 0
        self._log_interval = 50
        self._genes_processed = 0
        self._start_time = 0.0

    @property
    def name(self) -> str:
        return "coast"  # Same name as COASTTest -- engine swaps implementation

    def check_dependencies(self) -> None:
        # Initialize backend (always succeeds -- pure Python deps)
        from variantcentrifuge.association.backends.coast_python import PythonCOASTBackend
        self._backend = PythonCOASTBackend()

    def effect_column_names(self):
        return {"effect": None, "se": None, "ci_lower": None, "ci_upper": None}

    def prepare(self, gene_count):
        # Same pattern as COASTTest.prepare() -- no R gc()
        self._total_genes = gene_count
        self._genes_processed = 0
        self._log_interval = max(10, min(50, gene_count // 10)) if gene_count > 0 else 50
        self._start_time = time.time()
        logger.info(f"Python COAST: beginning allelic series analysis of {gene_count} genes")

    def finalize(self):
        elapsed = time.time() - self._start_time
        logger.info(f"Python COAST complete: {self._genes_processed} genes in {elapsed:.1f}s")

    def run(self, gene, contingency_data, config) -> TestResult:
        # 1. Extract geno, phenotype, covariates, gene_df from contingency_data
        #    (same guards as COASTTest.run() -- return TestResult with p_value=None on missing data)
        # 2. Find EFFECT/IMPACT columns (reuse _find_column from COASTTest or inline)
        # 3. classify_variants(gene_df, effect_col, impact_col)
        # 4. Filter geno to COAST-eligible variants (include_mask)
        # 5. Check all 3 categories present (BMV, DMV, PTV) -- skip if any missing
        # 6. Lazy null model: if self._null_model is None, fit via PythonSKATBackend.fit_null_model()
        # 7. Call self._backend.test_gene(...)
        # 8. Return TestResult with omnibus p_value, extra containing component p-values
```

**Key implementation details:**

- Reuse `classify_variants` from `variantcentrifuge.association.tests.allelic_series` (import it)
- Reuse column-finding constants: `EFFECT_COLUMN_CANDIDATES`, `IMPACT_COLUMN_CANDIDATES`
- The null model fitting should use `PythonSKATBackend.fit_null_model()` (via `self._backend._ensure_skat_backend()` then `self._backend._skat_backend.fit_null_model()`)
- The `run()` method must replicate ALL skip-condition guards from `COASTTest.run()` (no genotype matrix, no phenotype, no gene_df, annotation mismatch, missing categories) with identical `coast_skip_reason` values in `extra` dict
- `extra` dict keys must match COASTTest's output: `coast_burden_p_value` (from Cauchy of 6 burden pvals), `coast_skat_p_value`, `coast_n_bmv`, `coast_n_dmv`, `coast_n_ptv`
- Progress logging every `_log_interval` genes (same pattern as PurePythonSKATTest)
- `coast_weights` from `config.coast_weights` or default `[1.0, 2.0, 3.0]`

Ruff: 100 char line length, Python 3.10+ target. Use `from __future__ import annotations`.
  </action>
  <verify>
`python -c "from variantcentrifuge.association.tests.allelic_series_python import PurePythonCOASTTest; t = PurePythonCOASTTest(); print(t.name, t.parallel_safe)"` prints `coast True`.
`ruff check variantcentrifuge/association/tests/allelic_series_python.py` passes.
  </verify>
  <done>
PurePythonCOASTTest exists with parallel_safe=True, name="coast", delegates to PythonCOASTBackend, reuses classify_variants(), matches COASTTest's skip-condition guards and extra dict keys.
  </done>
</task>

</tasks>

<verification>
1. Both new files import without errors: `python -c "from variantcentrifuge.association.backends.coast_python import PythonCOASTBackend; from variantcentrifuge.association.tests.allelic_series_python import PurePythonCOASTTest"`
2. `ruff check variantcentrifuge/association/backends/coast_python.py variantcentrifuge/association/tests/allelic_series_python.py` passes
3. `ruff format --check variantcentrifuge/association/backends/coast_python.py variantcentrifuge/association/tests/allelic_series_python.py` passes
4. PurePythonCOASTTest.parallel_safe is True
5. PurePythonCOASTTest.name returns "coast"
</verification>

<success_criteria>
- PythonCOASTBackend.test_gene() computes all 7 COAST components and returns omnibus p-value via Cauchy combination
- PurePythonCOASTTest wraps PythonCOASTBackend following PurePythonSKATTest pattern exactly
- No R or rpy2 imports anywhere in the new files
- All existing tests still pass: `pytest tests/unit/test_coast.py -x`
</success_criteria>

<output>
After completion, create `.planning/phases/24-pure-python-coast-backend/24-01-SUMMARY.md`
</output>
