---
phase: 10-output-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - variantcentrifuge/dataframe_optimizer.py
  - variantcentrifuge/stages/output_stages.py
  - variantcentrifuge/converter.py
  - variantcentrifuge/generate_igv_report.py
  - tests/unit/test_gt_cache.py
autonomous: true

must_haves:
  truths:
    - "GT column is pre-parsed once at DataFrame load time into structured cache"
    - "converter.py finalize_excel_file uses cached GT data instead of re-parsing with regex"
    - "generate_igv_report.py uses cached GT data instead of re-parsing with regex"
    - "Cache columns (_GT_PARSED) are stripped before final output (TSV and Excel)"
    - "Final output format is unchanged - GT column still contains original string format"
  artifacts:
    - path: "variantcentrifuge/dataframe_optimizer.py"
      provides: "GT pre-parsing function and integration into load_optimized_dataframe"
      contains: "_GT_PARSED"
    - path: "tests/unit/test_gt_cache.py"
      provides: "Tests for GT parsing, cache integration, and cache cleanup"
      min_lines: 60
  key_links:
    - from: "variantcentrifuge/dataframe_optimizer.py:load_optimized_dataframe"
      to: "parse_gt_column"
      via: "called after DataFrame load, before return"
      pattern: "parse_gt_column|_GT_PARSED"
    - from: "variantcentrifuge/converter.py:finalize_excel_file"
      to: "_GT_PARSED cache"
      via: "uses pre-parsed data instead of regex per row"
      pattern: "_GT_PARSED|gt_cache"
    - from: "variantcentrifuge/stages/output_stages.py:TSVOutputStage"
      to: "cache column cleanup"
      via: "drops _-prefixed columns before output"
      pattern: "startswith.*_|drop.*_GT"
---

<objective>
Pre-parse GT column once at DataFrame load time and eliminate redundant regex parsing across downstream stages.

Purpose: GT column parsing (regex `([^()]+)\(([^)]+)\)`) currently happens independently in converter.py (finalize_excel_file for IGV links), converter.py (produce_report_json for IGV JSON), and generate_igv_report.py. Pre-parsing once at load time eliminates redundant work and provides structured data for all downstream consumers.

Output: GT cache in dataframe_optimizer.py, updated consumers to use cache, cache cleanup before output, tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-output-optimization/10-CONTEXT.md
@.planning/phases/10-output-optimization/10-RESEARCH.md

Key source files:
@variantcentrifuge/dataframe_optimizer.py
@variantcentrifuge/converter.py (lines 264-345 for finalize_excel_file GT parsing)
@variantcentrifuge/generate_igv_report.py (line 247 for GT parsing)
@variantcentrifuge/stages/output_stages.py (TSVOutputStage, ExcelReportStage)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GT pre-parsing to dataframe_optimizer and wire into load path</name>
  <files>
    variantcentrifuge/dataframe_optimizer.py
    variantcentrifuge/stages/output_stages.py
  </files>
  <action>
1. In `dataframe_optimizer.py`, add module-level compiled regex:
   ```python
   GT_PATTERN = re.compile(r"([^()]+)\(([^)]+)\)")
   ```

2. Add `parse_gt_column(df)` function:
   - Input: DataFrame with GT column containing strings like "Sample1(0/1);Sample2(1/1);Sample3(0/0)"
   - Parse each GT value into a list of dicts: `[{"sample": "Sample1", "gt": "0/1"}, ...]`
   - Store as `_GT_PARSED` column (list of dicts per row)
   - Handle edge cases: pd.isna, empty strings, missing GT column
   - Skip rows where GT is NaN/empty (store empty list)
   - Use the module-level GT_PATTERN constant
   - Return modified DataFrame

3. Integrate into `load_optimized_dataframe()`:
   - After column sanitization (step 4), check for GT column
   - The GT column may be renamed to something else by sanitization - check both "GT" and the sanitized name
   - Call `parse_gt_column(df)` if GT column exists and DataFrame is non-empty
   - Log: "Pre-parsed GT column for {n} rows"

4. In `TSVOutputStage._process()` in output_stages.py, add cache column cleanup before writing:
   - Before the column rename restoration block (line ~531), add:
     ```python
     # Drop internal cache columns before output
     cache_cols = [c for c in df.columns if c.startswith('_')]
     if cache_cols:
         df = df.drop(columns=cache_cols)
         logger.debug(f"Dropped {len(cache_cols)} cache columns: {cache_cols}")
     ```
   - This ensures _GT_PARSED never appears in final TSV output.

5. In `ExcelReportStage._process()` in output_stages.py, add same cache column cleanup:
   - After copying variants_df (line ~600), drop cache columns from excel_df:
     ```python
     cache_cols = [c for c in excel_df.columns if c.startswith('_')]
     if cache_cols:
         excel_df = excel_df.drop(columns=cache_cols)
     ```
  </action>
  <verify>
    - `python -c "from variantcentrifuge.dataframe_optimizer import parse_gt_column; print('ok')"` succeeds
    - `make lint` passes
    - `pytest tests/unit/ -x -q --no-header` passes
  </verify>
  <done>
    - parse_gt_column function exists in dataframe_optimizer.py
    - _GT_PARSED column created during load_optimized_dataframe
    - Cache columns dropped before TSV and Excel output
    - All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Update downstream GT consumers to use cache + add tests</name>
  <files>
    variantcentrifuge/converter.py
    variantcentrifuge/generate_igv_report.py
    tests/unit/test_gt_cache.py
  </files>
  <action>
1. In `converter.py` `finalize_excel_file()` (the IGV links section, lines 285-310):
   - The finalize function works on openpyxl worksheet objects, not DataFrames. It reads GT cell values from the Excel sheet. Since it operates on already-written Excel data, it cannot directly use the _GT_PARSED cache from the DataFrame.
   - **However**, we can optimize the regex: use the module-level GT_PATTERN constant (added in Plan 01) instead of recompiling inside the loop at line 286. If Plan 01 hasn't run yet, add the module-level GT_PATTERN here.
   - Move `pattern = re.compile(r"([^()]+)\(([^)]+)\)")` from inside the loop to module-level `GT_PATTERN`.

2. In `converter.py` `produce_report_json()` (line 425):
   - Same optimization: use module-level GT_PATTERN instead of compiling inside the function.

3. In `generate_igv_report.py` (line 247):
   - Read the file to find where GT parsing happens. Move regex compilation to module level.
   - If the function receives a DataFrame with _GT_PARSED column, use it instead of re-parsing.
   - If it reads from a TSV file (no _GT_PARSED), fall back to regex parsing.

4. Create `tests/unit/test_gt_cache.py`:

   a. `test_parse_gt_column_basic()` - Parse a simple GT string, verify output structure:
      - Input: "Sample1(0/1);Sample2(1/1)"
      - Output: [{"sample": "Sample1", "gt": "0/1"}, {"sample": "Sample2", "gt": "1/1"}]

   b. `test_parse_gt_column_empty_values()` - NaN, empty string, None all produce empty list

   c. `test_parse_gt_column_single_sample()` - Single sample GT string

   d. `test_parse_gt_column_reference_genotype()` - Includes 0/0 and ./. entries (still parsed, filtering is downstream)

   e. `test_load_optimized_with_gt_cache(tmp_path)` - Write a TSV with GT column, load via load_optimized_dataframe, verify _GT_PARSED column exists and is correct

   f. `test_cache_columns_not_in_output()` - Verify that columns starting with _ are dropped by checking the cleanup logic works (create a DataFrame with _GT_PARSED, simulate the drop logic, verify it's gone)

Mark all tests with `@pytest.mark.unit`.
  </action>
  <verify>
    - `pytest tests/unit/test_gt_cache.py -v` passes all tests
    - `make lint` passes
    - `pytest tests/unit/ -x -q --no-header` passes (no regressions)
  </verify>
  <done>
    - GT regex compiled at module level in converter.py and generate_igv_report.py
    - All downstream GT consumers use centralized pattern (no inline re.compile)
    - 6+ tests covering GT parsing, caching, and cleanup
    - All tests pass
  </done>
</task>

</tasks>

<verification>
- `make ci-check` passes
- _GT_PARSED column exists after load_optimized_dataframe on DataFrames with GT column
- _GT_PARSED column does NOT appear in any output file (TSV or Excel)
- GT regex compiled exactly once at module level (grep confirms no re.compile inside functions for GT pattern)
</verification>

<success_criteria>
- GT pre-parsed once at DataFrame load time (grep confirms parse_gt_column call in load_optimized_dataframe)
- No inline GT regex compilation in converter.py or generate_igv_report.py
- Cache columns stripped before all output
- All unit tests pass including new GT cache tests
</success_criteria>

<output>
After completion, create `.planning/phases/10-output-optimization/10-02-SUMMARY.md`
</output>
