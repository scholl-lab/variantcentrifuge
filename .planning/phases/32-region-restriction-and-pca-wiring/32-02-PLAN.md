---
phase: 32-region-restriction-and-pca-wiring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - variantcentrifuge/cli.py
  - variantcentrifuge/stages/processing_stages.py
  - variantcentrifuge/stages/analysis_stages.py
  - variantcentrifuge/pipeline.py
  - tests/unit/stages/test_processing_stages.py
  - tests/unit/test_pca.py
autonomous: true

must_haves:
  truths:
    - "When --pca akt is set, PCA eigenvectors are computed automatically via AKT subprocess"
    - "When --pca /path/to/eigenvec is set, the pre-computed file is used directly"
    - "PCA eigenvectors computed by the stage appear as covariates in association test output"
    - "PCAComputationStage runs before AssociationAnalysisStage in the pipeline"
  artifacts:
    - path: "variantcentrifuge/stages/processing_stages.py"
      provides: "PCAComputationStage class"
      contains: "class PCAComputationStage"
    - path: "variantcentrifuge/pipeline.py"
      provides: "PCAComputationStage wired into build_pipeline_stages"
      contains: "PCAComputationStage"
    - path: "variantcentrifuge/stages/analysis_stages.py"
      provides: "AssociationAnalysisStage reads pca_computation result"
      contains: "pca_computation"
    - path: "variantcentrifuge/cli.py"
      provides: "Unified --pca flag replacing --pca-file and --pca-tool"
      contains: '"--pca"'
    - path: "tests/unit/stages/test_processing_stages.py"
      provides: "PCAComputationStage unit tests"
      contains: "PCAComputationStage"
  key_links:
    - from: "variantcentrifuge/cli.py"
      to: "variantcentrifuge/stages/processing_stages.py"
      via: "cfg['pca'] config key auto-detected as file or tool"
      pattern: 'cfg\["pca"\]'
    - from: "variantcentrifuge/stages/processing_stages.py"
      to: "variantcentrifuge/stages/analysis_stages.py"
      via: "context.stage_results['pca_computation']['pca_file']"
      pattern: "pca_computation"
    - from: "variantcentrifuge/pipeline.py"
      to: "variantcentrifuge/stages/processing_stages.py"
      via: "PCAComputationStage import and append"
      pattern: "PCAComputationStage"
---

<objective>
Wire PCAComputationStage into the pipeline so --pca akt runs AKT via subprocess and feeds eigenvectors to AssociationAnalysisStage automatically.

Purpose: Users currently must run AKT externally and pass the eigenvector file via --pca-file. This wires PCA computation into the pipeline as a proper stage, with a unified --pca flag that auto-detects whether the argument is a tool name or a file path.

Output: PCAComputationStage class, unified --pca CLI flag, pipeline wiring, AssociationAnalysisStage integration, unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-region-restriction-and-pca-wiring/32-RESEARCH.md

@variantcentrifuge/cli.py (lines 560-575: existing --pca-file/--pca-tool flags; lines 1226-1229: PCA config mapping; lines 1406-1410: PCA validation)
@variantcentrifuge/stages/processing_stages.py
@variantcentrifuge/stages/analysis_stages.py (lines 2204-2235: AssociationAnalysisStage class; lines 2269-2290: _process start; lines 2446-2455: PCA loading; lines 1946-1965: VALID_ASSOCIATION_KEYS)
@variantcentrifuge/pipeline.py (lines 128-327: build_pipeline_stages; lines 285-286: association stage insertion)
@variantcentrifuge/pipeline_core/context.py (get_result, mark_complete)
@variantcentrifuge/association/pca.py
@tests/unit/test_pca.py
@tests/unit/stages/test_processing_stages.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PCAComputationStage and unify --pca CLI flag</name>
  <files>variantcentrifuge/stages/processing_stages.py, variantcentrifuge/cli.py</files>
  <action>
**In processing_stages.py**, add `PCAComputationStage` class at the end of the file:

```python
class PCAComputationStage(Stage):
    """Compute or load PCA eigenvectors for association covariate adjustment."""

    @property
    def name(self) -> str:
        return "pca_computation"

    @property
    def description(self) -> str:
        return "Compute or load PCA eigenvectors"

    @property
    def dependencies(self) -> set[str]:
        return {"sample_config_loading", "configuration_loading"}

    @property
    def parallel_safe(self) -> bool:
        return False  # AKT subprocess not thread-safe

    def _process(self, context: PipelineContext) -> PipelineContext:
        pca_arg = context.config.get("pca")
        if not pca_arg:
            return context

        n_components = context.config.get("pca_components", 10)

        if os.path.isfile(pca_arg):
            pca_file = pca_arg
            logger.info(f"PCA: using pre-computed eigenvectors from {pca_file}")
        elif pca_arg == "akt":
            pca_file = self._run_akt(context, n_components)
        else:
            raise ValueError(
                f"--pca argument '{pca_arg}' is neither a valid file path "
                "nor a recognized tool name ('akt')."
            )

        # Store pca_file in config so _build_assoc_config_from_context picks it up
        context.config["pca_file"] = pca_file
        context.mark_complete(self.name, result={"pca_file": pca_file})
        return context

    def _run_akt(self, context: PipelineContext, n_components: int) -> str:
        vcf_file = context.config.get("vcf_file")
        if not vcf_file:
            raise ValueError("--pca akt requires a VCF file (--vcf-file)")

        output_path = context.workspace.get_intermediate_path(
            f"{context.workspace.base_name}.pca.eigenvec"
        )

        # Simple cache: reuse if output exists and is non-empty
        if output_path.exists() and output_path.stat().st_size > 0:
            logger.info(f"PCA: reusing cached eigenvectors from {output_path}")
            return str(output_path)

        cmd = ["akt", "pca", vcf_file, "-o", str(output_path), "-n", str(n_components)]
        logger.info(f"Running AKT PCA: {' '.join(cmd)}")

        try:
            subprocess.run(cmd, capture_output=True, text=True, check=True)
        except subprocess.CalledProcessError as e:
            raise RuntimeError(
                f"AKT PCA failed (exit code {e.returncode}): {e.stderr}"
            ) from e
        except FileNotFoundError as e:
            raise RuntimeError(
                "AKT not found in PATH. Install akt or use --pca <eigenvec_file> "
                "to supply pre-computed eigenvectors."
            ) from e

        if not output_path.exists() or output_path.stat().st_size == 0:
            raise RuntimeError(
                "AKT PCA completed but produced no output. "
                "Check that the VCF has sufficient samples and variants."
            )

        return str(output_path)
```

**In cli.py**, replace the existing `--pca-file` and `--pca-tool` arguments (lines ~560-573) with a single `--pca` argument:

```python
# Phase 32: Unified PCA argument (replaces --pca-file and --pca-tool)
assoc_group.add_argument(
    "--pca",
    help="PCA eigenvectors: path to pre-computed file (PLINK .eigenvec, AKT output, "
         "or generic TSV), or 'akt' to compute via AKT as a pipeline stage.",
    default=None,
)
assoc_group.add_argument(
    "--pca-components",
    type=int,
    default=10,
    help="Number of principal components to use as covariates (default: 10).",
)
```

Keep `--pca-file` and `--pca-tool` as hidden deprecated aliases that map to `--pca` for backward compatibility. Use `argparse.SUPPRESS` for help text:

```python
# Deprecated aliases (backward compatibility)
assoc_group.add_argument("--pca-file", dest="pca", help=argparse.SUPPRESS, default=None)
assoc_group.add_argument("--pca-tool", dest="pca", help=argparse.SUPPRESS, default=None)
```

**IMPORTANT:** Since both `--pca-file` and `--pca-tool` now share `dest="pca"`, and the new `--pca` also uses `dest="pca"`, they all map to `args.pca`. Remove the old flags' original definitions entirely and replace with the above.

In the config mapping section (~line 1226), replace:
```python
cfg["pca_file"] = getattr(args, "pca_file", None)
cfg["pca_tool"] = getattr(args, "pca_tool", None)
```
with:
```python
cfg["pca"] = getattr(args, "pca", None)
```

Keep `cfg["pca_components"]` as-is.

In the validation section (~lines 1406-1410), replace the two PCA validation blocks with:
```python
if getattr(args, "pca", None) and not args.perform_association:
    parser.error("--pca requires --perform-association to be set")
```

Add `"pca"` to `VALID_ASSOCIATION_KEYS` in analysis_stages.py (keep `"pca_file"` and `"pca_tool"` for JSON config backward compat).
  </action>
  <verify>
Run `python -c "from variantcentrifuge.cli import create_parser; p = create_parser(); a = p.parse_args(['--vcf-file', 'x.vcf', '-g', 'BRCA1', '--perform-association', '--pca', 'akt']); print(a.pca)"` — prints "akt".
Run `python -c "from variantcentrifuge.cli import create_parser; p = create_parser(); a = p.parse_args(['--vcf-file', 'x.vcf', '-g', 'BRCA1', '--perform-association', '--pca-file', '/tmp/test.eigenvec']); print(a.pca)"` — prints "/tmp/test.eigenvec" (backward compat).
Run `make lint` — no errors.
  </verify>
  <done>
PCAComputationStage class exists in processing_stages.py with _run_akt method. --pca unified CLI flag replaces --pca-file/--pca-tool with backward-compatible hidden aliases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire PCAComputationStage into pipeline and AssociationAnalysisStage</name>
  <files>variantcentrifuge/pipeline.py, variantcentrifuge/stages/analysis_stages.py, tests/unit/stages/test_processing_stages.py, tests/unit/test_pca.py</files>
  <action>
**In pipeline.py:**

1. Add import at top (in the processing_stages import block, ~line 42-53):
   ```python
   from .stages.processing_stages import (
       ...,
       PCAComputationStage,
   )
   ```

2. In `build_pipeline_stages()`, insert PCAComputationStage BEFORE the AssociationAnalysisStage block (~line 285). Add it when `pca` is set in args or config:
   ```python
   # PCA computation stage (Phase 32)
   pca_arg = getattr(args, "pca", None) or config.get("pca")
   if pca_arg:
       stages.append(PCAComputationStage())
   ```

3. In `create_stages_from_config()` (~line 330+), add:
   ```python
   args.pca = config.get("pca")
   ```

**In analysis_stages.py:**

1. Add `"pca_computation"` to `AssociationAnalysisStage.soft_dependencies`:
   ```python
   @property
   def soft_dependencies(self) -> set[str]:
       return {"custom_annotation", "pca_computation"}
   ```

2. In `AssociationAnalysisStage._process()`, at the top (after the `perform_association` check, before `_build_assoc_config_from_context()`), add:
   ```python
   # PCA-02: pick up pca_file from PCAComputationStage result
   pca_result = context.get_result("pca_computation")
   if pca_result and isinstance(pca_result, dict):
       pca_file_from_stage = pca_result.get("pca_file")
       if pca_file_from_stage:
           context.config.setdefault("pca_file", pca_file_from_stage)
           logger.debug(
               f"Association: PCA file from pipeline stage: {pca_file_from_stage}"
           )
   ```

3. Add `"pca"` to `VALID_ASSOCIATION_KEYS` frozenset (keep existing `"pca_file"` and `"pca_tool"` for backward compat).

**Tests in test_processing_stages.py** — add `TestPCAComputationStage` class:

- `test_pca_file_path`: Set `context.config["pca"] = str(tmp_eigenvec_file)` where tmp_eigenvec_file is a temp file with eigenvector content. Verify `context.config["pca_file"]` is set to that path after _process().
- `test_pca_akt_tool`: Set `context.config["pca"] = "akt"` and `context.config["vcf_file"] = "test.vcf"`. Mock `subprocess.run`. Verify _run_akt is called and context.config["pca_file"] is set.
- `test_pca_invalid_arg`: Set `context.config["pca"] = "unknown_tool"`. Assert ValueError with "neither a valid file path nor a recognized tool name".
- `test_pca_no_arg_skips`: Set no `pca` config key. Verify _process returns context unchanged (no mark_complete called).
- `test_pca_akt_not_found`: Mock subprocess.run to raise FileNotFoundError. Assert RuntimeError with "AKT not found".
- `test_pca_akt_failure`: Mock subprocess.run to raise CalledProcessError. Assert RuntimeError with "AKT PCA failed".
- `test_pca_akt_cache_reuse`: Create the expected output file before calling _process. Verify subprocess.run is NOT called (cache hit).

Create a minimal PipelineContext mock or use the existing test fixtures from test_processing_stages.py. The context needs: `config` dict, `workspace` with `get_intermediate_path` method, `mark_complete` method, `get_result` method.

**Tests in test_pca.py** — verify the existing tests still pass (no changes needed to test_pca.py itself, but ensure the test file is not broken by import changes).

Run full test suite to confirm no regressions.
  </action>
  <verify>
Run `pytest tests/unit/stages/test_processing_stages.py -v -k "PCA" --no-header` — all PCA stage tests pass.
Run `pytest tests/unit/test_pca.py -v --no-header` — all existing PCA tests pass.
Run `make ci-check` — all CI checks pass.
Run `python -c "from variantcentrifuge.pipeline import build_pipeline_stages; import argparse; a = argparse.Namespace(config={}, pca='akt', perform_association=True, threads=1, gene_name='BRCA1', vcf_file='x.vcf', no_replacement=False, no_stats=False, scoring_config_path=None, ped_file=None, annotate_bed=None, annotate_gene_list=None, annotate_json_genes=None, late_filtering=False, final_filter=None, pseudonymize=False, xlsx=False, html_report=False, igv=False, no_metadata=False, archive_results=False, snpeff_split_by_transcript=False, append_extra_sample_fields=None, clinvar_pm5_lookup=None, inheritance_mode=None, perform_gene_burden=False); stages = build_pipeline_stages(a); names = [s.name for s in stages]; print('pca_computation' in names, names.index('pca_computation') < names.index('association_analysis'))"` — prints `True True`.
  </verify>
  <done>
PCAComputationStage is wired into pipeline.py before AssociationAnalysisStage. AssociationAnalysisStage reads pca_computation result as a soft dependency. VALID_ASSOCIATION_KEYS includes "pca". 7+ unit tests cover PCA stage paths. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `pytest tests/unit/stages/test_processing_stages.py -v -k "PCA"` — all PCA stage tests pass
- `pytest tests/unit/test_pca.py -v` — all existing PCA file loading tests pass
- `make ci-check` — lint, format, typecheck, test-fast all pass
- Grep for `class PCAComputationStage` in processing_stages.py confirms stage exists
- Grep for `"pca_computation"` in analysis_stages.py confirms soft dependency
- Grep for `PCAComputationStage` in pipeline.py confirms wiring
- Grep for `"--pca"` in cli.py confirms unified flag
- Grep for `"--pca-file"` in cli.py confirms backward-compatible hidden alias
</verification>

<success_criteria>
1. PCAComputationStage class exists with _run_akt subprocess invocation
2. --pca unified flag auto-detects file path vs tool name
3. --pca-file and --pca-tool still work as hidden deprecated aliases
4. PCAComputationStage runs before AssociationAnalysisStage (soft dependency)
5. AssociationAnalysisStage picks up pca_file from stage result
6. "pca" added to VALID_ASSOCIATION_KEYS
7. AKT cache reuse works (skip subprocess if output exists)
8. All existing tests pass (no regressions)
9. 7+ new unit tests covering PCA stage paths
</success_criteria>

<output>
After completion, create `.planning/phases/32-region-restriction-and-pca-wiring/32-02-SUMMARY.md`
</output>
