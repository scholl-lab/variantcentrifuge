---
phase: 11-pipeline-io-elimination
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - variantcentrifuge/stages/processing_stages.py
  - variantcentrifuge/stages/output_stages.py
  - variantcentrifuge/stages/analysis_stages.py
  - variantcentrifuge/phenotype.py
  - variantcentrifuge/dataframe_optimizer.py
  - variantcentrifuge/pipeline_core/context.py
autonomous: true

must_haves:
  truths:
    - "GenotypeReplacementStage is skipped — raw per-sample GT columns flow directly to analysis"
    - "TSV output contains reconstructed GT column in 'Sample(0/1);Sample2(1/1)' format"
    - "Excel output contains same reconstructed GT column"
    - "Phenotype integration works with raw per-sample columns instead of packed GT"
    - "Analysis stages (inheritance) work with per-sample columns from bcftools output"
    - "_GT_PARSED cache column and parse_gt_column() removed as dead code"
  artifacts:
    - path: "variantcentrifuge/stages/output_stages.py"
      provides: "GT reconstruction at output time in TSVOutputStage and ExcelReportStage"
      contains: "reconstruct_gt_column"
    - path: "variantcentrifuge/stages/processing_stages.py"
      provides: "GenotypeReplacementStage skipped, PhenotypeIntegrationStage updated"
      contains: "per-sample"
    - path: "variantcentrifuge/phenotype.py"
      provides: "Phenotype extraction from per-sample GT columns"
      contains: "extract_phenotypes_from_sample_columns"
    - path: "variantcentrifuge/dataframe_optimizer.py"
      provides: "Cleaned of _GT_PARSED dead code"
  key_links:
    - from: "variantcentrifuge/stages/output_stages.py"
      to: "context.vcf_samples"
      via: "GT reconstruction uses sample list"
      pattern: "vcf_samples"
    - from: "variantcentrifuge/stages/processing_stages.py"
      to: "variantcentrifuge/phenotype.py"
      via: "PhenotypeIntegrationStage calls new phenotype function"
      pattern: "extract_phenotypes_from_sample_columns"
---

<objective>
Eliminate the 7-hour GenotypeReplacementStage by deferring GT formatting to output time, and update all consumers of the packed GT format.

Purpose: The genotype replacement stage takes 7 hours on large cohorts to convert per-sample GT columns into "Sample(0/1);Sample2(1/1)" packed format. With bcftools query (Plan 01) now providing per-sample columns directly, analysis stages already work with them. We only need the packed format for final TSV/Excel output. This plan defers GT reconstruction to output time (runs once at the end, ~1 minute) and updates phenotype integration to work with raw per-sample columns.

Output: Modified processing stages (skip GenotypeReplacementStage), updated output stages (GT reconstruction), updated phenotype integration, removed _GT_PARSED dead code.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-pipeline-io-elimination/11-CONTEXT.md
@.planning/phases/11-pipeline-io-elimination/11-RESEARCH.md
@.planning/phases/11-pipeline-io-elimination/11-01-SUMMARY.md

@variantcentrifuge/stages/processing_stages.py (GenotypeReplacementStage ~1121-1256, PhenotypeIntegrationStage ~1735-1862)
@variantcentrifuge/stages/output_stages.py (TSVOutputStage ~406-557, ExcelReportStage ~559-640)
@variantcentrifuge/stages/analysis_stages.py (create_sample_columns_from_gt_intelligent ~187-263, DataFrameLoadingStage ~477-576)
@variantcentrifuge/phenotype.py (extract_phenotypes_for_gt_row ~150-202)
@variantcentrifuge/dataframe_optimizer.py (parse_gt_column, _GT_PARSED, GT_PATTERN)
@variantcentrifuge/pipeline_core/context.py (context fields)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Skip GenotypeReplacementStage + update PhenotypeIntegrationStage + add GT reconstruction to output stages</name>
  <files>variantcentrifuge/stages/processing_stages.py, variantcentrifuge/stages/output_stages.py, variantcentrifuge/phenotype.py</files>
  <action>
**A. GenotypeReplacementStage — make it a no-op:**

In `GenotypeReplacementStage._process()` (processing_stages.py ~line 1166):
- At the top of `_process()`, add: immediately return context without doing any work. Log an info message: "Genotype replacement skipped — raw per-sample GT columns flow directly to analysis (Phase 11)".
- Do NOT delete the class yet (Plan 03 handles cleanup). Just short-circuit it.
- Remove the `from ..replacer import replace_genotypes` import at the top of the file (line 39). Add a comment noting replacer.py is deprecated.

**B. PhenotypeIntegrationStage — update to use per-sample columns:**

In `PhenotypeIntegrationStage._process()` (processing_stages.py ~line 1805):
- Currently it reads a TSV, checks for GT column, and calls `extract_phenotypes_for_gt_row(gt_val, phenotype_data)` which parses packed format "Sample(0/1);Sample2(1/1)".
- Change it to work with per-sample columns:
  1. Instead of checking for "GT" column, check for sample columns using `context.vcf_samples`
  2. For each row, iterate over `context.vcf_samples`, check each sample's GT value (the per-sample column). If GT is not reference (not 0/0, ./., empty, NA), include that sample's phenotype.
  3. Call a new function `extract_phenotypes_from_sample_columns()` from phenotype.py
  4. Format output as "Sample1(pheno1,pheno2);Sample2(pheno3)" — same format as before
- Update the import at the top: add `extract_phenotypes_from_sample_columns` alongside existing `extract_phenotypes_for_gt_row`
- The stage should also handle the case where per-sample columns don't exist (fallback to old GT-based approach for backwards compatibility with old checkpoints — though these are officially unsupported, graceful handling is better than crashes)

**C. Add extract_phenotypes_from_sample_columns() to phenotype.py:**

Add a new function that takes a DataFrame row (as Series or namedtuple), vcf_samples list, and phenotypes dict:
```python
def extract_phenotypes_from_sample_columns(
    row, vcf_samples: list[str], phenotypes: dict[str, set[str]]
) -> str:
```
- For each sample in vcf_samples, get the GT value from the row
- Skip reference genotypes: 0/0, ./., empty, NA, "."
- For samples with variants, format as "SampleID(pheno1,pheno2)" using sorted phenotypes
- Samples with variants but no phenotypes get "SampleID()"
- Join all entries with ";"
- Return the formatted string

**D. Add GT reconstruction to TSVOutputStage and ExcelReportStage:**

Create a helper function `reconstruct_gt_column()` in output_stages.py (or a shared location):
```python
def reconstruct_gt_column(df: pd.DataFrame, vcf_samples: list[str]) -> pd.DataFrame:
```
- For each row, iterate over vcf_samples
- For each sample column, get GT value
- Skip reference/missing: 0/0, ./., empty, NA, pd.isna(), "."
- Build entry: "SampleName(gt_value)"
- Join with ";" into a single GT column
- Use df.apply(build_gt_string, axis=1) — this runs once at output time, acceptable performance
- Insert the GT column at the position where it would normally appear (after the last non-sample column, or at the end)
- Drop the per-sample columns from the output DataFrame (they should not appear in final TSV/Excel)
- Return the modified DataFrame

**In TSVOutputStage._process()** (output_stages.py ~line 447):
- After the existing df retrieval but BEFORE writing output (before the links section around line 507):
  - Check if per-sample columns exist by looking for `context.vcf_samples` columns in df
  - If they exist and "GT" column does NOT exist, call `reconstruct_gt_column(df, context.vcf_samples)`
  - This reconstructs the packed GT format and drops per-sample columns before output

**In ExcelReportStage._process()** (output_stages.py ~line 588):
- When preparing excel_df from context.variants_df (around line 605):
  - After dropping cache columns and before restoring column names:
  - Same check: if per-sample columns exist and GT doesn't, call `reconstruct_gt_column()`
  - Pass context.vcf_samples

Important: The reconstruct_gt_column must be called BEFORE column rename restoration (which converts sanitized names back to originals), because per-sample column names are sample IDs (not sanitized names).

**E. Update DataFrameLoadingStage soft_dependencies:**

In analysis_stages.py DataFrameLoadingStage.soft_dependencies (line ~505):
- Keep "genotype_replacement" in soft_dependencies for now (the stage still exists, just no-ops)
- The `_find_input_file()` method (line ~557) has priority: extra_columns_removed > phenotypes_added > genotype_replaced > extracted. Since genotype_replaced_tsv will be None (stage no-ops), it will naturally fall through to extracted_tsv. No code change needed here.

**F. Handle create_sample_columns_from_gt_intelligent:**

In analysis_stages.py, the `create_sample_columns_from_gt_intelligent()` function (line ~187) is called by InheritanceAnalysisStage to create per-sample columns from the GT column. With bcftools output, per-sample columns already exist. The function already handles this case (line ~299-302: "Sample columns already exist, skipping creation"). No change needed — verify this path works.
  </action>
  <verify>
    `ruff check variantcentrifuge/stages/processing_stages.py variantcentrifuge/stages/output_stages.py variantcentrifuge/phenotype.py` passes.
    `ruff format --check variantcentrifuge/stages/processing_stages.py variantcentrifuge/stages/output_stages.py variantcentrifuge/phenotype.py` passes.
    `python -c "from variantcentrifuge.stages.output_stages import reconstruct_gt_column; print('OK')"` succeeds.
    `python -c "from variantcentrifuge.phenotype import extract_phenotypes_from_sample_columns; print('OK')"` succeeds.
  </verify>
  <done>
    GenotypeReplacementStage no-ops immediately. PhenotypeIntegrationStage uses per-sample columns. TSVOutputStage and ExcelReportStage reconstruct GT at output time. New phenotype function handles per-sample format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove _GT_PARSED dead code + update tests</name>
  <files>variantcentrifuge/dataframe_optimizer.py, tests/unit/test_gt_cache.py, tests/unit/test_excel_full_fidelity.py, tests/performance/benchmark_excel_output.py</files>
  <action>
**A. Remove _GT_PARSED from dataframe_optimizer.py:**

Per 11-CONTEXT.md decision: "_GT_PARSED cache column is unused dead code (created but never consumed by any production code) and structurally incompatible with raw SnpSift format".

1. Remove the `parse_gt_column()` function entirely (around lines 107-180)
2. Remove the `GT_PATTERN` compiled regex constant (line 25)
3. Remove the `import re` if no longer needed
4. In `load_optimized_dataframe()` (around line 417-421), remove the block that calls `parse_gt_column(df)`:
   ```python
   # REMOVE THIS BLOCK:
   has_gt = any(col.upper() == "GT" or "GT" in col.upper() for col in df.columns)
   if has_gt:
       df = parse_gt_column(df)
       logger.info(f"Pre-parsed GT column for {len(df)} rows")
   ```

**B. Update test_gt_cache.py:**

This file tests the _GT_PARSED functionality. Since _GT_PARSED is being removed:
- Remove or rewrite tests that test parse_gt_column() and _GT_PARSED behavior
- If the file only tests _GT_PARSED, delete the entire file
- If it tests other things too, keep those tests and remove _GT_PARSED-specific ones

**C. Update test_excel_full_fidelity.py:**

Check if any tests reference _GT_PARSED or parse_gt_column. If so, remove those references. The Excel fidelity tests should still pass since the output format is unchanged (GT reconstruction produces the same packed format).

**D. Update benchmark_excel_output.py:**

Check if benchmarks reference _GT_PARSED. If so, update them. The benchmarks may create synthetic DataFrames with _GT_PARSED columns — remove those.

**E. Cache column cleanup in output stages:**

Both TSVOutputStage and ExcelReportStage already drop columns starting with "_" before output (cache_cols check). With _GT_PARSED removed, this cleanup code still works but there may be fewer (or no) cache columns to drop. No change needed, but verify the pattern still works.

After all removals, run `ruff check` and `ruff format` on modified files.
  </action>
  <verify>
    `pytest tests/unit/test_gt_cache.py -v` either passes (if rewritten) or file is deleted.
    `pytest tests/unit/test_excel_full_fidelity.py -v` passes.
    `pytest tests/performance/benchmark_excel_output.py -v --benchmark-disable` passes (just runs tests, skips benchmarks).
    `ruff check variantcentrifuge/dataframe_optimizer.py` passes.
    `pytest -m unit --timeout=120` all unit tests pass (no regressions from _GT_PARSED removal).
  </verify>
  <done>
    parse_gt_column() and _GT_PARSED removed from dataframe_optimizer.py. GT_PATTERN regex removed. Tests updated to not reference dead code. All existing unit tests pass.
  </done>
</task>

</tasks>

<verification>
- `pytest -m unit --timeout=120` all unit tests pass
- `make lint` passes
- `make format` passes
- GenotypeReplacementStage._process() returns immediately without processing
- TSVOutputStage reconstructs GT column from per-sample columns before writing
- ExcelReportStage reconstructs GT column from per-sample columns before writing
- PhenotypeIntegrationStage uses per-sample columns for phenotype extraction
- _GT_PARSED and parse_gt_column() no longer exist in codebase
</verification>

<success_criteria>
- GenotypeReplacementStage is effectively eliminated (no-op)
- GT column reconstructed at output time with correct "Sample(0/1);Sample2(1/1)" format
- Phenotype integration works with per-sample columns
- _GT_PARSED dead code completely removed
- No regressions in unit tests
- Per-sample columns dropped from final output (only packed GT appears)
</success_criteria>

<output>
After completion, create `.planning/phases/11-pipeline-io-elimination/11-02-SUMMARY.md`
</output>
