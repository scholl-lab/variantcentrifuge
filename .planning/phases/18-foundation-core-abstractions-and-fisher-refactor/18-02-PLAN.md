---
phase: 18-foundation-core-abstractions-and-fisher-refactor
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - variantcentrifuge/pipeline_core/context.py
  - variantcentrifuge/stages/analysis_stages.py
  - variantcentrifuge/stages/stage_registry.py
  - variantcentrifuge/pipeline.py
  - variantcentrifuge/gene_burden.py
autonomous: true

must_haves:
  truths:
    - "AssociationAnalysisStage runs in the pipeline when --perform-association is in context.config"
    - "AssociationAnalysisStage skips silently when perform_association is not set"
    - "GeneBurdenAnalysisStage is not modified — it runs normally when --perform-gene-burden is set, regardless of whether --perform-association is also set. It does NOT run when only --perform-association is set (it already has a config guard for perform_gene_burden). Both paths coexist independently."
    - "PipelineContext.association_results field exists and is merged correctly in merge_from()"
    - "gene_burden.py imports apply_correction from association.correction (no behavior change)"
  artifacts:
    - path: "variantcentrifuge/stages/analysis_stages.py"
      provides: "AssociationAnalysisStage"
      contains: "class AssociationAnalysisStage"
    - path: "variantcentrifuge/pipeline_core/context.py"
      provides: "association_results field"
      contains: "association_results"
    - path: "variantcentrifuge/stages/stage_registry.py"
      provides: "association_analysis registration"
      contains: "AssociationAnalysisStage"
    - path: "variantcentrifuge/pipeline.py"
      provides: "conditional stage inclusion"
      contains: "AssociationAnalysisStage"
    - path: "variantcentrifuge/gene_burden.py"
      provides: "correction import rewiring"
      contains: "from .association.correction import apply_correction"
  key_links:
    - from: "variantcentrifuge/stages/analysis_stages.py"
      to: "variantcentrifuge/association/engine.py"
      via: "AssociationEngine.from_names call"
      pattern: "AssociationEngine.from_names"
    - from: "variantcentrifuge/stages/analysis_stages.py"
      to: "variantcentrifuge/pipeline_core/context.py"
      via: "context.association_results assignment"
      pattern: "context\\.association_results"
    - from: "variantcentrifuge/gene_burden.py"
      to: "variantcentrifuge/association/correction.py"
      via: "import"
      pattern: "from .association.correction import apply_correction"
---

<objective>
Wire the association/ package into the stage-based pipeline: add AssociationAnalysisStage mirroring GeneBurdenAnalysisStage, extend PipelineContext with association_results field, register the stage, add it to pipeline.py stage list, and rewire gene_burden.py to import correction from association/correction.py.

Purpose: This connects the association abstractions (Plan 18-01) to the pipeline execution framework. Without this wiring, the association package is a dead library — this plan makes it executable.

Output: AssociationAnalysisStage registered and conditionally included in pipeline, PipelineContext extended, gene_burden.py correction rewired.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-CONTEXT.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-RESEARCH.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-01-SUMMARY.md
@variantcentrifuge/pipeline_core/context.py
@variantcentrifuge/stages/analysis_stages.py
@variantcentrifuge/stages/stage_registry.py
@variantcentrifuge/pipeline.py
@variantcentrifuge/gene_burden.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add association_results to PipelineContext and create AssociationAnalysisStage</name>
  <files>
    variantcentrifuge/pipeline_core/context.py
    variantcentrifuge/stages/analysis_stages.py
  </files>
  <action>
    **context.py** — Two changes:

    1. Add field after `gene_burden_results` (line 160):
       ```python
       association_results: pd.DataFrame | None = None
       ```

    2. In `merge_from()` method, add after the gene_burden_results merge block (after line 301):
       ```python
       if other.association_results is not None and self.association_results is None:
           self.association_results = other.association_results
       ```

    Also update the docstring to mention association_results.

    **analysis_stages.py** — Add `AssociationAnalysisStage` class. Model it EXACTLY after `GeneBurdenAnalysisStage` (lines 1810+). Place it after GeneBurdenAnalysisStage in the file. Add import at top: `from ..association.engine import AssociationEngine` and `from ..association.base import AssociationConfig`.

    ```python
    class AssociationAnalysisStage(Stage):
        @property
        def name(self) -> str:
            return "association_analysis"

        @property
        def description(self) -> str:
            return "Perform association analysis"

        @property
        def dependencies(self) -> set[str]:
            return {"dataframe_loading", "sample_config_loading"}

        @property
        def soft_dependencies(self) -> set[str]:
            return {"custom_annotation"}
    ```

    The `_process` method should:
    1. Check `context.config.get("perform_association")` — return early if not set (same guard as GeneBurdenAnalysisStage line 1870)
    2. Get test names from `context.config.get("association_tests", ["fisher"])`
    3. Eager dependency check: instantiate tests via `AssociationEngine.from_names(test_names, config)` and call `check_dependencies()` on each test. This fails fast before processing (CONTEXT.md requirement).
    4. Get case/control samples from context.config (same pattern as GeneBurdenAnalysisStage lines 1882-1904 — read case_samples, control_samples, log warning and return if empty)
    5. Get DataFrame from `context.current_dataframe` or `context.variants_df` (same fallback as GeneBurdenAnalysisStage)
    6. Build gene_burden_data using the SAME aggregation functions from gene_burden.py: `_aggregate_gene_burden_from_columns` or `_aggregate_gene_burden_from_gt` or `_aggregate_gene_burden_legacy`. Import these as `from ..gene_burden import _aggregate_gene_burden_from_columns, _aggregate_gene_burden_from_gt, _aggregate_gene_burden_legacy, _find_gt_columns`. This reuses the existing aggregation logic (which stays in gene_burden.py per CONTEXT.md).
       CRITICAL for bit-identity: pass `vcf_samples=list(context.vcf_samples) if context.vcf_samples else None` to `_aggregate_gene_burden_from_columns` — exactly as GeneBurdenAnalysisStage line 1979 does. This ensures the sample ordering and column selection is identical.
    7. Call `engine.run_all(gene_burden_data)` -> get results DataFrame
    8. Write results to TSV: `{base_name}.association.tsv` following gene_burden output pattern (analysis_stages.py lines 1990-2004). Store path in `context.config["association_output"]`.
    9. Store results: `context.association_results = results_df`
    10. Log summary at INFO: "Association analysis: {N} genes tested, {M} significant (FDR < 0.05)" (per CONTEXT.md logging spec)

    Also implement `_handle_checkpoint_skip` mirroring GeneBurdenAnalysisStage (lines 1835-1867) — restore association_output path from default location.

    Also implement `_get_input_files` and `_get_output_files` mirroring GeneBurdenAnalysisStage (lines 2014-2029).

    Build `AssociationConfig` from context.config: `AssociationConfig(correction_method=context.config.get("correction_method", "fdr"), gene_burden_mode=context.config.get("gene_burden_mode", "samples"), ...)`.

    IMPORTANT: The aggregation step must pick the same strategy as gene_burden.py (column-based > GT-based > legacy) to ensure identical contingency data. Reuse `_find_gt_columns` and the same priority logic from `perform_gene_burden_analysis` lines 380-404.

    IMPORTANT: Do NOT modify GeneBurdenAnalysisStage in any way. It remains completely unchanged. Both stages are independent — GeneBurdenAnalysisStage guards on `perform_gene_burden`, AssociationAnalysisStage guards on `perform_association`. Both can run in the same pipeline invocation without interference.
  </action>
  <verify>
    `make lint` passes (no import errors, no style violations in modified files).
    `python -c "from variantcentrifuge.stages.analysis_stages import AssociationAnalysisStage; s = AssociationAnalysisStage(); print(s.name, s.dependencies)"` prints `association_analysis {'dataframe_loading', 'sample_config_loading'}`.
    `python -c "from variantcentrifuge.pipeline_core.context import PipelineContext; print(hasattr(PipelineContext, '__dataclass_fields__') and 'association_results' in PipelineContext.__dataclass_fields__)"` prints `True`.
  </verify>
  <done>
    - AssociationAnalysisStage exists with correct name, dependencies, soft_dependencies
    - Stage uses same aggregation functions as GeneBurdenAnalysisStage (ensuring identical contingency data)
    - Stage passes vcf_samples to aggregation functions exactly as GeneBurdenAnalysisStage does
    - PipelineContext has association_results field with merge_from support
    - Stage writes association TSV and stores path in context.config["association_output"]
    - GeneBurdenAnalysisStage is completely unmodified
  </done>
</task>

<task type="auto">
  <name>Task 2: Register stage, add to pipeline.py, and rewire gene_burden.py correction</name>
  <files>
    variantcentrifuge/stages/stage_registry.py
    variantcentrifuge/pipeline.py
    variantcentrifuge/gene_burden.py
  </files>
  <action>
    **stage_registry.py** — In `_register_analysis_stages()`:
    1. Add import: `from .analysis_stages import AssociationAnalysisStage` (add to existing import block at line 484)
    2. Add registration after GeneBurdenAnalysisStage (after line 506):
       ```python
       register_stage(AssociationAnalysisStage, "analysis", ["association_analysis", "association"], 30.0)
       ```

    **pipeline.py** — In `build_stage_list` function:
    1. Add import at top: `from .stages.analysis_stages import AssociationAnalysisStage` (add to existing import at line 24)
    2. After the GeneBurdenAnalysisStage block (after line 282), add:
       ```python
       if hasattr(args, "perform_association") and args.perform_association:
           stages.append(AssociationAnalysisStage())
       ```

    **gene_burden.py** — Rewire correction to use association/correction.py:
    1. At top of file, after the existing `try: import statsmodels.stats.multitest as smm` block (lines 38-43), add:
       ```python
       try:
           from .association.correction import apply_correction as _apply_correction
       except ImportError:
           _apply_correction = None
       ```
    2. Replace the inline correction block at lines 502-510:
       - OLD: `if smm is None: ... else: if correction_method == "bonferroni": corrected_pvals = smm.multipletests(...)[1] else: ...`
       - NEW: Use `_apply_correction` if available, fall back to inline smm if not:
       ```python
       if _apply_correction is not None:
           corrected_pvals = _apply_correction(pvals, correction_method)
       elif smm is not None:
           if correction_method == "bonferroni":
               corrected_pvals = smm.multipletests(pvals, method="bonferroni")[1]
           else:
               corrected_pvals = smm.multipletests(pvals, method="fdr_bh")[1]
       else:
           logger.warning("statsmodels not available. Skipping multiple testing correction.")
           corrected_pvals = pvals
       ```
       This ensures ZERO behavior change — if association package somehow fails to import, the original code path still works.

    IMPORTANT: Do NOT remove the existing `smm` import in gene_burden.py. Keep it as fallback. The correction.py re-export is additive, not replacing.
  </action>
  <verify>
    Run existing tests: `pytest tests/ -m unit -x -q --tb=short 2>&1 | tail -20` — all should pass (gene_burden.py behavior unchanged).
    `python -c "from variantcentrifuge.stages.stage_registry import initialize_registry, get_registry; initialize_registry(); r = get_registry(); print(r.stage_exists('association_analysis'))"` prints `True`.
    `python -c "from variantcentrifuge.pipeline import build_stage_list; print('pipeline import OK')"` — no import errors.
  </verify>
  <done>
    - AssociationAnalysisStage is registered in stage_registry with aliases ["association_analysis", "association"]
    - pipeline.py conditionally includes AssociationAnalysisStage when perform_association is set
    - gene_burden.py imports apply_correction from association.correction (with fallback to inline smm)
    - All existing unit tests pass — zero behavior change to gene_burden.py
  </done>
</task>

</tasks>

<verification>
1. All existing tests pass: `pytest tests/ -m unit -x -q`
2. AssociationAnalysisStage is discoverable in stage registry
3. PipelineContext.association_results field exists and is handled in merge_from
4. gene_burden.py still produces identical output (correction rewiring is transparent)
5. GeneBurdenAnalysisStage is completely unmodified (git diff shows zero changes to existing GeneBurdenAnalysisStage code)
6. `make lint` and `make format` pass
</verification>

<success_criteria>
- AssociationAnalysisStage is fully wired into the pipeline (registry, pipeline.py, context)
- gene_burden.py correction uses association/correction.py with safe fallback
- Zero behavioral change to existing --perform-gene-burden path
- GeneBurdenAnalysisStage is unmodified and runs independently of --perform-association
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-02-SUMMARY.md`
</output>
