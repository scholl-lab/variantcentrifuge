---
phase: 18-foundation-core-abstractions-and-fisher-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - variantcentrifuge/association/__init__.py
  - variantcentrifuge/association/base.py
  - variantcentrifuge/association/engine.py
  - variantcentrifuge/association/correction.py
  - variantcentrifuge/association/tests/__init__.py
  - variantcentrifuge/association/tests/fisher.py
autonomous: true

must_haves:
  truths:
    - "association/ package is importable with `from variantcentrifuge.association import AssociationEngine, AssociationTest, TestResult, AssociationConfig`"
    - "FisherExactTest produces identical p-values and odds ratios to gene_burden.py for the same contingency data"
    - "Requesting an unknown test name raises ValueError with list of available tests"
    - "Genes with zero qualifying variants return TestResult with p_value=None"
    - "correction.py applies FDR and Bonferroni identically to current gene_burden.py inline calls"
  artifacts:
    - path: "variantcentrifuge/association/__init__.py"
      provides: "Package exports"
      contains: "AssociationEngine"
    - path: "variantcentrifuge/association/base.py"
      provides: "AssociationTest ABC, TestResult dataclass, AssociationConfig dataclass"
      exports: ["AssociationTest", "TestResult", "AssociationConfig"]
    - path: "variantcentrifuge/association/engine.py"
      provides: "AssociationEngine orchestrator"
      exports: ["AssociationEngine"]
    - path: "variantcentrifuge/association/correction.py"
      provides: "Multiple testing correction (FDR + Bonferroni)"
      exports: ["apply_correction"]
    - path: "variantcentrifuge/association/tests/fisher.py"
      provides: "FisherExactTest implementation"
      exports: ["FisherExactTest"]
  key_links:
    - from: "variantcentrifuge/association/engine.py"
      to: "variantcentrifuge/association/tests/fisher.py"
      via: "test registry dict"
      pattern: '"fisher".*FisherExactTest'
    - from: "variantcentrifuge/association/tests/fisher.py"
      to: "scipy.stats.fisher_exact"
      via: "import"
      pattern: "from scipy.stats import fisher_exact"
    - from: "variantcentrifuge/association/correction.py"
      to: "statsmodels.stats.multitest"
      via: "import"
      pattern: "multipletests"
---

<objective>
Create the `association/` package skeleton with all core abstractions: AssociationTest ABC, TestResult dataclass, AssociationConfig, AssociationEngine orchestrator, correction.py (FDR + Bonferroni), and FisherExactTest — a clean reimplementation of the Fisher's exact test from gene_burden.py.

Purpose: This package is the foundation for all 6 phases of v0.15.0. Every subsequent association test (burden, SKAT, SKAT-O, ACAT-O) will implement the AssociationTest ABC. Getting the abstractions right here determines whether the rest of the milestone composes cleanly.

Output: Importable `variantcentrifuge/association/` package with working FisherExactTest that produces bit-identical results to gene_burden.py's Fisher implementation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-CONTEXT.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-RESEARCH.md
@variantcentrifuge/gene_burden.py
@variantcentrifuge/pipeline_core/stage.py
@variantcentrifuge/pipeline_core/context.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create association/ package with base abstractions and correction module</name>
  <files>
    variantcentrifuge/association/__init__.py
    variantcentrifuge/association/base.py
    variantcentrifuge/association/correction.py
    variantcentrifuge/association/tests/__init__.py
  </files>
  <action>
    Create the `variantcentrifuge/association/` package directory and `tests/` subdirectory.

    **base.py** — Define three things:

    1. `TestResult` dataclass with fields: `gene: str`, `test_name: str`, `p_value: float | None` (None = skipped/zero-variant), `corrected_p_value: float | None`, `effect_size: float | None` (OR for Fisher; beta for regression tests in future), `ci_lower: float | None`, `ci_upper: float | None`, `n_cases: int`, `n_controls: int`, `n_variants: int`, `extra: dict = field(default_factory=dict)` for test-specific fields.

    2. `AssociationConfig` dataclass with fields: `correction_method: str = "fdr"` (choices: "fdr", "bonferroni"), `gene_burden_mode: str = "samples"` (choices: "samples", "alleles"), `confidence_interval_method: str = "normal_approx"`, `confidence_interval_alpha: float = 0.05`, `continuity_correction: float = 0.5`. This mirrors the config keys currently read from `cfg` dict in gene_burden.py (lines 373-377).

    3. `AssociationTest` ABC with:
       - `@property @abstractmethod def name(self) -> str` — short identifier like "fisher"
       - `@abstractmethod def run(self, gene: str, contingency_data: dict, config: AssociationConfig) -> TestResult` — run test on one gene
       - `def check_dependencies(self) -> None` — default no-op; subclasses override to raise ImportError if scipy/etc missing

    **correction.py** — Extract multiple testing correction into a standalone module:
    - `def apply_correction(pvals: list[float] | np.ndarray, method: str = "fdr") -> np.ndarray`
    - Lazy import of `statsmodels.stats.multitest as smm` at module top with try/except (same pattern as gene_burden.py lines 38-43)
    - If `method == "bonferroni"`: `smm.multipletests(pvals, method="bonferroni")[1]`
    - Else: `smm.multipletests(pvals, method="fdr_bh")[1]`
    - If smm is None: log warning, return pvals unchanged (same graceful degradation as gene_burden.py line 503-505)
    - Keep this module leaf-level: only imports stdlib + numpy + statsmodels. NO imports from gene_burden.py or other variantcentrifuge modules.

    **`__init__.py`** — Export: `AssociationTest`, `TestResult`, `AssociationConfig`, `AssociationEngine` (from engine.py), `apply_correction` (from correction.py).
    **`tests/__init__.py`** — Export: `FisherExactTest` (from fisher.py). Use lazy import pattern so fisher.py is only loaded when accessed.
  </action>
  <verify>
    Run: `python -c "from variantcentrifuge.association import AssociationTest, TestResult, AssociationConfig, AssociationEngine; from variantcentrifuge.association.correction import apply_correction; print('OK')"`
    Run: `python -c "from variantcentrifuge.association.tests import FisherExactTest; print(FisherExactTest().name)"`
    Both should succeed without error. Second prints "fisher".
  </verify>
  <done>
    - AssociationTest ABC is importable and has abstract `name` property and `run` method
    - TestResult dataclass has all 10 fields (gene, test_name, p_value, corrected_p_value, effect_size, ci_lower, ci_upper, n_cases, n_controls, n_variants) plus extra dict
    - AssociationConfig has all 5 config fields with defaults matching gene_burden.py
    - correction.py's apply_correction produces identical output to inline smm.multipletests calls in gene_burden.py
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FisherExactTest and AssociationEngine</name>
  <files>
    variantcentrifuge/association/tests/fisher.py
    variantcentrifuge/association/engine.py
  </files>
  <action>
    **fisher.py** — Clean reimplementation of Fisher's exact test (NOT delegation to gene_burden.py):

    1. Lazy imports at module top (same pattern as gene_burden.py lines 31-43):
       ```python
       try:
           from scipy.stats import fisher_exact
       except ImportError:
           fisher_exact = None
       try:
           from statsmodels.stats.contingency_tables import Table2x2
       except ImportError:
           Table2x2 = None
       ```

    2. `class FisherExactTest(AssociationTest)`:
       - `name` property returns `"fisher"`
       - `check_dependencies()`: raises `ImportError("FisherExactTest requires scipy and statsmodels...")` if `fisher_exact is None or Table2x2 is None`
       - `run(self, gene, contingency_data, config) -> TestResult`:
         a. Check `contingency_data["n_qualifying_variants"] == 0` -> return TestResult with p_value=None (skip silently)
         b. Build 2x2 table from contingency_data using EXACT same logic as gene_burden.py lines 428-465. The contingency_data dict has keys: `proband_count`, `control_count`, `proband_carrier_count`, `control_carrier_count`, `proband_allele_count`, `control_allele_count`, `n_qualifying_variants`. Use `config.gene_burden_mode` to select "samples" vs "alleles" table construction.
         c. Handle negative reference counts (p_ref < 0 or c_ref < 0) -> return TestResult with p_value=None, log error
         d. `odds_ratio, pval = fisher_exact(table)` — EXACT same tuple unpacking order as gene_burden.py line 468
         e. CI computation: port `_compute_or_confidence_interval` logic inline or as private method. Use exact same Table2x2 + oddsratio_confint call chain with score -> normal -> logit fallback (gene_burden.py lines 97-111). Same continuity correction (0.5 added to zero cells).
         f. Return TestResult with all fields populated. Store table in extra dict for debugging: `extra={"table": table}`

    3. CRITICAL for bit-identity: the `run()` method must handle "samples" mode using carrier counts AND "alleles" mode using allele counts, constructing the contingency table identically to gene_burden.py lines 428-465. The p_count==0 and c_count==0 skip at line 425 should also be replicated.

    **engine.py** — AssociationEngine orchestrator:

    1. `class AssociationEngine`:
       - `__init__(self, tests: list[AssociationTest], config: AssociationConfig)`
       - `_tests` stored as `{t.name: t for t in tests}`
       - `@classmethod from_names(cls, test_names: list[str], config: AssociationConfig) -> AssociationEngine`:
         - Registry dict: `{"fisher": FisherExactTest}` (grows with phases)
         - For each name not in registry: raise `ValueError(f"Test '{name}' is not available. Available tests: {', '.join(sorted(available))}")`
         - Instantiate and return engine
       - `def run_all(self, gene_burden_data: list[dict]) -> pd.DataFrame`:
         a. Sort gene_burden_data by "GENE" key (critical for bit-identical correction — gene_burden.py line 411)
         b. For each gene, for each test: call `test.run(gene, data_dict, self._config)` -> collect TestResults
         c. Build wide-format DataFrame: one row per gene. Column naming: `{test_name}_p_value`, `{test_name}_corrected_p_value`, `{test_name}_or` (effect_size), `{test_name}_or_ci_lower`, `{test_name}_or_ci_upper`, plus shared columns: `gene`, `n_cases`, `n_controls`, `n_variants`
         d. Apply correction per test: collect all p-values for each test name, call `apply_correction(pvals, config.correction_method)`, fill `{test_name}_corrected_p_value` column
         e. Return DataFrame. Skip genes where all tests returned p_value=None.

    2. The wide-format output is the new Association sheet schema. For Phase 18 with only Fisher, columns will be: `gene`, `n_cases`, `n_controls`, `n_variants`, `fisher_p_value`, `fisher_corrected_p_value`, `fisher_or`, `fisher_or_ci_lower`, `fisher_or_ci_upper`.
  </action>
  <verify>
    Write a quick smoke test inline:
    ```python
    python -c "
    from variantcentrifuge.association.engine import AssociationEngine
    from variantcentrifuge.association.base import AssociationConfig
    config = AssociationConfig(gene_burden_mode='samples')
    engine = AssociationEngine.from_names(['fisher'], config)
    data = [{'GENE': 'BRCA1', 'proband_count': 100, 'control_count': 200, 'proband_carrier_count': 15, 'control_carrier_count': 10, 'proband_allele_count': 15, 'control_allele_count': 10, 'n_qualifying_variants': 5}]
    result = engine.run_all(data)
    print(result.columns.tolist())
    print(result.iloc[0])
    assert 'fisher_p_value' in result.columns
    assert result['fisher_p_value'].iloc[0] < 1.0
    print('OK')
    "
    ```
    Also verify unknown test raises: `python -c "from variantcentrifuge.association.engine import AssociationEngine; from variantcentrifuge.association.base import AssociationConfig; AssociationEngine.from_names(['skat'], AssociationConfig())"` should raise ValueError.
  </verify>
  <done>
    - FisherExactTest.run() produces p-values and ORs using identical scipy.stats.fisher_exact calls to gene_burden.py
    - AssociationEngine.from_names(["fisher"], config) works; from_names(["skat"], config) raises ValueError with available test list
    - engine.run_all() returns wide-format DataFrame with correct column schema
    - Gene sort before correction ensures identical correction order to gene_burden.py
    - Zero-variant genes are skipped silently (p_value=None, not included in output)
  </done>
</task>

</tasks>

<verification>
1. `python -c "from variantcentrifuge.association import AssociationEngine, AssociationTest, TestResult, AssociationConfig; print('imports OK')"` succeeds
2. `python -c "from variantcentrifuge.association.correction import apply_correction; import numpy as np; result = apply_correction([0.01, 0.05, 0.1], 'fdr'); print(result); assert len(result) == 3; print('correction OK')"` succeeds
3. FisherExactTest smoke test (from Task 2 verify) produces valid p-value and OR
4. Unknown test name raises ValueError
5. `make lint` passes on new files
6. `make typecheck` runs without new errors in association/ (may have pre-existing warnings elsewhere)
</verification>

<success_criteria>
- The `association/` package is fully importable
- FisherExactTest implements the full Fisher pipeline (table construction, fisher_exact, CI computation) matching gene_burden.py logic
- AssociationEngine orchestrates per-gene test dispatch with correct gene sort order
- correction.py provides apply_correction with FDR and Bonferroni
- No imports from gene_burden.py in any association/ module (except correction.py is self-contained)
- All new code passes ruff lint and format checks
</success_criteria>

<output>
After completion, create `.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-01-SUMMARY.md`
</output>
