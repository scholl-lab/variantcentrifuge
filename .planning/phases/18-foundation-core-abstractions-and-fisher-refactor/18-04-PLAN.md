---
phase: 18-foundation-core-abstractions-and-fisher-refactor
plan: 04
type: execute
wave: 4
depends_on: ["18-03"]
files_modified:
  - tests/unit/test_association_base.py
  - tests/unit/test_association_engine.py
  - tests/unit/test_association_fisher.py
  - tests/unit/test_association_correction.py
  - tests/unit/test_association_stage.py
autonomous: true

must_haves:
  truths:
    - "FisherExactTest produces bit-identical p-values and ORs to gene_burden.py for the same input data"
    - "AssociationEngine sorts genes before correction (matching gene_burden.py sort order)"
    - "Zero-variant genes are skipped with p_value=None"
    - "correction.py apply_correction matches inline smm.multipletests output exactly"
    - "AssociationAnalysisStage skips when perform_association is not in config"
    - "GeneBurdenAnalysisStage and AssociationAnalysisStage coexist: both --perform-gene-burden and --perform-association can be set simultaneously, each stage runs independently"
    - "Existing gene burden tests still pass (backward compatibility)"
  artifacts:
    - path: "tests/unit/test_association_base.py"
      provides: "Tests for TestResult, AssociationConfig, AssociationTest ABC"
      min_lines: 30
    - path: "tests/unit/test_association_engine.py"
      provides: "Tests for AssociationEngine orchestration"
      min_lines: 50
    - path: "tests/unit/test_association_fisher.py"
      provides: "Fisher bit-identity tests and edge cases"
      min_lines: 80
    - path: "tests/unit/test_association_correction.py"
      provides: "Correction module tests"
      min_lines: 30
    - path: "tests/unit/test_association_stage.py"
      provides: "AssociationAnalysisStage unit tests including coexistence tests"
      min_lines: 50
  key_links:
    - from: "tests/unit/test_association_fisher.py"
      to: "variantcentrifuge/gene_burden.py"
      via: "cross-validation"
      pattern: "perform_gene_burden_analysis"
    - from: "tests/unit/test_association_fisher.py"
      to: "variantcentrifuge/association/tests/fisher.py"
      via: "direct test"
      pattern: "FisherExactTest"
    - from: "tests/unit/test_association_stage.py"
      to: "variantcentrifuge/stages/analysis_stages.py"
      via: "coexistence test"
      pattern: "GeneBurdenAnalysisStage.*AssociationAnalysisStage"
---

<objective>
Write comprehensive unit tests validating bit-identical Fisher output between the new association framework and the existing gene_burden.py, plus edge case coverage for all association/ modules.

Purpose: These tests are the permanent regression guard for all subsequent v0.15.0 phases. Every future phase adds tests to this suite. The bit-identity tests specifically ensure the Fisher refactor introduces zero numerical drift.

Output: Test suite in tests/unit/ covering base abstractions, engine, Fisher parity, correction, stage integration, and stage coexistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-CONTEXT.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-RESEARCH.md
@.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-03-SUMMARY.md
@variantcentrifuge/gene_burden.py
@variantcentrifuge/association/base.py
@variantcentrifuge/association/engine.py
@variantcentrifuge/association/tests/fisher.py
@variantcentrifuge/association/correction.py
@variantcentrifuge/stages/analysis_stages.py
@tests/unit/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test base abstractions, correction module, and engine</name>
  <files>
    tests/unit/test_association_base.py
    tests/unit/test_association_correction.py
    tests/unit/test_association_engine.py
  </files>
  <action>
    **test_association_base.py** — Tests for base.py:
    - TestResult dataclass creation with all fields
    - TestResult with p_value=None (skipped gene)
    - TestResult extra dict usage
    - AssociationConfig defaults match gene_burden.py expectations (correction_method="fdr", gene_burden_mode="samples", etc.)
    - AssociationTest ABC cannot be instantiated directly
    - AssociationTest subclass must implement name and run

    **test_association_correction.py** — Tests for correction.py:
    - apply_correction with method="fdr" matches `smm.multipletests(pvals, method="fdr_bh")[1]` exactly (compare numpy arrays element-wise)
    - apply_correction with method="bonferroni" matches `smm.multipletests(pvals, method="bonferroni")[1]` exactly
    - apply_correction with empty list returns empty
    - apply_correction with single p-value
    - apply_correction with all p-values = 1.0
    - apply_correction with very small p-values (1e-10)

    For the parity tests, compute expected values using direct smm.multipletests calls and compare with apply_correction output using `np.testing.assert_array_almost_equal`.

    **test_association_engine.py** — Tests for engine.py:
    - from_names(["fisher"], config) succeeds
    - from_names(["skat"], config) raises ValueError with "Available tests: fisher" in message
    - from_names([], config) creates engine with no tests
    - run_all with single gene returns DataFrame with expected columns (gene, n_cases, n_controls, n_variants, fisher_p_value, fisher_corrected_p_value, fisher_or, fisher_or_ci_lower, fisher_or_ci_upper)
    - run_all with multiple genes returns sorted DataFrame
    - run_all with zero-variant gene skips that gene
    - run_all gene sort order: input genes in reverse alphabetical -> output still alphabetical (confirms sort before correction)

    Mark all tests with `@pytest.mark.unit`.
  </action>
  <verify>
    `pytest tests/unit/test_association_base.py tests/unit/test_association_correction.py tests/unit/test_association_engine.py -v --tb=short` — all pass.
  </verify>
  <done>
    - Base abstractions tested (TestResult, AssociationConfig, ABC enforcement)
    - Correction module tested with exact parity to inline smm calls
    - Engine tested for registration, error handling, sort order, and output schema
  </done>
</task>

<task type="auto">
  <name>Task 2: Fisher bit-identity tests, stage unit tests, and coexistence tests</name>
  <files>
    tests/unit/test_association_fisher.py
    tests/unit/test_association_stage.py
  </files>
  <action>
    **test_association_fisher.py** — The critical parity test suite:

    1. **Bit-identity test (samples mode)**: Create a synthetic gene_burden_data list with 5-10 genes having varying carrier counts. Run BOTH:
       a. `perform_gene_burden_analysis(df, cfg, case_samples, control_samples, vcf_samples)` from gene_burden.py
       b. `AssociationEngine.from_names(["fisher"], config).run_all(gene_burden_data)` from association engine

       For approach (a), you need to construct a DataFrame with GENE column and per-sample GT columns matching the gene_burden_data. The simplest approach: call the aggregation functions directly to get gene_burden_data, then pass that same data to both paths.

       Compare: raw p-values must be EXACTLY equal (not approximately — use `==` or `np.testing.assert_array_equal`). Corrected p-values must be EXACTLY equal. Odds ratios must be EXACTLY equal. CI bounds must be EXACTLY equal.

       ALTERNATIVE simpler approach: Instead of running the full `perform_gene_burden_analysis`, compute expected values manually using `scipy.stats.fisher_exact` on the same contingency tables, then verify FisherExactTest.run() returns those exact values. Then separately verify correction parity in test_association_correction.py.

    2. **Bit-identity test (alleles mode)**: Same test but with `gene_burden_mode="alleles"`. Verify allele-based table construction matches gene_burden.py alleles mode.

    3. **Edge cases**:
       - Gene with all carriers in cases, none in controls (extreme OR)
       - Gene with zero carriers in both groups (p_count==0, c_count==0 -> skip)
       - Gene with zero qualifying variants -> TestResult.p_value is None
       - Gene with one variant, one carrier -> valid but sparse table
       - Negative reference count scenario (p_var > p_count) -> p_value=None, error logged
       - CI fallback chain: gene where score method fails -> normal -> logit (create a table with zero cell to trigger continuity correction path)

    4. **Fisher dependency check**: FisherExactTest.check_dependencies() does not raise (scipy and statsmodels are installed in test env)

    **test_association_stage.py** — Unit tests for AssociationAnalysisStage:

    1. Stage skips when perform_association is not in config (returns context unchanged)
    2. Stage skips when perform_association is False
    3. Stage name is "association_analysis"
    4. Stage dependencies are {"dataframe_loading", "sample_config_loading"}
    5. Stage soft_dependencies include "custom_annotation"
    6. Mock a minimal PipelineContext with perform_association=True, a small DataFrame, case/control samples -> verify context.association_results is set to a DataFrame after _process
    7. Verify association_output path is set in context.config

    **Coexistence tests (CORE-05)** — Add these to test_association_stage.py:

    8. **test_both_stages_coexist**: Create a mock PipelineContext with BOTH `perform_gene_burden=True` and `perform_association=True`. Instantiate both GeneBurdenAnalysisStage and AssociationAnalysisStage. Verify:
       - Both stages have independent config guards (gene_burden checks `perform_gene_burden`, association checks `perform_association`)
       - Neither stage modifies the other's config keys
       - Both stages can be included in the same stage list (no name conflicts, no dependency conflicts)

    9. **test_gene_burden_unaffected_by_association_flag**: Create context with `perform_gene_burden=True` and `perform_association=True`. Verify GeneBurdenAnalysisStage's `_process` method does NOT check or depend on `perform_association` in any way (it only checks `perform_gene_burden`). This confirms CORE-05: GeneBurdenAnalysisStage is completely unmodified.

    10. **test_association_only_no_gene_burden**: Create context with `perform_gene_burden=False` and `perform_association=True`. Verify AssociationAnalysisStage proceeds normally and GeneBurdenAnalysisStage would skip (check its config guard).

    For mocking PipelineContext, use the existing test patterns from the codebase (check tests/unit/ for how other stages are tested — likely using unittest.mock or direct PipelineContext construction).

    Mark all tests with `@pytest.mark.unit`.
  </action>
  <verify>
    `pytest tests/unit/test_association_fisher.py tests/unit/test_association_stage.py -v --tb=short` — all pass.
    `pytest tests/ -m unit -x -q --tb=short 2>&1 | tail -5` — ALL unit tests pass (no regressions).
    `make lint` passes on all test files.
  </verify>
  <done>
    - Fisher bit-identity tests confirm EXACT numerical parity with gene_burden.py for both samples and alleles modes
    - Edge cases covered: zero variants, sparse tables, negative ref counts, CI fallback
    - AssociationAnalysisStage tested for skip behavior, output storage, and config flow
    - Coexistence tested: both stages run independently, neither interferes with the other (CORE-05)
    - All existing unit tests still pass (zero regressions)
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/unit/test_association_*.py -v` — all new tests pass
2. `pytest tests/ -m unit -x -q` — all existing + new unit tests pass
3. `make lint` passes on all test files
4. `make ci-check` passes (full CI validation)
5. Coexistence tests prove CORE-05: GeneBurdenAnalysisStage and AssociationAnalysisStage are fully independent
</verification>

<success_criteria>
- Bit-identity between FisherExactTest and gene_burden.py Fisher is proven by tests (exact equality, not approximate)
- All edge cases (zero variants, sparse tables, negative refs) are covered
- AssociationAnalysisStage skip/run behavior is tested
- correction.py parity with inline smm calls is proven
- Stage coexistence (CORE-05) is verified by dedicated tests
- Zero regressions in existing test suite
- make ci-check passes
</success_criteria>

<output>
After completion, create `.planning/phases/18-foundation-core-abstractions-and-fisher-refactor/18-04-SUMMARY.md`
</output>
