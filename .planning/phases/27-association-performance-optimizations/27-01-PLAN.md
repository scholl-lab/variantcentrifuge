---
phase: 27-association-performance-optimizations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - variantcentrifuge/association/backends/python_backend.py
  - variantcentrifuge/association/tests/fisher.py
  - variantcentrifuge/association/tests/logistic_burden.py
  - variantcentrifuge/association/tests/linear_burden.py
  - variantcentrifuge/association/tests/skat_python.py
  - tests/unit/test_gl_quadrature.py
autonomous: true

must_haves:
  truths:
    - "SKAT-O integration uses 128-node Gauss-Legendre quadrature instead of adaptive quad"
    - "SKAT-O p-values remain within tolerance of previous adaptive quad results"
    - "All Python-backend test classes declare parallel_safe=True"
    - "R-backend test classes retain parallel_safe=False"
  artifacts:
    - path: "variantcentrifuge/association/backends/python_backend.py"
      provides: "GL quadrature constants and _skato_integrate_davies using GL"
      contains: "_GL_NODES"
    - path: "variantcentrifuge/association/tests/fisher.py"
      provides: "FisherExactTest with parallel_safe=True"
      contains: "parallel_safe"
    - path: "variantcentrifuge/association/tests/skat_python.py"
      provides: "PurePythonSKATTest with parallel_safe=True"
      contains: "parallel_safe"
    - path: "tests/unit/test_gl_quadrature.py"
      provides: "GL quadrature accuracy tests"
      contains: "test_gl_vs_adaptive"
  key_links:
    - from: "variantcentrifuge/association/backends/python_backend.py"
      to: "numpy.polynomial.legendre.leggauss"
      via: "module-level GL constant computation"
      pattern: "leggauss\\(128\\)"
---

<objective>
Replace the adaptive scipy.integrate.quad in SKAT-O omnibus integration with fixed 128-node
Gauss-Legendre quadrature (measured 46x speedup: 379ms to 8ms per gene), and add parallel_safe
class attributes to all Python-backend test classes to prepare for ProcessPoolExecutor dispatch.

Purpose: The GL quadrature is the single highest-impact optimization in Phase 27 (46x on
the SKAT-O integration bottleneck). The parallel_safe attributes are a prerequisite for
Plan 03's ProcessPoolExecutor logic.

Output: Modified python_backend.py with GL quadrature, 4 test class files with parallel_safe=True,
and a unit test validating GL accuracy against the previous adaptive quad approach.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-association-performance-optimizations/27-RESEARCH.md

@variantcentrifuge/association/backends/python_backend.py
@variantcentrifuge/association/tests/fisher.py
@variantcentrifuge/association/tests/logistic_burden.py
@variantcentrifuge/association/tests/linear_burden.py
@variantcentrifuge/association/tests/skat_python.py
@variantcentrifuge/association/tests/allelic_series.py
@variantcentrifuge/association/tests/allelic_series_python.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: GL quadrature in SKAT-O integration</name>
  <files>variantcentrifuge/association/backends/python_backend.py</files>
  <action>
  Replace the adaptive `scipy.integrate.quad` call in `_skato_integrate_davies` with fixed
  128-node Gauss-Legendre quadrature. Specifically:

  1. Add module-level GL constants after the existing `_SKATO_RHO_GRID` constant (around line 73):
     ```python
     from numpy.polynomial.legendre import leggauss
     _GL_NODES_RAW, _GL_WEIGHTS_RAW = leggauss(128)
     _GL_A, _GL_B = 0.0, 40.0  # integration bounds (matches R: upper=40)
     _GL_X = (_GL_B - _GL_A) / 2.0 * _GL_NODES_RAW + (_GL_B + _GL_A) / 2.0
     _GL_W = (_GL_B - _GL_A) / 2.0 * _GL_WEIGHTS_RAW
     ```

  2. Rewrite `_skato_integrate_davies` to use GL quadrature instead of `scipy.integrate.quad`:
     - Replace the `integrand` closure + `quad()` call with a loop over `_GL_X` / `_GL_W`
     - Evaluate the same integrand logic at each GL node
     - Compute integral as `np.dot(integrand_vals, _GL_W)`
     - Keep the same Liu fallback behavior: if any Davies call inside the loop fails
       (p_dav is None or ifault != 0), fall back to `_skato_integrate_liu`
     - Keep the same NaN check and Bonferroni guard after integration
     - Keep the same `pvalue = 1.0 - integral` and `np.clip(pvalue, 0.0, 1.0)` at the end

  3. The `_skato_integrate_liu` function is UNCHANGED (it is already the fallback).

  4. Remove `import scipy.integrate` from the top of the file IF it is no longer used
     anywhere. Check first -- `_skato_integrate_liu` uses `scipy.integrate.quad` so the
     import MUST stay.

  Do NOT change `_skato_integrate_liu` -- it still uses adaptive quad as the Liu fallback
  and that is fine (Liu is rarely called).

  Do NOT implement the single-eigendecomposition optimization (research showed it is SLOWER
  for typical gene sizes p < 100).
  </action>
  <verify>
  Run existing SKAT-O tests: `pytest tests/unit/test_skat_python_backend.py -v -x`
  All existing tests must pass. The GL quadrature should produce results within tolerance
  of previous adaptive quad results (existing test tolerances already account for this).
  </verify>
  <done>
  `_skato_integrate_davies` uses 128-node GL quadrature. Module-level `_GL_X` and `_GL_W`
  constants exist. All existing SKAT-O unit tests pass. `scipy.integrate` import remains
  for `_skato_integrate_liu`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add parallel_safe attributes and GL accuracy test</name>
  <files>
    variantcentrifuge/association/tests/fisher.py
    variantcentrifuge/association/tests/logistic_burden.py
    variantcentrifuge/association/tests/linear_burden.py
    variantcentrifuge/association/tests/skat_python.py
    tests/unit/test_gl_quadrature.py
  </files>
  <action>
  Part A: Add `parallel_safe: bool = True` as a class-level attribute to each of these
  test classes. Place it as the first line inside the class body (after the docstring,
  before `__init__` or `@property`):

  - `FisherExactTest` in `fisher.py` -- add `parallel_safe: bool = True`
  - `LogisticBurdenTest` in `logistic_burden.py` -- add `parallel_safe: bool = True`
  - `LinearBurdenTest` in `linear_burden.py` -- add `parallel_safe: bool = True`
  - `PurePythonSKATTest` in `skat_python.py` -- add `parallel_safe: bool = True`

  Verify that COASTTest (allelic_series.py) already has `parallel_safe: bool = False` (line 277)
  and PurePythonCOASTTest (allelic_series_python.py) already has `parallel_safe: bool = True`
  (line 96). Do NOT modify those files.

  Part B: Create `tests/unit/test_gl_quadrature.py` with tests verifying GL accuracy:

  1. Test `test_gl_quadrature_accuracy`: Create a synthetic SKAT-O scenario (n=200, p=20)
     using the existing `PythonSKATBackend` infrastructure. Run `_skato_integrate_davies`
     (which now uses GL) and verify the result is a valid p-value (0 < p <= 1). This is a
     smoke test ensuring the GL integration produces sensible results.

  2. Test `test_gl_constants_shape`: Verify `_GL_X` has 128 elements, all in [0, 40],
     and `_GL_W` has 128 elements.

  3. Test `test_parallel_safe_attributes`: Import all 6 test classes and assert:
     - FisherExactTest.parallel_safe is True
     - LogisticBurdenTest.parallel_safe is True
     - LinearBurdenTest.parallel_safe is True
     - PurePythonSKATTest.parallel_safe is True
     - PurePythonCOASTTest.parallel_safe is True
     - COASTTest.parallel_safe is False

  Mark the GL accuracy test with `@pytest.mark.unit`. Use the existing test patterns
  from `tests/unit/test_skat_python_backend.py` for synthetic data generation.
  </action>
  <verify>
  Run: `pytest tests/unit/test_gl_quadrature.py -v -x`
  All 3 tests pass. Then run the full unit test suite: `pytest -m unit --timeout=120 -x`
  to confirm no regressions.
  </verify>
  <done>
  All 4 Python-backend test classes have `parallel_safe: bool = True`. R-backend classes
  retain `parallel_safe: bool = False`. New test file validates GL constants, GL accuracy,
  and parallel_safe attributes on all 6 test classes. Full unit suite passes.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/unit/test_skat_python_backend.py -v` -- all existing SKAT-O tests pass
2. `pytest tests/unit/test_gl_quadrature.py -v` -- new GL + parallel_safe tests pass
3. `pytest -m unit --timeout=120` -- full unit suite passes
4. `make lint` -- no linting errors
</verification>

<success_criteria>
1. SKAT-O integration in python_backend.py uses 128-node GL quadrature (no more adaptive quad in _skato_integrate_davies)
2. All 4 Python-backend test classes declare parallel_safe=True
3. All existing tests pass without regression
4. New test file validates GL accuracy and parallel_safe attributes
</success_criteria>

<output>
After completion, create `.planning/phases/27-association-performance-optimizations/27-01-SUMMARY.md`
</output>
