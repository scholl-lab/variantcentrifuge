---
phase: 16-column-level-filtering-and-visualization
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - variantcentrifuge/templates/index.html
autonomous: true

must_haves:
  truths:
    - "Filterable columns get appropriate controls: noUiSlider range sliders for numeric (AF, scores), dropdowns for categorical (IMPACT, ClinVar, Inheritance), text input for GENE"
    - "Filter toggle button shows/hides the filter row"
    - "Applying a filter updates the DataTables view and creates a removable chip in the filter strip"
    - "Removing a chip or clicking Reset All clears the corresponding filter(s) and redraws the table"
    - "The global 'Include missing values' toggle controls whether rows with missing/empty values pass all filters"
    - "All charts (Phase 14 impact + inheritance, AND Phase 16 variant type + chromosome + AF histogram) update reactively when filters change"
    - "The collapsible Visualizations section expands/collapses on click with localStorage persistence"
    - "Allele frequency histogram uses log-scale Y axis"
    - "Chromosome distribution chart sorts chromosomes in karyogram order (1-22, X, Y, M)"
    - "Text input for GENE is debounced at 300ms"
  artifacts:
    - path: "variantcentrifuge/templates/index.html"
      provides: "Complete filter + visualization JavaScript behavior"
      contains: "noUiSlider.create"
  key_links:
    - from: "filter controls"
      to: "DataTables ext.search"
      via: "Custom search functions with columnIndex identifier"
      pattern: "ext\\.search\\.push"
    - from: "DataTables draw.dt event"
      to: "Chart.js update('none')"
      via: "updateAllCharts function called on every draw"
      pattern: "draw\\.dt.*updateAllCharts"
    - from: "filter state (activeFilters Map)"
      to: "filter chip strip"
      via: "updateFilterChips() syncs Map to DOM"
      pattern: "activeFilters.*updateFilterChips"
    - from: "include-missing-toggle checkbox"
      to: "custom search functions"
      via: "includeMissing variable read by all filter predicates"
      pattern: "includeMissing"
---

<objective>
Wire up all JavaScript behavior for column-level filtering, filter chip management, reactive chart updates, and the collapsible visualization section.

Purpose: This is the core logic plan. It takes the HTML scaffolding from Plan 01 and makes everything interactive: filter controls initialize based on data, filters apply via DataTables custom search API, chips track active filters, charts react to filtered data, and the visualization section collapses/expands.

Output: Fully functional filtering and visualization system in the individual HTML report.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-column-level-filtering-and-visualization/16-CONTEXT.md
@.planning/phases/16-column-level-filtering-and-visualization/16-RESEARCH.md
@.planning/phases/16-column-level-filtering-and-visualization/16-01-SUMMARY.md
@variantcentrifuge/templates/index.html
@scripts/templates/cohort_report_template.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement filter initialization, controls, and DataTables custom search functions</name>
  <files>variantcentrifuge/templates/index.html</files>
  <action>
    Add JavaScript code INSIDE the existing `document.addEventListener('DOMContentLoaded', function() { ... })` block, AFTER the DataTables initialization and BEFORE the Chart.js initialization section. This code wires up column-level filtering.

    **Key architecture decisions (from CONTEXT.md and RESEARCH.md):**
    - Config-driven filter column selection via field name pattern matching (not hardcoded column names)
    - DataTables custom search functions (`$.fn.dataTable.ext.search.push()`) for filter logic
    - Each custom search function gets a `columnIndex` property for targeted removal
    - Filter state tracked in `activeFilters` Map (column name -> filter state object)
    - Missing values handled via global `includeMissing` flag from checkbox
    - Text input debounced at 300ms
    - Categorical dropdowns populated from actual data values
    - noUiSlider ranges computed from actual data min/max

    **Implementation details:**

    1. **Constants and state:**
       ```javascript
       var MISSING_VALUES = new Set(['', 'N/A', 'NA', '.', 'Unknown', 'null', 'undefined']);
       var activeFilters = new Map();
       var includeMissing = true; // From checkbox
       ```

    2. **isMissing utility:**
       ```javascript
       function isMissing(value) {
           if (value === null || value === undefined) return true;
           var str = String(value).trim();
           return MISSING_VALUES.has(str);
       }
       ```

    3. **Column type detection** -- Use pattern matching on column original_name (adapted from cohort report's `getColumnType()`):
       - Numeric: names matching `/_AF|_freq|_frequency|_score|_phred|CADD|REVEL|SpliceAI_D|GERP|phyloP|POS|QUAL|DP/i` (but NOT link columns)
       - Categorical: `IMPACT`, `ClinVar_CLNSIG` / `dbNSFP_clinvar_clnsig`, `Inheritance_Pattern`
       - Text: `GENE`
       - Skip: link columns, IGV links, control column, columns that don't match any pattern

    4. **Filter row population** -- After DataTable init, iterate `columnData` array. For each column matching a filter pattern:

       **Numeric columns (noUiSlider):**
       - Scan all data values in that column via `table.column(colIndex).data().toArray()`
       - Filter out missing values, parse to float, compute min/max
       - If min === max or fewer than 2 valid numeric values, skip (no range to filter)
       - Create a container div with label, slider div, and min/max value displays
       - Call `noUiSlider.create(sliderEl, { start: [min, max], connect: true, range: { min, max }, format: { to: val => parseFloat(val).toFixed(4), from: val => Number(val) } })`
       - On slider `update` event: remove previous custom search function for this columnIndex, create new one that checks numeric range + missing values, push to `$.fn.dataTable.ext.search`, update activeFilters Map, call `updateFilterChips()`, call `table.draw()`
       - When slider returns to full range (min,max = data min,max), REMOVE the filter and chip

       **Categorical columns (dropdown):**
       - Scan column data, collect unique non-missing values, sort alphabetically
       - Create a `<select>` with "All" as first option, then each unique value
       - On `change` event: if "All" selected, remove filter; otherwise add custom search function matching exact value (case-sensitive, trimmed)
       - Update activeFilters and chips, call `table.draw()`

       **Text columns (input):**
       - Create a text `<input>` with placeholder "Search [column name]..."
       - On `input` event (debounced 300ms): if empty, remove filter; otherwise add custom search function doing case-insensitive substring match
       - Update activeFilters and chips, call `table.draw()`

    5. **Filter toggle button:**
       ```javascript
       document.getElementById('filter-toggle-btn').addEventListener('click', function() {
           var filterRow = document.getElementById('filter-row');
           var isHidden = filterRow.style.display === 'none';
           filterRow.style.display = isHidden ? 'flex' : 'none';
       });
       ```
       Style the filter row as `display: flex; flex-wrap: wrap; gap: 12px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #dee2e6;` when visible.

    6. **Include missing values toggle:**
       ```javascript
       document.getElementById('include-missing-toggle').addEventListener('change', function() {
           includeMissing = this.checked;
           table.draw(); // Triggers all custom search functions to re-evaluate
       });
       ```

    7. **Filter chip management** -- `updateFilterChips()` function:
       - Get the `#active-filters-strip` element
       - If `activeFilters.size === 0`, hide strip, return
       - Show strip, set count text
       - Clear existing chips (but preserve reset button)
       - For each entry in activeFilters: create chip span with column name + formatted value, add remove button
       - Chip remove button: calls `removeFilter(colName)` which resets the control (slider to full range, dropdown to "All", input to empty), removes custom search function, deletes from activeFilters, calls `updateFilterChips()`, calls `table.draw()`

    8. **Reset All button:**
       ```javascript
       document.getElementById('btn-reset-all').addEventListener('click', function() {
           // Reset all filter controls to defaults
           activeFilters.forEach(function(state, colName) {
               removeFilter(colName);
           });
       });
       ```

    **Critical pitfalls to avoid (from RESEARCH.md):**
    - Always check `settings.nTable.id !== 'variants_table'` in custom search functions (return true if not our table)
    - Use `filterFn.columnIndex = colIndex` property for targeted removal
    - Check `slider && !slider.noUiSlider` before creating noUiSlider instances
    - Use `String(value).trim()` before comparing, NOT bare `!value` (would exclude 0)
    - Debounce text input at 300ms to avoid excessive redraws
    - Remove old filter function BEFORE pushing new one (prevent accumulation)
  </action>
  <verify>
    ```bash
    # Verify key patterns exist in template
    grep -c "noUiSlider.create\|ext.search.push\|activeFilters\|updateFilterChips\|isMissing\|includeMissing\|filter-toggle-btn.*click\|btn-reset-all.*click\|include-missing-toggle.*change" variantcentrifuge/templates/index.html
    # Should return 9+ matches

    # Verify debounce pattern for text input
    grep "setTimeout\|clearTimeout\|300" variantcentrifuge/templates/index.html
    ```
  </verify>
  <done>
    All filter controls initialize from data, apply via DataTables custom search API, track state in activeFilters Map, display as removable chips, respect missing values toggle, and can be reset individually or all at once.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement reactive chart updates and collapsible visualization section</name>
  <files>variantcentrifuge/templates/index.html</files>
  <action>
    Add JavaScript code for the three new charts (variant type breakdown, chromosome distribution, allele frequency histogram), reactive updates for ALL charts on filter change, and the collapsible section toggle.

    **1. Collapsible section toggle** (add after DataTables init, before charts):
    ```javascript
    // Visualization section collapse/expand
    var collapseToggle = document.querySelector('.collapse-toggle');
    if (collapseToggle) {
        collapseToggle.addEventListener('click', function() {
            var expanded = this.getAttribute('aria-expanded') === 'true';
            var content = document.getElementById('viz-content');
            this.setAttribute('aria-expanded', !expanded);
            content.hidden = expanded; // Toggle
            localStorage.setItem('vizSectionExpanded', !expanded);
        });
        // Restore saved preference
        if (localStorage.getItem('vizSectionExpanded') === 'true') {
            collapseToggle.click();
        }
    }
    ```

    **2. New Chart Initialization** (add after existing Phase 14 chart init):

    **Variant Type Breakdown (doughnut chart):**
    - Compute variant types from `variants` template data: classify by comparing REF and ALT lengths
      - SNV: len(REF) === 1 AND len(ALT) === 1
      - Insertion: len(REF) < len(ALT)
      - Deletion: len(REF) > len(ALT)
      - MNV: len(REF) === len(ALT) AND len(REF) > 1
    - Use semantic colors: SNV=#2196f3 (blue), Insertion=#4caf50 (green), Deletion=#dc3545 (red), MNV=#ff9800 (orange)
    - Chart.js doughnut chart on `#variant_type_chart` canvas
    - Include datalabels plugin

    **Chromosome Distribution (horizontal bar chart):**
    - Count variants per chromosome from data
    - Sort in karyogram order: chr1, chr2, ..., chr22, chrX, chrY, chrM (strip "chr" prefix for sorting, handle both "chr1" and "1" formats)
    - Karyogram sort function: numeric chromosomes first (1-22 numerically), then X, Y, M/MT
    - Use a single color (#607d8b blue-grey) for all bars
    - Horizontal bar chart on `#chromosome_chart` canvas
    - X-axis: "Number of Variants", Y-axis: chromosome labels

    **Allele Frequency Histogram (bar chart with log-scale Y):**
    - Extract AF values from data. Look for columns matching `/_AF|^AF$|^AF_/i` pattern. Use the first match found.
    - If no AF column found, show "No allele frequency data available" message in the canvas container
    - Create log-scale bins: `<0.0001`, `0.0001-0.001`, `0.001-0.01`, `0.01-0.1`, `>0.1`
    - Count variants falling into each bin
    - Bar chart on `#af_histogram_chart` with logarithmic Y-axis:
      ```javascript
      scales: {
          y: {
              type: 'logarithmic',
              beginAtZero: false,
              min: 1,
              title: { display: true, text: 'Count (log scale)' },
              ticks: {
                  callback: function(value) {
                      if (Number.isInteger(Math.log10(value))) return value;
                      return null;
                  }
              }
          },
          x: { title: { display: true, text: 'Allele Frequency' } }
      }
      ```
    - Use color gradient: lightest for rare (<0.0001) to darkest for common (>0.1) using blues

    **IMPORTANT:** To access REF, ALT, CHROM, AF data for chart initialization, the JS needs access to the raw variant data. Two approaches:
    - Option A: Use `table.rows().data().toArray()` after DataTable init (data is in array form indexed by column position). Use `allColumnOriginalNames` to find column indices for REF, ALT, CHROM, AF columns.
    - Option B: Inject `{{ variants | tojson }}` into a JS variable.

    Use Option A (DataTable API) since the data is already loaded and this avoids doubling the data payload. The column indices can be found via `allColumnOriginalNames.indexOf('REF')` + 1 (for control column offset).

    **3. Reactive Chart Updates on Filter Change:**

    Create an `updateAllCharts()` function that:
    - Gets filtered data: `table.rows({ search: 'applied' }).data().toArray()`
    - Recomputes counts for each chart from filtered data
    - Updates each Chart.js instance's `.data.labels` and `.data.datasets[0].data`
    - Calls `.update('none')` on each chart (no animation, per CONTEXT.md)
    - Also updates Phase 14 dashboard charts (impactChart, inheritanceChart)

    Wire `updateAllCharts` to the DataTables `draw.dt` event:
    ```javascript
    table.on('draw.dt', function() {
        updateAllCharts();
    });
    ```

    **IMPORTANT:** The existing Phase 14 impactChart and inheritanceChart are initialized with static data from `{{ summary.impact_distribution | tojson }}`. The `updateAllCharts` function must update these charts with filtered data computed from the DataTable rows, NOT from the static summary. This means recomputing impact counts and inheritance counts from the filtered row data.

    To recompute from filtered rows, find IMPACT and Inheritance_Pattern column indices via `allColumnOriginalNames.indexOf('IMPACT') + 1` and `allColumnOriginalNames.indexOf('Inheritance_Pattern') + 1`.

    **4. Move existing chart variables to broader scope:**
    The existing `impactChart` and `inheritanceChart` variables (currently `var` inside the DOMContentLoaded handler) need to be accessible from `updateAllCharts()`. They already are since they're in the same function scope. New chart variables (`variantTypeChart`, `chromosomeChart`, `afHistogramChart`) should also be declared at the same scope level.

    **Chart update for empty filtered results:**
    If all rows are filtered out, charts should show empty state (zero counts) rather than error. Check `filteredData.length === 0` and handle gracefully.
  </action>
  <verify>
    ```bash
    # Verify new chart initializations
    grep -c "variant_type_chart\|chromosome_chart\|af_histogram_chart\|logarithmic\|updateAllCharts\|draw.dt\|vizSectionExpanded\|karyogram\|collapse-toggle.*click" variantcentrifuge/templates/index.html
    # Should return 9+ matches

    # Verify reactive update wiring
    grep "draw.dt" variantcentrifuge/templates/index.html
    grep "update('none')" variantcentrifuge/templates/index.html

    # Run linting
    make lint
    ```
  </verify>
  <done>
    Three new charts (variant type doughnut, chromosome horizontal bar, AF histogram with log-scale) initialize from data. All 5 charts (2 existing + 3 new) update reactively when any filter changes via draw.dt event. Collapsible section toggles with localStorage persistence. Chromosome chart sorted in karyogram order.
  </done>
</task>

</tasks>

<verification>
1. Template contains complete filter system: noUiSlider range sliders, categorical dropdowns, text search with debounce
2. Filter chips appear and disappear correctly as filters are applied/removed
3. "Reset All Filters" clears all active filters
4. "Include missing values" toggle affects all filter functions
5. All 5 charts update when filters change (no animation)
6. Visualization section collapses/expands with localStorage persistence
7. AF histogram uses logarithmic Y-axis
8. Chromosome chart uses karyogram sort order
9. `make lint` passes
10. `pytest tests/unit/test_html_report.py tests/unit/test_html_report_assets.py -x` passes
</verification>

<success_criteria>
- Column-level filters work for numeric (slider), categorical (dropdown), and text (input) columns
- Filter chips display active filters with remove capability
- Reset All clears everything
- Missing values toggle works globally
- All charts react to filtered data instantly (no animation)
- Collapsible visualization section works with preference persistence
- AF histogram has log-scale Y-axis
- Chromosomes sorted in biological order
- Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-column-level-filtering-and-visualization/16-02-SUMMARY.md`
</output>
