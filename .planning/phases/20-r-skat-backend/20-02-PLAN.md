---
phase: 20-r-skat-backend
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - variantcentrifuge/association/backends/r_backend.py
  - variantcentrifuge/association/tests/skat_r.py
  - variantcentrifuge/stages/analysis_stages.py
autonomous: true

must_haves:
  truths:
    - "Binary traits always use SKATBinary — SKAT() is never called for binary phenotypes"
    - "SKAT-O uses method='SKATO' and returns optimal rho in skat_o_rho column"
    - "Null model is fit once before gene loop and reused for all genes"
    - "R objects are deleted after each gene and gc() is called every 100 genes"
    - "R heap monitored periodically; WARNING logged if > 4 GB"
    - "Progress logged at INFO every max(10,min(50,n//10)) genes"
    - "Large panel (>2000 genes) emits warning before starting"
    - "Calling R backend from worker thread raises RuntimeError (not segfault)"
    - "AssociationAnalysisStage.parallel_safe returns False when R backend active"
    - "SKAT_Null_Model uses Adjustment=TRUE (moment adjustment for small samples)"
    - "R warnings captured per gene via withCallingHandlers"
    - "Statistical NA (from R NA_Real) mapped to p_value=None"
  artifacts:
    - path: "variantcentrifuge/association/backends/r_backend.py"
      provides: "Full RSKATBackend with fit_null_model, test_gene, memory management"
      contains: "SKATBinary"
    - path: "variantcentrifuge/association/tests/skat_r.py"
      provides: "RSKATTest with null model caching and gene loop"
      contains: "fit_null_model"
    - path: "variantcentrifuge/stages/analysis_stages.py"
      provides: "parallel_safe property on AssociationAnalysisStage"
      contains: "parallel_safe"
  key_links:
    - from: "variantcentrifuge/association/backends/r_backend.py"
      to: "R SKAT package"
      via: "rpy2 importr('SKAT') -> SKATBinary/SKAT calls"
      pattern: "SKATBinary|SKAT_Null_Model"
    - from: "variantcentrifuge/association/tests/skat_r.py"
      to: "variantcentrifuge/association/backends/r_backend.py"
      via: "RSKATTest.run() -> backend.test_gene()"
      pattern: "self._backend.test_gene"
    - from: "variantcentrifuge/stages/analysis_stages.py"
      to: "skat_backend config key"
      via: "parallel_safe checks context.config for R backend"
      pattern: "skat_backend.*parallel_safe"
---

<objective>
Implement the full RSKATBackend: null model fitting with SKAT_Null_Model(Adjustment=TRUE),
per-gene testing with SKATBinary (binary) or SKAT (continuous), SKAT-O via method="SKATO"
with rho extraction, R memory management (del + gc every 100 genes, heap monitoring),
R warning capture, thread safety guard, progress logging, and pipeline stage integration.

Purpose: This is the core statistical computation plan. After this, the R SKAT backend
is functionally complete and can run SKAT/SKAT-O on real data.

Output: Fully functional RSKATBackend, RSKATTest with null model caching, stage integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-r-skat-backend/20-RESEARCH.md
@.planning/phases/20-r-skat-backend/20-CONTEXT.md
@.planning/phases/20-r-skat-backend/20-01-SUMMARY.md
@variantcentrifuge/association/backends/r_backend.py
@variantcentrifuge/association/tests/skat_r.py
@variantcentrifuge/association/engine.py
@variantcentrifuge/association/base.py
@variantcentrifuge/stages/analysis_stages.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RSKATBackend fit_null_model + test_gene + memory management</name>
  <files>
    variantcentrifuge/association/backends/r_backend.py
  </files>
  <action>
Replace the stub methods in RSKATBackend with full implementations. All rpy2 imports
remain inside method bodies (never at module level).

**fit_null_model(phenotype, covariates, trait_type) -> NullModelResult:**
1. Call `self._assert_main_thread()`
2. Determine `out_type = "D" if trait_type == "binary" else "C"`
3. Build R objects using the simpler global-env pattern from research:
   ```python
   import rpy2.robjects as ro
   ro.globalenv["._vc_y"] = ro.FloatVector(phenotype.tolist())
   if covariates is not None and covariates.shape[1] > 0:
       r_cov = ro.r['matrix'](
           ro.FloatVector(covariates.ravel(order='F').tolist()),
           nrow=len(phenotype), ncol=covariates.shape[1],
       )
       ro.globalenv["._vc_x"] = r_cov
       formula_str = "._vc_y ~ ._vc_x"
   else:
       formula_str = "._vc_y ~ 1"
   ```
4. Call `self._skat_pkg.SKAT_Null_Model(ro.Formula(formula_str), out_type=out_type, Adjustment=True)`
   - Adjustment=TRUE enables moment adjustment for small samples (n<2000) automatically
   - This uses the unified SKAT 2.x API, NOT the deprecated SKAT_Null_Model_MomentAdjust
5. Clean up R globals: `ro.r("rm(list=ls(pattern='\\\\._vc_'))")`
   BUT keep the null model object — do NOT delete it.
6. Return `NullModelResult(model=null_obj, trait_type=trait_type, n_samples=len(phenotype), adjustment=True)`

**test_gene(gene, genotype_matrix, null_model, method, weights_beta) -> dict:**
1. Call `self._assert_main_thread()`
2. Convert numpy genotype_matrix to R matrix:
   ```python
   n_samples, n_variants = genotype_matrix.shape
   r_z = ro.r['matrix'](
       ro.FloatVector(genotype_matrix.ravel(order='F').tolist()),
       nrow=n_samples, ncol=n_variants,
   )
   ```
   CRITICAL: use `order='F'` for Fortran/column-major order (R expects column-major).
3. Assign to R global env and run via withCallingHandlers to capture warnings:
   ```python
   ro.globalenv["._vc_Z"] = r_z
   ro.globalenv["._vc_obj"] = null_model.model
   func_name = "SKATBinary" if null_model.trait_type == "binary" else "SKAT"
   ```
   Use the R code pattern from research (Pattern 7 — R Warnings Capture):
   ```r
   local({
     warns <- character(0)
     result <- withCallingHandlers(
       {func_name}(._vc_Z, ._vc_obj, kernel="linear.weighted",
                   method="{method}", weights.beta=c({a},{b})),
       warning = function(w) {
         warns <<- c(warns, conditionMessage(w))
         invokeRestart("muffleWarning")
       }
     )
     list(result=result, warnings=warns)
   })
   ```
4. Extract results:
   - p_value: `result.rx2("p.value")[0]` — guard with `NA_Real` check:
     `from rpy2.rinterface import NA_Real; p = None if p_val_r is NA_Real else float(p_val_r)`
   - rho (SKAT-O only): `result.rx2("param").rx2("rho")[0]` with NA_Real guard
   - n_marker_test: `result.rx2("param").rx2("n.marker.test")[0]`
   - warnings: list from the R withCallingHandlers capture
5. Clean up R globals: `ro.r("rm(list=ls(pattern='\\\\._vc_'))")`
6. `del r_z` (release rpy2 wrapper)
7. Return dict: `{"p_value": p_value, "rho": rho, "n_variants": n_variants,
   "n_marker_test": n_marker_test, "warnings": warnings_list}`

**R exceptions during test_gene:** If the R call raises an exception (not a statistical NA),
this is an R infrastructure failure. Let it propagate — the phase context says "Per-gene
R crash/exception mid-run: abort entire run immediately."

**Memory management methods:**
- `_run_r_gc() -> None`: Call `self._r_gc_func()` (cached `ro.r['gc']`) and `gc.collect()`.
  Log at DEBUG level.
- `_check_r_heap() -> float | None`: Call `ro.r('gc(verbose=FALSE)')`, extract Vcells used
  (row 2, col 1 of returned matrix), compute `vcells_used * 8 / 1024**2` for MB.
  Return None on any exception. Log WARNING if > 4 GB (`R_HEAP_WARNING_GB = 4.0`).
- `cleanup()`: Call `_run_r_gc()`. Log total genes processed and total elapsed time.

**Constants at class level:**
- `GC_INTERVAL = 100` — genes between GC calls (fixed, not configurable per research)
- `R_HEAP_WARNING_GB = 4.0` — heap warning threshold
- `LARGE_PANEL_THRESHOLD = 2000` — gene count warning threshold
  </action>
  <verify>
    - `python -c "from variantcentrifuge.association.backends.r_backend import RSKATBackend; print('OK')"` succeeds
    - `make lint` passes
    - Methods exist: `RSKATBackend.fit_null_model`, `RSKATBackend.test_gene`, `RSKATBackend._run_r_gc`, `RSKATBackend._check_r_heap`
  </verify>
  <done>
    RSKATBackend.fit_null_model() uses SKAT_Null_Model with Adjustment=TRUE.
    RSKATBackend.test_gene() dispatches to SKATBinary (binary) or SKAT (continuous).
    SKAT-O uses method="SKATO" and extracts optimal rho.
    NA_Real guarded — statistical NA returns p_value=None.
    R warnings captured via withCallingHandlers.
    Memory: del + gc every GC_INTERVAL genes, heap monitoring, cleanup().
    Thread safety: _assert_main_thread() called in fit_null_model and test_gene.
  </done>
</task>

<task type="auto">
  <name>Task 2: RSKATTest gene loop + stage parallel_safe integration</name>
  <files>
    variantcentrifuge/association/tests/skat_r.py
    variantcentrifuge/stages/analysis_stages.py
  </files>
  <action>
**skat_r.py — RSKATTest.run() full implementation:**

Replace the stub run() method. The key design: null model is fit ONCE on first run()
call and cached as `self._null_model`. This matches SKAT's intended usage (one null model
per cohort).

```python
def run(self, gene, contingency_data, config):
    # Extract per-gene data (same keys as logistic_burden, from Phase 19 stage integration)
    geno = contingency_data.get("genotype_matrix")
    phenotype = contingency_data.get("phenotype_vector")
    covariates = contingency_data.get("covariate_matrix")

    n_cases = contingency_data.get("proband_count", 0)
    n_controls = contingency_data.get("control_count", 0)

    # No genotype matrix = skip (p_value=None)
    if geno is None or geno.shape[1] == 0:
        return TestResult(gene=gene, test_name=self.name, p_value=None, ...)

    # Lazy null model fit (once per cohort, cached)
    if self._null_model is None:
        if phenotype is None:
            raise ValueError("RSKATTest requires phenotype_vector in contingency_data")
        self._null_model = self._backend.fit_null_model(
            phenotype, covariates, config.trait_type
        )
        # Track gene count for progress logging and GC
        self._genes_processed = 0
        self._start_time = time.time()
        # Large panel warning (checked once at start)
        # Note: we don't know total gene count here; this is handled in run_all_genes()

    # Run SKAT for this gene
    result = self._backend.test_gene(
        gene, geno, self._null_model, config.skat_method,
        weights_beta=_parse_weights_beta(config.variant_weights),
    )

    # Increment counter and handle GC + progress
    self._genes_processed += 1
    if self._genes_processed % self._backend.GC_INTERVAL == 0:
        self._backend._run_r_gc()
        heap_mb = self._backend._check_r_heap()
        if heap_mb is not None and heap_mb > self._backend.R_HEAP_WARNING_GB * 1024:
            logger.warning(
                f"R heap usage {heap_mb/1024:.1f} GB exceeds "
                f"{self._backend.R_HEAP_WARNING_GB} GB threshold"
            )

    # Build TestResult
    return TestResult(
        gene=gene,
        test_name=self.name,
        p_value=result["p_value"],
        corrected_p_value=None,
        effect_size=None,
        ci_lower=None,
        ci_upper=None,
        se=None,
        n_cases=n_cases,
        n_controls=n_controls,
        n_variants=result["n_variants"],
        extra={
            "skat_o_rho": result.get("rho"),
            "skat_warnings": "; ".join(result.get("warnings", [])) or None,
            "skat_method": config.skat_method,
        },
    )
```

Add helper `_parse_weights_beta(variant_weights: str) -> tuple[float, float]`:
- Parse "beta:a,b" -> (a, b) as floats
- "uniform" -> (1.0, 1.0) (equal weights)
- Default: (1.0, 25.0) matching SKAT convention

Add progress logging in run(). Use the engine's gene loop — the engine calls run() per
gene. We need progress logging inside RSKATTest since it's the only place that knows
about the R backend. Track total genes via a counter. Log every `log_interval` genes
where `log_interval = max(10, min(50, estimated_total // 10))`. Since we don't know
total at init, use a heuristic: set log_interval when _genes_processed first exceeds 10.
Alternative: Add `prepare(n_genes)` method called before gene loop for progress setup.
Better approach: Add a `notify_total_genes(n)` method that engine.run_all calls before
the gene loop for any test that has it. For now, simpler: log every 50 genes with
absolute count (no percentage), or add a `_total_genes` that gets set by a hook.

Simplest correct approach: Add a `prepare(gene_count: int)` method to RSKATTest that
the engine calls before the per-gene loop. In AssociationTest ABC, add default no-op
`prepare()`. In RSKATTest.prepare():
- Set `self._total_genes = gene_count`
- Set `self._log_interval = max(10, min(50, gene_count // 10))`
- If gene_count > LARGE_PANEL_THRESHOLD, log WARNING about large panel
- Log start message: "R SKAT: beginning analysis of {gene_count} genes"

In engine.py run_all(), add before the gene loop:
```python
for test in self._tests.values():
    if hasattr(test, 'prepare'):
        test.prepare(len(sorted_data))
```

Then in RSKATTest.run(), add progress logging:
```python
if self._total_genes and self._genes_processed % self._log_interval == 0:
    pct = 100 * self._genes_processed / self._total_genes
    logger.info(f"SKAT progress: {self._genes_processed}/{self._total_genes} genes ({pct:.0f}%)")
```

At the end (after last gene), log aggregate timing:
Add a `finalize()` method to RSKATTest (default no-op in ABC):
- Log total time: "R SKAT complete: {n} genes in {elapsed:.1f}s"
- Call `self._backend.cleanup()`

In engine.py run_all(), add after the gene loop:
```python
for test in self._tests.values():
    if hasattr(test, 'finalize'):
        test.finalize()
```

**analysis_stages.py — AssociationAnalysisStage.parallel_safe:**

Add a `parallel_safe` property that checks the config for R backend:
```python
@property
def parallel_safe(self) -> bool:
    """Return False when R backend active (rpy2 is not thread-safe)."""
    # Default is already False from Stage base class.
    # Explicit property documents the SKAT-08 requirement.
    return False
```
Note: The base class default is already False, so this is purely for documentation
and explicit SKAT-08 compliance. When a future Python-only backend is added, this
could conditionally return True.
  </action>
  <verify>
    - `python -c "from variantcentrifuge.association.tests.skat_r import RSKATTest; t = RSKATTest(); print(hasattr(t, 'prepare'), hasattr(t, 'finalize'))"` prints True True
    - `make lint` passes
    - `pytest tests/unit/ -x -q --timeout=60` passes (existing tests unbroken)
    - Grep analysis_stages.py for parallel_safe in AssociationAnalysisStage class
  </verify>
  <done>
    RSKATTest.run() extracts genotype matrix, fits null model once (cached),
    delegates to backend.test_gene() per gene, handles GC/progress/heap monitoring.
    prepare()/finalize() hooks added to engine for lifecycle management.
    AssociationAnalysisStage.parallel_safe explicitly returns False (SKAT-08).
    Progress logging at INFO level every max(10,min(50,n//10)) genes.
    Large panel warning emitted for >2000 genes.
    Aggregate timing logged at finalize().
  </done>
</task>

</tasks>

<verification>
1. RSKATBackend.fit_null_model uses `SKAT_Null_Model(..., Adjustment=True)` — grep confirms
2. RSKATBackend.test_gene dispatches `SKATBinary` for binary, `SKAT` for continuous — grep confirms
3. SKAT-O uses `method="SKATO"` — grep confirms
4. GC_INTERVAL = 100 — grep confirms
5. `_assert_main_thread()` called in fit_null_model and test_gene — grep confirms
6. `NA_Real` guard on p_value extraction — grep confirms
7. AssociationAnalysisStage has explicit `parallel_safe` returning False — grep confirms
8. `make lint && pytest tests/unit/ -x -q --timeout=60` both pass
</verification>

<success_criteria>
- Binary trait -> SKATBinary; continuous -> SKAT (never mixed)
- SKAT-O uses method="SKATO" and reports optimal rho in extra dict
- Null model fit once, reused across all genes in the cohort
- R memory: del per gene, gc() every 100 genes, heap check every 100 genes
- Thread safety: RuntimeError from non-main thread (not segfault)
- Progress: INFO log every max(10,min(50,n//10)) genes
- Large panel warning at >2000 genes
- Stage parallel_safe = False (SKAT-08)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-r-skat-backend/20-02-SUMMARY.md`
</output>
