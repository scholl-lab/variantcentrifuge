---
phase: 20-r-skat-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - variantcentrifuge/association/backends/__init__.py
  - variantcentrifuge/association/backends/base.py
  - variantcentrifuge/association/backends/r_backend.py
  - variantcentrifuge/association/tests/skat_r.py
  - variantcentrifuge/association/engine.py
  - variantcentrifuge/association/base.py
autonomous: true

must_haves:
  truths:
    - "Importing association package without R/rpy2 installed does not raise an error"
    - "get_skat_backend('r') returns RSKATBackend when R+SKAT are available"
    - "get_skat_backend('r') when R is missing raises ImportError with R_HOME hint"
    - "get_skat_backend('r') when SKAT package is missing raises ImportError with install.packages hint"
    - "Engine handles tests that return None effect column names without crashing"
    - "RSKATTest is registered in engine registry as 'skat'"
  artifacts:
    - path: "variantcentrifuge/association/backends/__init__.py"
      provides: "get_skat_backend() factory function"
      exports: ["get_skat_backend"]
    - path: "variantcentrifuge/association/backends/base.py"
      provides: "SKATBackend ABC and NullModel container"
      exports: ["SKATBackend", "NullModelResult"]
    - path: "variantcentrifuge/association/backends/r_backend.py"
      provides: "RSKATBackend with R detection and environment logging"
      exports: ["RSKATBackend"]
    - path: "variantcentrifuge/association/tests/skat_r.py"
      provides: "RSKATTest AssociationTest subclass wrapping RSKATBackend"
      exports: ["RSKATTest"]
  key_links:
    - from: "variantcentrifuge/association/tests/skat_r.py"
      to: "variantcentrifuge/association/backends/r_backend.py"
      via: "RSKATTest delegates to RSKATBackend"
      pattern: "RSKATBackend"
    - from: "variantcentrifuge/association/engine.py"
      to: "variantcentrifuge/association/tests/skat_r.py"
      via: "_build_registry() includes 'skat': RSKATTest"
      pattern: "skat.*RSKATTest"
    - from: "variantcentrifuge/association/engine.py"
      to: "effect_column_names None guard"
      via: "skip None-valued effect/CI columns"
      pattern: "col_names.*is not None"
---

<objective>
Create the SKAT backend abstraction layer (ABC + factory), RSKATBackend skeleton with
eager R/SKAT detection and environment logging, RSKATTest wrapper for the engine, and
fix the engine.py None-effect column guard needed for SKAT (which has no effect size).

Purpose: Establishes the backend infrastructure that Plan 20-02 fills with actual SKAT
computation logic. Eagerly detects R availability at engine construction time so users
get clear errors before data processing begins.

Output: backends/ subpackage, skat_r.py test wrapper, engine registry entry, engine fix.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-r-skat-backend/20-RESEARCH.md
@.planning/phases/20-r-skat-backend/20-CONTEXT.md
@variantcentrifuge/association/base.py
@variantcentrifuge/association/engine.py
@variantcentrifuge/association/__init__.py
@variantcentrifuge/association/tests/logistic_burden.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend abstraction layer + RSKATBackend skeleton with R detection</name>
  <files>
    variantcentrifuge/association/backends/__init__.py
    variantcentrifuge/association/backends/base.py
    variantcentrifuge/association/backends/r_backend.py
    variantcentrifuge/association/base.py
  </files>
  <action>
Create `variantcentrifuge/association/backends/` subpackage with three files:

**backends/base.py** — SKATBackend ABC:
- `@dataclass NullModelResult` container holding the R null model object (`model: Any`),
  `trait_type: str` ("binary"/"quantitative"), `n_samples: int`, `adjustment: bool`.
- `class SKATBackend(ABC)` with abstract methods:
  - `detect_environment() -> None` — raises ImportError if backend not available
  - `log_environment() -> None` — logs version info at INFO level
  - `fit_null_model(phenotype, covariates, trait_type) -> NullModelResult`
  - `test_gene(gene, genotype_matrix, null_model, method, weights_beta) -> dict`
    Returns dict with keys: p_value (float|None), rho (float|None), n_variants (int),
    n_marker_test (int|None), warnings (list[str])
  - `cleanup() -> None` — final GC call

**backends/r_backend.py** — RSKATBackend(SKATBackend):
- ALL rpy2 imports deferred to method bodies (never at module level). This is critical
  because `import rpy2.robjects` initializes R immediately.
- `detect_environment()`:
  1. Try `import rpy2.robjects` — catch Exception, raise ImportError with R_HOME diagnostic
     (include `os.environ.get("R_HOME", "<not set>")` and PATH suggestion)
  2. Check `rpy2.robjects.packages.isinstalled("SKAT")` — if False, raise ImportError with
     message "R found but SKAT package missing. Install with: install.packages('SKAT') in R."
  3. Load and cache `self._skat_pkg = importr("SKAT")`, `self._base_pkg = importr("base")`
  4. Store rpy2, R, SKAT versions as instance attributes for logging
- `log_environment()`:
  1. Log at INFO: `"R SKAT backend: rpy2={ver}, R={ver}, SKAT={ver}, R_HOME={path}"`
  2. Warn if R < 4.0: `"R version ... may not support all SKAT 2.x features. Recommend R >= 4.0."`
  3. Warn if SKAT < 2.0: `"SKAT version ... predates SKATBinary improvements. Recommend SKAT >= 2.0."`
  4. Warn if rpy2 < 3.5.0
  Use `packaging.version.Version` or simple string comparison for version checks.
- `_assert_main_thread()` — `threading.current_thread() is not threading.main_thread()` guard.
  Raises RuntimeError with clear message about rpy2 thread safety.
- `fit_null_model()` and `test_gene()` — implement as stubs that raise NotImplementedError
  with message "Implemented in Plan 20-02". These will be filled in the next plan.
- `cleanup()` — stub calling `ro.r['gc']()` and `gc.collect()`.

**backends/__init__.py** — Factory:
- `get_skat_backend(backend_name: str) -> SKATBackend` factory.
  - `"r"` -> RSKATBackend (import inside function body)
  - `"python"` -> raise NotImplementedError("Python SKAT backend is Phase 21")
  - `"auto"` -> try "r" first, fall back to "python", then raise if neither works
  - Any other value -> raise ValueError

**base.py update** — Add SKAT-specific fields to AssociationConfig:
- `skat_backend: str = "auto"` — "r", "python", or "auto"
- `skat_method: str = "SKAT"` — "SKAT", "Burden", or "SKATO"
  </action>
  <verify>
    - `python -c "from variantcentrifuge.association.backends.base import SKATBackend, NullModelResult; print('OK')"` succeeds
    - `python -c "from variantcentrifuge.association.backends import get_skat_backend; print('OK')"` succeeds
    - `python -c "from variantcentrifuge.association.base import AssociationConfig; c = AssociationConfig(); print(c.skat_backend, c.skat_method)"` prints "auto SKAT"
    - `make lint` passes
  </verify>
  <done>
    backends/ subpackage exists with ABC, R backend skeleton, and factory.
    AssociationConfig has skat_backend and skat_method fields.
    No rpy2 import at module level in r_backend.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: RSKATTest wrapper + engine registry + engine None-effect guard</name>
  <files>
    variantcentrifuge/association/tests/skat_r.py
    variantcentrifuge/association/engine.py
  </files>
  <action>
**tests/skat_r.py** — RSKATTest(AssociationTest):
- `name` property returns `"skat"`
- `__init__()`: `self._backend: RSKATBackend | None = None`
- `check_dependencies()`:
  1. Import `get_skat_backend` from backends (local import)
  2. Get backend via `get_skat_backend(config_backend_name)` — for now hardcode "r"
     since this class IS the R SKAT test. The engine registry maps "skat" -> RSKATTest.
  3. Call `backend.detect_environment()`
  4. Call `backend.log_environment()`
  5. Store `self._backend = backend`
- `effect_column_names()`: Return `{"effect": None, "se": None, "ci_lower": None, "ci_upper": None}`.
  SKAT has no effect size, no SE, no CI. The engine must handle all-None gracefully.
- `run(gene, contingency_data, config)`:
  1. Extract genotype_matrix, phenotype_vector, covariate_matrix from contingency_data
     (same keys as logistic_burden uses, established in Phase 19)
  2. If genotype_matrix missing or has 0 variants: return TestResult with p_value=None
  3. Lazy null model: if `self._null_model` is None, call
     `self._backend.fit_null_model(phenotype, covariates, config.trait_type)`
     and cache as `self._null_model`. (Null model is fit once, reused for all genes.)
  4. Call `self._backend.test_gene(gene, genotype_matrix, self._null_model, config.skat_method, ...)`
  5. Build and return TestResult:
     - p_value from result dict
     - effect_size=None, se=None, ci_lower=None, ci_upper=None (SKAT has no effect)
     - extra={"skat_o_rho": result["rho"], "skat_warnings": result["warnings"],
              "skat_method": config.skat_method, "skat_n_marker_test": result["n_marker_test"]}
  Note: run() will raise NotImplementedError until Plan 20-02 fills the backend stubs.

**engine.py** — Two changes:

1. Fix None-effect column guard (lines 213-220). Currently line 216 does:
   `row[f"{test_name}_{col_names['effect']}"] = res.effect_size`
   When effect is None, this produces column `skat_None`. Fix:
   ```python
   if col_names.get("effect") is not None:
       row[f"{test_name}_{col_names['effect']}"] = res.effect_size
   if col_names.get("se") is not None:
       row[f"{test_name}_{col_names['se']}"] = res.se
   if col_names.get("ci_lower") is not None:
       row[f"{test_name}_{col_names['ci_lower']}"] = res.ci_lower
   if col_names.get("ci_upper") is not None:
       row[f"{test_name}_{col_names['ci_upper']}"] = res.ci_upper
   ```

2. Add "skat" to _build_registry():
   ```python
   from variantcentrifuge.association.tests.skat_r import RSKATTest
   # ... in the return dict:
   "skat": RSKATTest,
   ```
   Import must be inside _build_registry() (lazy), same pattern as existing tests.

3. Add extra columns from TestResult.extra to the output DataFrame. After the effect
   columns block, add:
   ```python
   # Write test-specific extra columns (e.g., skat_o_rho, skat_warnings)
   for extra_key, extra_val in res.extra.items():
       row[f"{test_name}_{extra_key}"] = extra_val
   ```
   This writes skat_skat_o_rho, skat_skat_warnings etc. Wait — the test_name is "skat"
   and extra keys are "skat_o_rho" etc. That would produce "skat_skat_o_rho".
   Instead, use bare extra key names (they're already namespaced by the test):
   ```python
   for extra_key, extra_val in res.extra.items():
       row[extra_key] = extra_val
   ```
   This produces columns: skat_o_rho, skat_warnings, skat_method — matching the
   research recommendation. Other tests (Fisher, burden) have empty extra dicts so
   this loop is a no-op for them.
  </action>
  <verify>
    - `python -c "from variantcentrifuge.association.tests.skat_r import RSKATTest; t = RSKATTest(); print(t.name)"` prints "skat"
    - `python -c "from variantcentrifuge.association.tests.skat_r import RSKATTest; print(RSKATTest().effect_column_names())"` shows all None values
    - `python -c "from variantcentrifuge.association.engine import _build_registry; r = _build_registry(); print('skat' in r)"` prints True
    - Verify extra columns are written: `python -c "from variantcentrifuge.association.base import TestResult; r = TestResult(gene='X', test_name='skat', p_value=0.05, extra={'skat_o_rho': 0.5}); print(r.extra)"` shows dict with skat_o_rho
    - `make lint` passes
    - `pytest tests/unit/ -x -q --timeout=30` passes (existing tests unbroken)
  </verify>
  <done>
    RSKATTest registered in engine as "skat".
    Engine handles None effect columns without producing "skat_None" column names.
    Extra columns from TestResult.extra written to output DataFrame.
    Existing Fisher and burden tests unaffected (verified by pytest).
  </done>
</task>

</tasks>

<verification>
1. `python -c "from variantcentrifuge.association.backends import get_skat_backend"` succeeds
2. `python -c "from variantcentrifuge.association.engine import _build_registry; print(sorted(_build_registry().keys()))"` includes "skat"
3. `python -c "from variantcentrifuge.association.tests.skat_r import RSKATTest; t = RSKATTest(); print(t.effect_column_names())"` shows all None effect columns
4. `make lint && make format` pass cleanly
5. `pytest tests/unit/ -x -q --timeout=60` — all existing tests pass
</verification>

<success_criteria>
- backends/ subpackage with ABC and R backend skeleton exists
- RSKATBackend.detect_environment() provides clear error messages for R-missing, SKAT-missing, R_HOME-misconfigured
- RSKATTest is in engine registry and its effect_column_names() returns all-None
- Engine handles all-None effect columns without producing malformed column names
- TestResult.extra dict written to output DataFrame for SKAT-specific columns
- No rpy2 import at module level anywhere
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/20-r-skat-backend/20-01-SUMMARY.md`
</output>
