---
phase: 23-pca-functional-weights-allelic-series-json-config
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - variantcentrifuge/association/weights.py
  - variantcentrifuge/association/base.py
  - variantcentrifuge/stages/analysis_stages.py
  - variantcentrifuge/cli.py
  - tests/unit/test_functional_weights.py
autonomous: true

must_haves:
  truths:
    - "User can specify --variant-weights cadd and get CADD-normalized weights applied"
    - "User can specify --variant-weights revel and get REVEL-based weights applied"
    - "User can specify --variant-weights combined and get Beta(MAF) x CADD weights"
    - "LoF variants missing CADD/REVEL scores receive maximum functional weight (1.0)"
    - "Missense variants missing scores fall back to Beta(MAF)-only (functional=1.0)"
    - "Missing score counts are logged per variant category"
  artifacts:
    - path: "variantcentrifuge/association/weights.py"
      provides: "CADD, REVEL, and combined weight functions"
      exports: ["cadd_weights", "revel_weights", "combined_weights", "get_weights"]
    - path: "tests/unit/test_functional_weights.py"
      provides: "Unit tests for functional weight schemes"
      min_lines: 80
  key_links:
    - from: "variantcentrifuge/stages/analysis_stages.py"
      to: "variantcentrifuge/association/weights.py"
      via: "Functional weights called with CADD/REVEL scores from DataFrame"
      pattern: "cadd_weights|revel_weights|combined_weights"
    - from: "variantcentrifuge/association/weights.py"
      to: "DataFrame columns"
      via: "dbNSFP_CADD_phred and dbNSFP_REVEL_score column values"
      pattern: "cadd_scores|revel_scores"
---

<objective>
Implement functional variant weights: CADD-normalized, REVEL-based, and combined (Beta(MAF) x functional) weight schemes with variant-type-aware fallback for missing scores.

Purpose: Allow users to apply annotation-based variant weights that up-weight damaging variants beyond MAF-based weights alone, increasing power for detecting pathogenic associations.
Output: Extended weights.py with three new weight functions, CLI args, stage integration, unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-CONTEXT.md
@.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-RESEARCH.md
@.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-01-SUMMARY.md

Key source files:
@variantcentrifuge/association/weights.py
@variantcentrifuge/association/base.py
@variantcentrifuge/stages/analysis_stages.py (AssociationAnalysisStage._process, line ~2102)
@variantcentrifuge/cli.py (--variant-weights arg, line ~474)
@variantcentrifuge/config.json (field names: dbNSFP_CADD_phred, dbNSFP_REVEL_score)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add functional weight functions to weights.py and extend CLI</name>
  <files>
    variantcentrifuge/association/weights.py
    variantcentrifuge/association/base.py
    variantcentrifuge/cli.py
  </files>
  <action>
    1. **Add to weights.py** (keep as single file per research recommendation):

    Define variant type constants at module level:
    ```python
    LOF_EFFECTS = frozenset({
        "stop_gained", "frameshift_variant",
        "splice_acceptor_variant", "splice_donor_variant",
    })
    MISSENSE_EFFECTS = frozenset({"missense_variant"})
    ```

    Add `cadd_weights(mafs, cadd_scores, variant_effects=None, cap=40.0)` -> np.ndarray:
    - `maf_w = beta_maf_weights(mafs)` (reuse existing)
    - Create nan_mask from cadd_scores (np.isnan after coercing to float, handling None/"." as NaN)
    - `functional = np.where(nan_mask, 1.0, np.minimum(cadd_scores / cap, 1.0))`
    - If variant_effects provided, apply type-aware fallback for missing scores:
      - LoF (effect in LOF_EFFECTS) missing CADD -> functional = 1.0 (already default, but log count)
      - Missense missing CADD -> functional = 1.0 (Beta(MAF)-only, already default, log count)
      - Other missing -> functional = 1.0 (Beta(MAF)-only, log count)
    - Log warning with counts: "CADD weights: {n_lof} LoF, {n_miss} missense, {n_other} other variants had missing scores (used fallback weights)"
    - Return `maf_w * functional`

    Add `revel_weights(mafs, revel_scores, variant_effects=None)` -> np.ndarray:
    - Same structure as cadd_weights but REVEL is already 0-1 range, no cap needed.
    - `functional = np.where(nan_mask, 1.0, revel_scores_clean)`
    - Same type-aware fallback logging.
    - Return `maf_w * functional`

    Add `combined_weights(mafs, cadd_scores=None, revel_scores=None, variant_effects=None, cadd_cap=40.0)` -> np.ndarray:
    - If cadd_scores provided: use CADD normalization.
    - If revel_scores provided (and no cadd_scores): use REVEL.
    - If both: use CADD (CADD is the default for "combined").
    - This is `Beta(MAF) x functional_score` — same as cadd_weights/revel_weights but explicitly named as the "combined" scheme.

    **Extend `get_weights()`** — add optional kwargs:
    ```python
    def get_weights(
        mafs: np.ndarray,
        weight_spec: str,
        *,  # keyword-only
        cadd_scores: np.ndarray | None = None,
        revel_scores: np.ndarray | None = None,
        variant_effects: np.ndarray | None = None,
        weight_params: dict | None = None,
    ) -> np.ndarray:
    ```
    - Add dispatch for new specs:
      - `"cadd"` -> `cadd_weights(mafs, cadd_scores, variant_effects, cap=weight_params.get("cadd_cap", 40.0) if weight_params else 40.0)`
      - `"revel"` -> `revel_weights(mafs, revel_scores, variant_effects)`
      - `"combined"` -> `combined_weights(mafs, cadd_scores, revel_scores, variant_effects, ...)`
    - Raise ValueError if cadd spec used but cadd_scores is None (same for revel).

    2. **Extend AssociationConfig** in base.py:
    ```python
    variant_weight_params: dict | None = None
    """Extra parameters for weight schemes (e.g. {'cadd_cap': 40.0})."""
    ```

    3. **Update CLI** --variant-weights help text to list new options:
    ```python
    "--variant-weights",
    type=str,
    default="beta:1,25",
    help=(
        "Variant weighting scheme. "
        "'beta:a,b' = Beta(MAF;a,b) density (default: 'beta:1,25'). "
        "'uniform' = equal weights. "
        "'cadd' = Beta(MAF) x CADD_phred/40. "
        "'revel' = Beta(MAF) x REVEL_score. "
        "'combined' = Beta(MAF) x functional score (CADD preferred)."
    ),
    ```

    Add new CLI arg:
    ```python
    stats_group.add_argument(
        "--variant-weight-params",
        type=str,
        default=None,
        help=(
            "JSON string of extra weight parameters, e.g. "
            "'{\"cadd_cap\": 30}'. Overrides default parameters."
        ),
    )
    ```
    Parse it in the validation section: `json.loads(args.variant_weight_params)` if provided.
    Wire to context.config: `"variant_weight_params": parsed_params_or_None`.
  </action>
  <verify>
    `python -c "from variantcentrifuge.association.weights import cadd_weights, revel_weights, combined_weights, get_weights; print('OK')"` succeeds.
    `make lint && make format` passes.
  </verify>
  <done>
    weights.py has cadd_weights, revel_weights, combined_weights functions.
    get_weights() dispatches to new specs: "cadd", "revel", "combined".
    CLI has updated --variant-weights help and new --variant-weight-params arg.
    AssociationConfig has variant_weight_params field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stage integration and unit tests for functional weights</name>
  <files>
    variantcentrifuge/stages/analysis_stages.py
    tests/unit/test_functional_weights.py
  </files>
  <action>
    1. **Wire functional weights into AssociationAnalysisStage._process()** in analysis_stages.py:
       - In the section where the engine iterates over genes and calls tests, the weight vector is computed per gene. Find where `get_weights()` is called (or where weights are passed to test.run()).
       - When variant_weights spec is "cadd", "revel", or "combined", extract the annotation columns from the gene DataFrame:
         ```python
         cadd_scores = None
         revel_scores = None
         variant_effects = None
         if assoc_config.variant_weights in ("cadd", "revel", "combined"):
             # Extract annotation columns from gene_df
             cadd_col = next((c for c in gene_df.columns if c.lower() in ("dbnsfp_cadd_phred", "cadd_phred")), None)
             revel_col = next((c for c in gene_df.columns if c.lower() in ("dbnsfp_revel_score", "revel_score")), None)
             effect_col = next((c for c in gene_df.columns if c.upper() in ("EFFECT", "ANN_0__EFFECT")), None)

             if cadd_col:
                 cadd_scores = pd.to_numeric(gene_df[cadd_col], errors="coerce").values
             if revel_col:
                 revel_scores = pd.to_numeric(gene_df[revel_col], errors="coerce").values
             if effect_col:
                 variant_effects = gene_df[effect_col].values
         ```
       - Pass these to `get_weights()` via the new keyword args.
       - Also wire `assoc_config.variant_weight_params` into the config construction (add it to the AssociationConfig() call).
       - Note: The exact location depends on how the engine currently calls get_weights(). Look at how the genotype matrix builder or burden tests use weights. Weights are applied per-gene in the test.run() call — the engine passes the weight spec through config. The functional weight scores must be extracted per-gene from the DataFrame and passed alongside.

    2. **Unit tests** in tests/unit/test_functional_weights.py:
       - Test `cadd_weights()`:
         - Normal case: MAFs + CADD scores -> Beta(MAF) * min(CADD/40, 1.0)
         - CADD score > 40 -> capped at 1.0
         - Missing CADD (NaN) for LoF variant -> functional=1.0 (max weight)
         - Missing CADD for missense -> functional=1.0 (fallback)
         - Custom cap (30.0) via weight_params
       - Test `revel_weights()`:
         - Normal case: MAFs + REVEL scores -> Beta(MAF) * REVEL
         - Missing REVEL for LoF -> functional=1.0
         - REVEL is already 0-1, no normalization
       - Test `combined_weights()`:
         - With CADD scores -> uses CADD normalization
         - With REVEL scores -> uses REVEL
       - Test `get_weights()` dispatch:
         - "cadd" with cadd_scores -> calls cadd_weights
         - "revel" with revel_scores -> calls revel_weights
         - "combined" -> calls combined_weights
         - "cadd" without cadd_scores -> raises ValueError
         - Existing "beta:1,25" and "uniform" still work (regression check)
       - Test type-aware fallback logging (use caplog):
         - Missing CADD on LoF variants -> log includes "LoF" count
         - Missing CADD on missense -> log includes "missense" count
       - Verify cadd_weights and revel_weights produce DIFFERENT results from uniform_weights on the same data (confirms weights are actually applied).
       - Mark all tests `@pytest.mark.unit`.
  </action>
  <verify>
    `pytest tests/unit/test_functional_weights.py -v` passes all tests.
    `make lint && make format` passes.
    `make test-fast` passes (no regressions).
  </verify>
  <done>
    Functional weights are wired into AssociationAnalysisStage for "cadd", "revel", "combined" specs.
    Annotation columns (dbNSFP_CADD_phred, dbNSFP_REVEL_score, EFFECT) are extracted per gene.
    Unit tests verify all weight schemes, type-aware fallback, logging, and no regressions.
    All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from variantcentrifuge.association.weights import cadd_weights, revel_weights, get_weights"` imports cleanly
2. `pytest tests/unit/test_functional_weights.py -v` — all functional weight tests pass
3. `make test-fast` — no regressions
4. `make lint && make format` — clean
</verification>

<success_criteria>
- "cadd" weights produce Beta(MAF) x min(CADD_phred/40, 1.0) with configurable cap
- "revel" weights produce Beta(MAF) x REVEL_score
- "combined" weights use CADD normalization by default
- LoF variants with missing scores get maximum functional weight (1.0)
- Missense with missing scores fall back to Beta(MAF)-only
- Missing score counts logged per variant category
- Different from uniform weights on same data (weights actually applied)
- Existing "beta:1,25" and "uniform" specs unchanged (regression-safe)
</success_criteria>

<output>
After completion, create `.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-02-SUMMARY.md`
</output>
