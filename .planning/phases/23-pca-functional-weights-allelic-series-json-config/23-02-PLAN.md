---
phase: 23-pca-functional-weights-allelic-series-json-config
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - variantcentrifuge/association/weights.py
  - variantcentrifuge/association/base.py
  - variantcentrifuge/stages/analysis_stages.py
  - variantcentrifuge/cli.py
  - tests/unit/test_functional_weights.py
autonomous: true

must_haves:
  truths:
    - "User can specify --variant-weights cadd and get CADD-normalized weights applied"
    - "User can specify --variant-weights revel and get REVEL-based weights applied"
    - "User can specify --variant-weights combined and get Beta(MAF) x CADD weights"
    - "LoF variants missing CADD/REVEL scores receive maximum functional weight (1.0)"
    - "Missense variants missing scores fall back to Beta(MAF)-only (functional=1.0)"
    - "Missing score counts are logged per variant category"
    - "Functional weight schemes produce different p-values than uniform weights on the same data, confirming weights are applied"
  artifacts:
    - path: "variantcentrifuge/association/weights.py"
      provides: "CADD, REVEL, and combined weight functions"
      exports: ["cadd_weights", "revel_weights", "combined_weights", "get_weights"]
    - path: "tests/unit/test_functional_weights.py"
      provides: "Unit tests for functional weight schemes"
      min_lines: 80
  key_links:
    - from: "variantcentrifuge/association/tests/logistic_burden.py"
      to: "variantcentrifuge/association/weights.py"
      via: "get_weights() called in test.run() with contingency_data scores"
      pattern: "get_weights.*cadd_scores|contingency_data.*cadd_scores"
    - from: "variantcentrifuge/stages/analysis_stages.py"
      to: "gene_data dict (contingency_data)"
      via: "CADD/REVEL/EFFECT columns extracted from gene_df and stored in gene_data"
      pattern: "gene_data.*cadd_scores|gene_data.*revel_scores|gene_data.*variant_effects"
    - from: "variantcentrifuge/association/weights.py"
      to: "DataFrame columns"
      via: "dbNSFP_CADD_phred and dbNSFP_REVEL_score column values"
      pattern: "cadd_scores|revel_scores"
---

<objective>
Implement functional variant weights: CADD-normalized, REVEL-based, and combined (Beta(MAF) x functional) weight schemes with variant-type-aware fallback for missing scores.

Purpose: Allow users to apply annotation-based variant weights that up-weight damaging variants beyond MAF-based weights alone, increasing power for detecting pathogenic associations.
Output: Extended weights.py with three new weight functions, CLI args, stage integration, unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-CONTEXT.md
@.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-RESEARCH.md
@.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-01-SUMMARY.md

Key source files:
@variantcentrifuge/association/weights.py
@variantcentrifuge/association/base.py
@variantcentrifuge/stages/analysis_stages.py (AssociationAnalysisStage._process, line ~2102; genotype matrix loop line ~2316)
@variantcentrifuge/cli.py (--variant-weights arg, line ~474)
@variantcentrifuge/config.json (field names: dbNSFP_CADD_phred, dbNSFP_REVEL_score)
@variantcentrifuge/association/tests/logistic_burden.py (get_weights call at line ~331)
@variantcentrifuge/association/tests/linear_burden.py (get_weights call at line ~153)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add functional weight functions to weights.py and extend CLI</name>
  <files>
    variantcentrifuge/association/weights.py
    variantcentrifuge/association/base.py
    variantcentrifuge/cli.py
  </files>
  <action>
    1. **Add to weights.py** (keep as single file per research recommendation):

    Define variant type constants at module level:
    ```python
    LOF_EFFECTS = frozenset({
        "stop_gained", "frameshift_variant",
        "splice_acceptor_variant", "splice_donor_variant",
    })
    MISSENSE_EFFECTS = frozenset({"missense_variant"})
    ```

    Add `cadd_weights(mafs, cadd_scores, variant_effects=None, cap=40.0)` -> np.ndarray:
    - `maf_w = beta_maf_weights(mafs)` (reuse existing)
    - Create nan_mask from cadd_scores (np.isnan after coercing to float, handling None/"." as NaN)
    - `functional = np.where(nan_mask, 1.0, np.minimum(cadd_scores / cap, 1.0))`
    - If variant_effects provided, apply type-aware fallback for missing scores:
      - LoF (effect in LOF_EFFECTS) missing CADD -> functional = 1.0 (already default, but log count)
      - Missense missing CADD -> functional = 1.0 (Beta(MAF)-only, already default, log count)
      - Other missing -> functional = 1.0 (Beta(MAF)-only, log count)
    - Log warning with counts: "CADD weights: {n_lof} LoF, {n_miss} missense, {n_other} other variants had missing scores (used fallback weights)"
    - Return `maf_w * functional`

    Add `revel_weights(mafs, revel_scores, variant_effects=None)` -> np.ndarray:
    - Same structure as cadd_weights but REVEL is already 0-1 range, no cap needed.
    - `functional = np.where(nan_mask, 1.0, revel_scores_clean)`
    - Same type-aware fallback logging.
    - Return `maf_w * functional`

    Add `combined_weights(mafs, cadd_scores=None, revel_scores=None, variant_effects=None, cadd_cap=40.0)` -> np.ndarray:
    - If cadd_scores provided: use CADD normalization.
    - If revel_scores provided (and no cadd_scores): use REVEL.
    - If both: use CADD (CADD is the default for "combined").
    - This is `Beta(MAF) x functional_score` — same as cadd_weights/revel_weights but explicitly named as the "combined" scheme.

    **Extend `get_weights()`** — add optional kwargs:
    ```python
    def get_weights(
        mafs: np.ndarray,
        weight_spec: str,
        *,  # keyword-only
        cadd_scores: np.ndarray | None = None,
        revel_scores: np.ndarray | None = None,
        variant_effects: np.ndarray | None = None,
        weight_params: dict | None = None,
    ) -> np.ndarray:
    ```
    - Add dispatch for new specs:
      - `"cadd"` -> `cadd_weights(mafs, cadd_scores, variant_effects, cap=weight_params.get("cadd_cap", 40.0) if weight_params else 40.0)`
      - `"revel"` -> `revel_weights(mafs, revel_scores, variant_effects)`
      - `"combined"` -> `combined_weights(mafs, cadd_scores, revel_scores, variant_effects, ...)`
    - Raise ValueError if cadd spec used but cadd_scores is None (same for revel).
    - IMPORTANT: The new kwargs are keyword-only and optional with None defaults, so ALL existing callers (`get_weights(mafs, spec)`) continue to work unchanged for "beta:*" and "uniform" specs.

    2. **Extend AssociationConfig** in base.py:
    ```python
    variant_weight_params: dict | None = None
    """Extra parameters for weight schemes (e.g. {'cadd_cap': 40.0})."""
    ```

    3. **Update CLI** --variant-weights help text to list new options:
    ```python
    "--variant-weights",
    type=str,
    default="beta:1,25",
    help=(
        "Variant weighting scheme. "
        "'beta:a,b' = Beta(MAF;a,b) density (default: 'beta:1,25'). "
        "'uniform' = equal weights. "
        "'cadd' = Beta(MAF) x CADD_phred/40. "
        "'revel' = Beta(MAF) x REVEL_score. "
        "'combined' = Beta(MAF) x functional score (CADD preferred)."
    ),
    ```

    Add new CLI arg:
    ```python
    stats_group.add_argument(
        "--variant-weight-params",
        type=str,
        default=None,
        help=(
            "JSON string of extra weight parameters, e.g. "
            "'{\"cadd_cap\": 30}'. Overrides default parameters."
        ),
    )
    ```
    Parse it in the validation section: `json.loads(args.variant_weight_params)` if provided.
    Wire to context.config: `"variant_weight_params": parsed_params_or_None`.
  </action>
  <verify>
    `python -c "from variantcentrifuge.association.weights import cadd_weights, revel_weights, combined_weights, get_weights; print('OK')"` succeeds.
    `make lint && make format` passes.
  </verify>
  <done>
    weights.py has cadd_weights, revel_weights, combined_weights functions.
    get_weights() dispatches to new specs: "cadd", "revel", "combined".
    CLI has updated --variant-weights help and new --variant-weight-params arg.
    AssociationConfig has variant_weight_params field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stage integration (annotation extraction + weight wiring) and unit tests</name>
  <files>
    variantcentrifuge/stages/analysis_stages.py
    variantcentrifuge/association/tests/logistic_burden.py
    variantcentrifuge/association/tests/linear_burden.py
    tests/unit/test_functional_weights.py
  </files>
  <action>
    **Architecture decision: Where functional weight data flows.**

    `get_weights()` is called INSIDE the test classes (logistic_burden.py line 331, linear_burden.py line 153) with `config.variant_weights` (the spec string) and `mafs` from `contingency_data`. The functional annotation scores (CADD, REVEL, variant_effects) are per-gene data, so they must be:
    1. Extracted from gene_df in the stage's genotype matrix loop
    2. Stored in gene_data dict (contingency_data)
    3. Read by test.run() and passed to get_weights()

    **Step 1: Extract annotation columns in analysis_stages.py genotype matrix loop** (line ~2316-2363):

    Inside the `for gene_data in gene_burden_data:` loop, after building the genotype matrix and before storing gene_data entries, add extraction of functional annotation columns from gene_df:
    ```python
    # Extract functional annotation columns for weight schemes (WEIGHT-05)
    if assoc_config.variant_weights in ("cadd", "revel", "combined"):
        cadd_col = next((c for c in gene_df.columns if c.lower() in ("dbnsfp_cadd_phred", "cadd_phred")), None)
        revel_col = next((c for c in gene_df.columns if c.lower() in ("dbnsfp_revel_score", "revel_score")), None)
        effect_col = next((c for c in gene_df.columns if c.upper() in ("EFFECT", "ANN_0__EFFECT")), None)

        if cadd_col:
            gene_data["cadd_scores"] = pd.to_numeric(gene_df[cadd_col], errors="coerce").values
        if revel_col:
            gene_data["revel_scores"] = pd.to_numeric(gene_df[revel_col], errors="coerce").values
        if effect_col:
            gene_data["variant_effects"] = gene_df[effect_col].values
    ```

    Place this AFTER the genotype_matrix/variant_mafs assignments (line ~2358) and BEFORE the `gene_data["phenotype_vector"]` assignment (line ~2361). The annotation arrays have length = n_variants (same as variant_mafs), NOT n_samples.

    Also wire `assoc_config.variant_weight_params` into the AssociationConfig() constructor call.

    **Step 2: Update get_weights() calls in test classes** to pass functional scores from contingency_data:

    In `variantcentrifuge/association/tests/logistic_burden.py` (line ~331), change:
    ```python
    weights = get_weights(mafs, config.variant_weights)
    ```
    to:
    ```python
    weights = get_weights(
        mafs, config.variant_weights,
        cadd_scores=contingency_data.get("cadd_scores"),
        revel_scores=contingency_data.get("revel_scores"),
        variant_effects=contingency_data.get("variant_effects"),
        weight_params=config.variant_weight_params,
    )
    ```

    Make the same change in `variantcentrifuge/association/tests/linear_burden.py` (line ~153).

    These calls are backward-compatible: for "beta:*" and "uniform" specs, the new kwargs are ignored inside get_weights(). For "cadd"/"revel"/"combined", the scores are read from contingency_data where the stage stored them.

    **Step 3: Unit tests** in tests/unit/test_functional_weights.py:
    - Test `cadd_weights()`:
      - Normal case: MAFs + CADD scores -> Beta(MAF) * min(CADD/40, 1.0)
      - CADD score > 40 -> capped at 1.0
      - Missing CADD (NaN) for LoF variant -> functional=1.0 (max weight)
      - Missing CADD for missense -> functional=1.0 (fallback)
      - Custom cap (30.0) via weight_params
    - Test `revel_weights()`:
      - Normal case: MAFs + REVEL scores -> Beta(MAF) * REVEL
      - Missing REVEL for LoF -> functional=1.0
      - REVEL is already 0-1, no normalization
    - Test `combined_weights()`:
      - With CADD scores -> uses CADD normalization
      - With REVEL scores -> uses REVEL
    - Test `get_weights()` dispatch:
      - "cadd" with cadd_scores -> calls cadd_weights
      - "revel" with revel_scores -> calls revel_weights
      - "combined" -> calls combined_weights
      - "cadd" without cadd_scores -> raises ValueError
      - Existing "beta:1,25" and "uniform" still work (regression check)
    - Test type-aware fallback logging (use caplog):
      - Missing CADD on LoF variants -> log includes "LoF" count
      - Missing CADD on missense -> log includes "missense" count
    - **Verify cadd_weights and revel_weights produce DIFFERENT numerical results from uniform_weights on the same MAF/score data** (confirms weights are actually applied, not identity).
    - Mark all tests `@pytest.mark.unit`.
  </action>
  <verify>
    `pytest tests/unit/test_functional_weights.py -v` passes all tests.
    `make lint && make format` passes.
    `make test-fast` passes (no regressions).
  </verify>
  <done>
    Functional annotation columns (CADD, REVEL, EFFECT) extracted per-gene in stage and stored in gene_data dict.
    logistic_burden.py and linear_burden.py pass functional scores from contingency_data to get_weights().
    Unit tests verify all weight schemes, type-aware fallback, logging, difference from uniform, and no regressions.
    All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from variantcentrifuge.association.weights import cadd_weights, revel_weights, get_weights"` imports cleanly
2. `pytest tests/unit/test_functional_weights.py -v` — all functional weight tests pass
3. `make test-fast` — no regressions
4. `make lint && make format` — clean
</verification>

<success_criteria>
- "cadd" weights produce Beta(MAF) x min(CADD_phred/40, 1.0) with configurable cap
- "revel" weights produce Beta(MAF) x REVEL_score
- "combined" weights use CADD normalization by default
- LoF variants with missing scores get maximum functional weight (1.0)
- Missense with missing scores fall back to Beta(MAF)-only
- Missing score counts logged per variant category
- Functional weights produce different results from uniform weights (weights actually applied)
- Existing "beta:1,25" and "uniform" specs unchanged (regression-safe)
</success_criteria>

<output>
After completion, create `.planning/phases/23-pca-functional-weights-allelic-series-json-config/23-02-SUMMARY.md`
</output>
