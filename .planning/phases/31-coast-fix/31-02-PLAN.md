---
phase: 31-coast-fix
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - variantcentrifuge/association/tests/allelic_series.py
  - variantcentrifuge/association/tests/allelic_series_python.py
  - variantcentrifuge/association/base.py
  - variantcentrifuge/cli.py
  - scoring/coast_classification/sift_polyphen/variable_assignment_config.json
  - scoring/coast_classification/sift_polyphen/formula_config.json
  - scoring/coast_classification/cadd/variable_assignment_config.json
  - scoring/coast_classification/cadd/formula_config.json
  - scoring/coast_classification/custom_template/variable_assignment_config.json
  - scoring/coast_classification/custom_template/formula_config.json
  - tests/unit/test_coast_classification.py
autonomous: true

must_haves:
  truths:
    - "SnpEff '&'-concatenated effect strings like 'stop_gained&splice_region_variant' are correctly classified as PTV"
    - "User can specify --coast-classification cadd and COAST uses CADD thresholds for BMV/DMV/PTV"
    - "Default --coast-classification sift_polyphen produces identical results to the prior hardcoded classify_variants logic"
    - "When --association-tests coast is specified, required annotation fields are auto-injected into field extraction"
    - "If CADD classification is selected but VCF lacks CADD annotations, pipeline fails early with a clear error"
    - "coast_classification.tsv diagnostics file is written when --diagnostics-output is set"
  artifacts:
    - path: "scoring/coast_classification/sift_polyphen/formula_config.json"
      provides: "Default SIFT+PolyPhen classification model"
      contains: "coast_category"
    - path: "scoring/coast_classification/cadd/formula_config.json"
      provides: "CADD-threshold classification model"
      contains: "cadd_phred"
    - path: "variantcentrifuge/association/tests/allelic_series.py"
      provides: "_resolve_effect function and formula-engine classification path"
      contains: "_resolve_effect"
    - path: "variantcentrifuge/cli.py"
      provides: "--coast-classification CLI option and auto-field injection"
      contains: "coast-classification"
    - path: "variantcentrifuge/association/base.py"
      provides: "coast_classification field on AssociationConfig"
      contains: "coast_classification"
    - path: "tests/unit/test_coast_classification.py"
      provides: "Tests for effect resolution, formula classification, auto-injection"
  key_links:
    - from: "variantcentrifuge/cli.py"
      to: "scoring/coast_classification/*/variable_assignment_config.json"
      via: "auto-field injection reads required fields from classification config"
      pattern: "coast_classification"
    - from: "variantcentrifuge/association/tests/allelic_series.py"
      to: "variantcentrifuge/scoring.py"
      via: "classify_variants delegates to read_scoring_config + apply_scoring"
      pattern: "read_scoring_config|apply_scoring"
    - from: "variantcentrifuge/cli.py"
      to: "variantcentrifuge/association/base.py"
      via: "coast_classification propagated through cfg to AssociationConfig"
      pattern: "coast_classification"
---

<objective>
Add configurable COAST classification via the scoring formula engine, fix SnpEff "&"-concatenated effect strings, implement auto-field injection, and create the classification config directory structure (COAST-02, COAST-04, COAST-05, COAST-06, COAST-07).

Purpose: Makes COAST classification configurable (SIFT/PolyPhen, CADD, or custom models) instead of hardcoded, handles real-world multi-transcript SnpEff annotations, and ensures required annotation fields are always available.

Output: Three classification configs in scoring/coast_classification/, updated classify_variants with formula engine delegation, _resolve_effect function, --coast-classification CLI option, auto-field injection in cli.py, diagnostics output, unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-coast-fix/31-CONTEXT.md
@.planning/phases/31-coast-fix/31-RESEARCH.md
@.planning/phases/31-coast-fix/31-01-SUMMARY.md
@variantcentrifuge/association/tests/allelic_series.py
@variantcentrifuge/association/tests/allelic_series_python.py
@variantcentrifuge/association/base.py
@variantcentrifuge/cli.py
@variantcentrifuge/scoring.py
@scoring/nephro_candidate_score/variable_assignment_config.json
@scoring/nephro_candidate_score/formula_config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create classification configs, _resolve_effect, and formula-engine classification path (COAST-04, COAST-06, COAST-07)</name>
  <files>
    scoring/coast_classification/sift_polyphen/variable_assignment_config.json
    scoring/coast_classification/sift_polyphen/formula_config.json
    scoring/coast_classification/cadd/variable_assignment_config.json
    scoring/coast_classification/cadd/formula_config.json
    scoring/coast_classification/custom_template/variable_assignment_config.json
    scoring/coast_classification/custom_template/formula_config.json
    variantcentrifuge/association/tests/allelic_series.py
    variantcentrifuge/association/tests/allelic_series_python.py
  </files>
  <action>
  **Step 1: Create scoring/coast_classification/ directory structure with 3 models.**

  **sift_polyphen/variable_assignment_config.json:**
  ```json
  {
    "variables": {
      "ANN[0].EFFECT": "effect|default:''",
      "ANN[0].IMPACT": "impact|default:''",
      "dbNSFP_SIFT_pred": "sift_pred|default:''",
      "dbNSFP_Polyphen2_HDIV_pred": "polyphen_pred|default:''"
    }
  }
  ```

  **sift_polyphen/formula_config.json:**
  Formulas that replicate the current hardcoded classify_variants logic. Output: `coast_category` (0/1/2/3).
  - `is_ptv`: `(impact == 'HIGH') & effect.isin(['stop_gained', 'frameshift_variant', 'splice_acceptor_variant', 'splice_donor_variant'])`
  - `is_missense`: `effect == 'missense_variant'`
  - SIFT deleterious: `sift_pred.str.contains('deleterious|^D$', na=False, regex=True)`
  - PolyPhen damaging: `polyphen_pred.str.contains('probably_damaging|possibly_damaging|^D$|^P$', na=False, regex=True)`
  - SIFT benign: `sift_pred.str.contains('tolerated|^T$', na=False, regex=True)`
  - PolyPhen benign: `polyphen_pred.str.contains('benign|^B$', na=False, regex=True)`
  - `is_dmv`: `is_missense & (sift_dam | polyphen_dam)`
  - `is_bmv`: `is_missense & sift_ben & polyphen_ben`
  - `coast_category`: `is_ptv * 3 + is_dmv * 2 + is_bmv * 1`
  - `output_scores`: `["coast_category"]`

  **cadd/variable_assignment_config.json:**
  ```json
  {
    "variables": {
      "ANN[0].EFFECT": "effect|default:''",
      "ANN[0].IMPACT": "impact|default:''",
      "dbNSFP_CADD_phred": "cadd_phred|default:0.0"
    }
  }
  ```

  **cadd/formula_config.json:**
  - Same PTV logic as sift_polyphen
  - `is_dmv`: `is_missense & (cadd_phred >= 15)`
  - `is_bmv`: `is_missense & (cadd_phred > 0) & (cadd_phred < 15)`
  - `coast_category`: `is_ptv * 3 + is_dmv * 2 + is_bmv * 1`

  **custom_template/:** Both files should be minimal valid JSON with comments-as-keys explaining the format. variable_assignment_config maps VCF fields to variable names. formula_config shows expected structure with `output_scores: ["coast_category"]` and empty formulas list.

  **Step 2: Add `_resolve_effect()` to allelic_series.py (COAST-04, COAST-07).**

  Add before `classify_variants()`:

  ```python
  def _resolve_effect(effect_str: str) -> str:
      """Resolve '&'-concatenated SnpEff effect string to single highest-priority effect.

      Priority: PTV effects > missense_variant > first part.
      This handles multi-transcript annotations like 'stop_gained&splice_region_variant'.
      """
      if "&" not in effect_str:
          return effect_str
      parts = [p.strip() for p in effect_str.split("&")]
      for part in parts:
          if part in PTV_EFFECTS:
              return part
      if MISSENSE_EFFECT in parts:
          return MISSENSE_EFFECT
      return parts[0] if parts else effect_str
  ```

  **Step 3: Update `classify_variants()` to support formula engine delegation.**

  Add optional parameters: `model_dir: str | None = None`, `diagnostics_rows: list | None = None`.

  When `model_dir` is provided:
  1. Pre-resolve effect column: `gene_df[effect_col] = gene_df[effect_col].astype(object).fillna("").astype(str).map(_resolve_effect)` (on a copy)
  2. Pre-cast all string columns referenced in variable_assignment_config to object dtype (avoid Categorical issues)
  3. Call `read_scoring_config(model_dir)` and `apply_scoring(gene_df_copy, scoring_config)`
  4. Read `coast_category` column: `anno_codes = gene_df_copy["coast_category"].fillna(0).astype(int).to_numpy()`
  5. `include_mask = anno_codes > 0`
  6. If `diagnostics_rows` list is provided, append per-variant dicts with: gene, variant_id (CHROM:POS:REF:ALT or index), original_effect, resolved_effect, assigned_category, score_used (model name)

  When `model_dir` is None (backward compat): use existing hardcoded logic BUT still apply `_resolve_effect` to the effect_series. Change line ~172:
  ```python
  effect_series = gene_df[effect_col].astype(object).fillna("").astype(str).map(_resolve_effect)
  ```
  This fixes COAST-04 for the default path too.

  **Step 4: Update PurePythonCOASTTest.run() and COASTTest.run() to pass model_dir.**

  Both `run()` methods call `classify_variants(gene_df, effect_col, impact_col)`. Add `model_dir` parameter:
  - Read `coast_classification` from config: `model_name = getattr(config, "coast_classification", "sift_polyphen")`
  - Resolve path: Look for `scoring/coast_classification/{model_name}/` relative to the package data directory (use the same path resolution as existing scoring configs -- check how `scoring_config_path` is resolved in pipeline.py/cli.py)
  - Pass `model_dir=resolved_path` to `classify_variants()`
  - For diagnostics: if `getattr(config, "diagnostics_output", None)`, create a diagnostics_rows list and pass it. After all genes, write `coast_classification.tsv` in finalize().

  **Important:** The model_dir path resolution must work both in development (repo root `scoring/`) and in installed packages. Check how existing scoring configs resolve their paths. If `--scoring-config-path` is always user-provided, COAST classification may need similar treatment OR use `importlib.resources` / `__file__`-relative resolution. Follow the existing pattern.
  </action>
  <verify>
  Run: `python -c "from variantcentrifuge.scoring import read_scoring_config; c = read_scoring_config('scoring/coast_classification/sift_polyphen'); print(c)"` to verify configs parse correctly.
  Run: `python -c "from variantcentrifuge.association.tests.allelic_series import _resolve_effect; assert _resolve_effect('stop_gained&splice_region_variant') == 'stop_gained'; print('OK')"` to verify effect resolution.
  Run: `make lint` passes.
  </verify>
  <done>
  - Three classification configs exist in scoring/coast_classification/ and parse without error
  - _resolve_effect correctly resolves "&"-concatenated strings (PTV > missense > first)
  - classify_variants accepts model_dir and delegates to formula engine when provided
  - classify_variants applies _resolve_effect even in default (no model_dir) path
  - Both COAST test classes pass model_dir from config.coast_classification
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI option, auto-field injection, AssociationConfig, and tests (COAST-02, COAST-05)</name>
  <files>
    variantcentrifuge/cli.py
    variantcentrifuge/association/base.py
    tests/unit/test_coast_classification.py
  </files>
  <action>
  **Step 1: Add --coast-classification CLI option (COAST-05).**

  In cli.py, add `--coast-classification` argument following the `--coast-backend` pattern (~line 430 area):

  ```python
  parser.add_argument(
      "--coast-classification",
      type=str,
      default="sift_polyphen",
      help="COAST classification model for BMV/DMV/PTV assignment. "
           "Built-in models: 'sift_polyphen' (default), 'cadd'. "
           "Custom models: provide directory name under scoring/coast_classification/."
  )
  ```

  In the cfg construction section (~line 1194 area), add:
  ```python
  cfg["coast_classification"] = getattr(args, "coast_classification", "sift_polyphen")
  ```

  **Step 2: Add coast_classification to AssociationConfig (COAST-05).**

  In base.py, add field to AssociationConfig dataclass:
  ```python
  coast_classification: str = "sift_polyphen"
  ```

  Verify that the config propagation path (`cfg["coast_classification"]` -> `AssociationConfig`) works. Check how other coast_* fields are propagated in engine.py or analysis_stages.py and follow the same pattern.

  **Step 3: Auto-field injection in cli.py (COAST-02).**

  In cli.py `main()`, AFTER `fields` is resolved (~line 1128: `fields = args.fields or cfg.get("fields_to_extract")`) but BEFORE `cfg["fields_to_extract"] = fields` (~line 1312), add COAST field injection:

  ```python
  # Auto-inject COAST classification fields
  if args.association_tests and "coast" in args.association_tests:
      import json
      import os
      coast_model = getattr(args, "coast_classification", "sift_polyphen")
      # Resolve scoring dir -- use same base as existing scoring configs
      # Check for scoring/ relative to package or CWD
      _scoring_base = os.path.join(os.path.dirname(os.path.dirname(__file__)), "scoring")
      if not os.path.isdir(_scoring_base):
          _scoring_base = os.path.join(os.getcwd(), "scoring")
      coast_model_dir = os.path.join(_scoring_base, "coast_classification", coast_model)
      if not os.path.isdir(coast_model_dir):
          parser.error(f"COAST classification model not found: {coast_model_dir}")

      var_config_path = os.path.join(coast_model_dir, "variable_assignment_config.json")
      with open(var_config_path) as f:
          var_config = json.load(f)
      required_fields = list(var_config.get("variables", {}).keys())

      # Inject missing fields into extraction list
      if fields:
          field_list = [f.strip() for f in fields.split(",")]
          injected = []
          for rf in required_fields:
              if rf not in field_list:
                  field_list.append(rf)
                  injected.append(rf)
          if injected:
              logger.info(f"COAST auto-injected fields for '{coast_model}' model: {injected}")
          fields = ",".join(field_list)
      else:
          fields = ",".join(required_fields)
          logger.info(f"COAST set extraction fields for '{coast_model}' model: {required_fields}")
  ```

  **Important: VCF header validation.** After field injection, if the VCF file is available, check that required fields exist in the VCF header. Use any existing VCF header parsing utility (search for `parse_vcf_header` or `bcftools query -l`). If required annotation fields are absent from VCF, `sys.exit()` with a clear message: "COAST classification model '{model}' requires field '{field}' which is not annotated in the VCF. Add annotations or use --coast-classification sift_polyphen".

  If no VCF header checking utility exists, skip this validation for now and add a TODO comment -- the pipeline will still fail at SnpSift extraction with a less clear error. The CONTEXT.md decision says "fail early" but the exact mechanism is at Claude's discretion.

  **Step 4: Create tests/unit/test_coast_classification.py.**

  Tests:
  1. `test_resolve_effect_simple` — Single effect string returned unchanged
  2. `test_resolve_effect_ptv_priority` — `"stop_gained&splice_region_variant"` -> `"stop_gained"`
  3. `test_resolve_effect_missense_priority` — `"missense_variant&splice_region_variant"` -> `"missense_variant"`
  4. `test_resolve_effect_no_match` — `"intron_variant&synonymous_variant"` -> `"intron_variant"` (first part)
  5. `test_classify_variants_with_resolve_effect` — DataFrame with "&"-concatenated effects, verify PTV correctly classified
  6. `test_classify_variants_sift_polyphen_config` — Call classify_variants with model_dir pointing to sift_polyphen config, verify category codes match hardcoded logic on a known DataFrame
  7. `test_classify_variants_cadd_config` — Call with CADD model, verify CADD>15 missense -> DMV, CADD<15 missense -> BMV
  8. `test_coast_classification_cli_option_default` — Parse args with no --coast-classification, verify default is "sift_polyphen"
  9. `test_auto_field_injection` — Mock a fields string missing SIFT columns, simulate the injection logic, verify fields are appended

  Mark all with `@pytest.mark.unit`.
  </action>
  <verify>
  Run: `python -m pytest tests/unit/test_coast_classification.py -v` — all tests pass
  Run: `make ci-check` — full CI passes
  </verify>
  <done>
  - --coast-classification CLI option exists with default "sift_polyphen"
  - AssociationConfig has coast_classification field
  - Auto-field injection adds required fields when COAST is selected
  - _resolve_effect handles all "&"-concatenated patterns correctly
  - classify_variants delegates to formula engine when model_dir provided
  - 9+ unit tests cover effect resolution, classification configs, CLI option, and field injection
  - COAST-02, COAST-04, COAST-05, COAST-06, COAST-07 all satisfied
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/unit/test_coast_classification.py -v` — all classification tests pass
2. `python -m pytest tests/ -k "coast" -v` — all COAST tests pass (including Plan 01 tests)
3. `make ci-check` — lint, format, typecheck, test-fast all pass
4. Verify scoring configs parse: `python -c "from variantcentrifuge.scoring import read_scoring_config; print(read_scoring_config('scoring/coast_classification/sift_polyphen'))"`
5. Verify _resolve_effect: `python -c "from variantcentrifuge.association.tests.allelic_series import _resolve_effect; assert _resolve_effect('stop_gained&splice_region_variant') == 'stop_gained'"`
</verification>

<success_criteria>
- COAST-02 satisfied: auto-field injection adds SIFT/PolyPhen (or CADD) fields to extraction
- COAST-04 satisfied: "&"-concatenated SnpEff effects resolved via _resolve_effect before classification
- COAST-05 satisfied: --coast-classification CLI option selects model by name
- COAST-06 satisfied: scoring/coast_classification/ has sift_polyphen, cadd, and custom_template configs
- COAST-07 satisfied: _resolve_effect implements priority-order resolution (PTV > missense > other)
- Default sift_polyphen model produces identical classification to prior hardcoded logic
- All tests pass, CI green
</success_criteria>

<output>
After completion, create `.planning/phases/31-coast-fix/31-02-SUMMARY.md`
</output>
