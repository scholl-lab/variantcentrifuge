---
phase: 25-python-default-backends-and-quick-wins
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - variantcentrifuge/association/tests/acat.py
  - variantcentrifuge/association/tests/skat_python.py
  - variantcentrifuge/association/engine.py
  - tests/unit/test_acat_v.py
autonomous: true

must_haves:
  truths:
    - "ACAT-V per-variant score test p-value is computed for each gene with SKAT results"
    - "ACAT-V p-value feeds into ACAT-O omnibus combination"
    - "ACAT-V column appears in association output TSV"
    - "Genes with no valid per-variant p-values get acat_v_p=None"
  artifacts:
    - path: "variantcentrifuge/association/tests/acat.py"
      provides: "compute_acat_v() function"
      contains: "def compute_acat_v"
    - path: "variantcentrifuge/association/tests/skat_python.py"
      provides: "ACAT-V computation in PurePythonSKATTest.run()"
      contains: "acat_v_p"
    - path: "variantcentrifuge/association/engine.py"
      provides: "ACAT-V included in ACAT-O combination"
      contains: "acat_v_p"
    - path: "tests/unit/test_acat_v.py"
      provides: "ACAT-V unit tests"
      contains: "compute_acat_v"
  key_links:
    - from: "variantcentrifuge/association/tests/skat_python.py"
      to: "variantcentrifuge/association/tests/acat.py"
      via: "PurePythonSKATTest.run() calls compute_acat_v()"
      pattern: "compute_acat_v"
    - from: "variantcentrifuge/association/engine.py"
      to: "variantcentrifuge/association/tests/skat_python.py"
      via: "_compute_acat_o reads acat_v_p from SKAT result.extra"
      pattern: "acat_v_p"
---

<objective>
Implement ACAT-V (per-variant score test combined via Cauchy) as a component of the
ACAT-O omnibus, providing power for sparse-signal detection where SKAT and burden
both lose power.

Purpose: ACAT-V is recommended by STAARpipeline and Liu (2019) as a standard
component of ACAT-O. It detects signals when only a small fraction of variants are
causal. Computationally trivial: O(M) per gene.

Output: compute_acat_v() in acat.py, wiring in skat_python.py and engine.py,
unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/ASSOCIATION_REMAINING_WORK.md
@.planning/phases/25-python-default-backends-and-quick-wins/25-RESEARCH.md

@variantcentrifuge/association/tests/acat.py
@variantcentrifuge/association/tests/skat_python.py
@variantcentrifuge/association/engine.py
@variantcentrifuge/association/backends/python_backend.py
@variantcentrifuge/association/weights.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement compute_acat_v() and wire into SKAT + ACAT-O</name>
  <files>
    variantcentrifuge/association/tests/acat.py
    variantcentrifuge/association/tests/skat_python.py
    variantcentrifuge/association/engine.py
  </files>
  <action>
    **1. acat.py — Add compute_acat_v() function:**

    Add a new function `compute_acat_v()` after `cauchy_combination()` and before
    `compute_acat_o()`.

    Type signature — NOTE the correct Optional type for mu_hat:
    ```python
    def compute_acat_v(
        geno: np.ndarray,
        residuals: np.ndarray,
        trait_type: str,
        sigma2: float,
        mu_hat: np.ndarray | None,
        weights: np.ndarray,
    ) -> float | None:
    ```

    IMPORTANT: `mu_hat` is declared as `np.ndarray | None` because it is required only
    for binary traits. The guard `if trait_type == "binary" and mu_hat is not None:`
    must protect ALL uses of `mu_hat` inside the function. Do NOT declare it as
    `np.ndarray` (non-Optional) — that would make the type incorrect and callers that
    pass None for quantitative traits would have a type error.

    Full implementation using a SINGLE-PASS loop (use this implementation, not the
    double-loop variant):

    ```python
    def compute_acat_v(
        geno: np.ndarray,
        residuals: np.ndarray,
        trait_type: str,
        sigma2: float,
        mu_hat: np.ndarray | None,
        weights: np.ndarray,
    ) -> float | None:
        """
        ACAT-V per-variant score test (Liu & Xie 2020, STAARpipeline).

        Computes marginal score test p-values for each variant and combines
        them via Cauchy combination with Beta(MAF) weights. Powerful when
        only a small fraction of variants are causal.

        Parameters
        ----------
        geno : np.ndarray, shape (n_samples, n_variants)
            Genotype dosage matrix (0/1/2). No NaN.
        residuals : np.ndarray, shape (n_samples,)
            Null model residuals (y - mu_hat).
        trait_type : str
            "binary" or "quantitative".
        sigma2 : float
            Variance estimate from null model.
        mu_hat : np.ndarray | None, shape (n_samples,)
            Fitted values from null model. Required for binary traits;
            may be None for quantitative traits (sigma2 is used instead).
        weights : np.ndarray, shape (n_variants,)
            Per-variant weights (typically Beta(MAF; 1, 25)).

        Returns
        -------
        float | None
            Combined ACAT-V p-value, or None if no valid per-variant p-values.
        """
        n_samples, n_variants = geno.shape
        if n_variants == 0:
            return None

        # Per-variant score statistics: S_j = G_j' @ residuals
        score_vec = geno.T @ residuals  # shape: (n_variants,)

        # Per-variant variance: V_j = G_j' @ V @ G_j
        # Binary: V = diag(mu*(1-mu)), so V_j = sum(G_j^2 * mu*(1-mu))
        # Quantitative: V = sigma2 * I, so V_j = sigma2 * sum(G_j^2)
        if trait_type == "binary" and mu_hat is not None:
            var_weights = mu_hat * (1.0 - mu_hat)  # (n_samples,)
            var_vec = np.sum(geno ** 2 * var_weights[:, np.newaxis], axis=0)  # (n_variants,)
        else:
            var_vec = sigma2 * np.sum(geno ** 2, axis=0)  # (n_variants,)

        # Single-pass: compute per-variant z-statistics, p-values, and collect
        # valid (p, weight) pairs in one loop
        valid_p: list[float] = []
        valid_w: list[float] = []
        for j in range(n_variants):
            if var_vec[j] <= 0.0:
                continue  # skip zero-variance variants (monomorphic)
            z_j = score_vec[j] / np.sqrt(var_vec[j])
            p_j = 2.0 * float(norm.sf(abs(z_j)))
            if 0.0 < p_j < 1.0:
                valid_p.append(p_j)
                valid_w.append(float(weights[j]))

        if not valid_p:
            return None

        return cauchy_combination(valid_p, valid_w)
    ```

    IMPORTANT: Add `from scipy.stats import norm` to the imports at the top of acat.py
    (alongside the existing `from scipy.stats import cauchy`).

    **2. skat_python.py — Compute ACAT-V in PurePythonSKATTest.run():**

    After the backend returns the SKAT result (line ~265-271), compute ACAT-V and
    store in extra. The genotype matrix, residuals, sigma2, mu_hat, and weights are
    all available at this point.

    Add after `result = self._backend.test_gene(...)` (around line 271):

    ```python
    # Compute ACAT-V per-variant score test (Phase 25)
    from variantcentrifuge.association.tests.acat import compute_acat_v
    from variantcentrifuge.association.weights import beta_maf_weights

    mafs = geno.mean(axis=0) / 2.0
    a1, a2 = weights_beta
    acat_v_weights = beta_maf_weights(mafs, a=a1, b=a2)

    acat_v_p = compute_acat_v(
        geno=geno,
        residuals=self._null_model.extra["residuals"],
        trait_type=config.trait_type,
        sigma2=self._null_model.extra["sigma2"],
        mu_hat=self._null_model.extra.get("mu_hat"),  # None for quantitative
        weights=acat_v_weights,
    )
    ```

    Then add `"acat_v_p": acat_v_p` to the `extra` dict (around line 289-298).

    Move the imports to the top of the file (not inline) since acat.py and weights.py
    are already internal modules with no heavy dependencies.

    **3. engine.py — Include ACAT-V in ACAT-O combination:**

    In `_compute_acat_o()`, the per-test p-values are collected in a loop, then
    `compute_acat_o()` is called on the collected dict. The ACAT-V block must be
    inserted in a SPECIFIC location: AFTER the test_pvals collection loop completes
    and BEFORE the `acat_p = compute_acat_o(test_pvals)` call.

    Concretely, locate the two anchor points:
    - Anchor A (end of collection loop): the line that sets
      `test_pvals[test_name] = res.p_value if res is not None else None`
      (approximately line 235). This is the LAST line of the for-loop body.
    - Anchor B (omnibus call): the line `acat_p = compute_acat_o(test_pvals)`
      (approximately line 238). This is where ACAT-O is computed.

    Insert the ACAT-V block BETWEEN these two anchors (after Anchor A, before Anchor B):

    ```python
    # Collect p-values from all primary tests for this gene
    test_pvals: dict[str, float | None] = {}
    for test_name in self._tests:
        res = results_by_test[test_name].get(gene)
        test_pvals[test_name] = res.p_value if res is not None else None
    # <-- INSERT HERE: after collection loop, before compute_acat_o() call -->

    # Include ACAT-V if available from SKAT test (Phase 25)
    # ACAT-V is NOT a primary test — it's a per-variant score test stored
    # in the SKAT result's extra dict. Adding it to the ACAT-O omnibus
    # improves power for sparse signals.
    for test_name in self._tests:
        res = results_by_test[test_name].get(gene)
        if res is not None and "acat_v_p" in res.extra:
            acat_v_p = res.extra["acat_v_p"]
            if acat_v_p is not None:
                test_pvals["acat_v"] = acat_v_p
            break  # only one SKAT test can produce ACAT-V

    acat_p = compute_acat_o(test_pvals)  # <-- Anchor B: this line must come AFTER
    ```

    If the ACAT-V block is inserted after `compute_acat_o()` is called, the ACAT-V
    p-value will be silently dropped from the omnibus result. Verify placement by
    checking that `test_pvals` dict is fully populated (including "acat_v" key when
    present) before the `compute_acat_o(test_pvals)` call.

    Also add `"acat_v_p"` to the extra columns written in `run_all()` — but this is
    already handled because extra dict keys are written automatically at line 411.
    The ACAT-V p-value will appear as the `acat_v_p` column in the output.
  </action>
  <verify>
    Run `make lint && make format` to ensure no lint errors.
    Run `python -c "from variantcentrifuge.association.tests.acat import compute_acat_v; print('OK')"` to verify import works.
    Run `pytest tests/ -k "acat" -v --no-header` to check existing ACAT tests still pass.
  </verify>
  <done>
    compute_acat_v() exists in acat.py with mu_hat: np.ndarray | None signature and
    single-pass loop implementation.
    PurePythonSKATTest.run() computes ACAT-V and stores in extra["acat_v_p"].
    _compute_acat_o() includes ACAT-V in the omnibus combination (inserted AFTER
    test_pvals collection loop, BEFORE compute_acat_o() call).
    acat_v_p column appears in output for genes tested with SKAT.
  </done>
</task>

<task type="auto">
  <name>Task 2: ACAT-V unit tests</name>
  <files>
    tests/unit/test_acat_v.py
  </files>
  <action>
    Create comprehensive unit tests for ACAT-V:

    ```python
    """Tests for ACAT-V per-variant score test (Phase 25)."""
    import numpy as np
    import pytest
    from scipy.stats import norm

    from variantcentrifuge.association.tests.acat import compute_acat_v, cauchy_combination


    @pytest.mark.unit
    class TestComputeAcatV:
        """Tests for compute_acat_v()."""

        def test_basic_binary(self):
            """ACAT-V produces valid p-value for binary trait."""
            rng = np.random.default_rng(42)
            n, m = 100, 5
            geno = rng.choice([0, 1, 2], size=(n, m), p=[0.8, 0.15, 0.05])
            mu_hat = np.full(n, 0.3)  # balanced binary trait
            residuals = rng.binomial(1, 0.3, n).astype(float) - mu_hat
            sigma2 = 1.0
            weights = np.ones(m)

            p = compute_acat_v(geno, residuals, "binary", sigma2, mu_hat, weights)
            assert p is not None
            assert 0.0 < p <= 1.0

        def test_basic_quantitative(self):
            """ACAT-V produces valid p-value for quantitative trait."""
            rng = np.random.default_rng(123)
            n, m = 200, 10
            geno = rng.choice([0, 1, 2], size=(n, m), p=[0.85, 0.12, 0.03])
            mu_hat = np.full(n, 5.0)
            residuals = rng.normal(0, 1, n)
            sigma2 = float(np.var(residuals, ddof=1))
            weights = np.ones(m)

            p = compute_acat_v(geno, residuals, "quantitative", sigma2, mu_hat, weights)
            assert p is not None
            assert 0.0 < p <= 1.0

        def test_quantitative_mu_hat_none(self):
            """ACAT-V accepts mu_hat=None for quantitative traits."""
            rng = np.random.default_rng(77)
            n, m = 100, 4
            geno = rng.choice([0, 1, 2], size=(n, m), p=[0.85, 0.12, 0.03])
            residuals = rng.normal(0, 1, n)
            sigma2 = 1.0
            weights = np.ones(m)

            # mu_hat=None should work for quantitative (sigma2 path)
            p = compute_acat_v(geno, residuals, "quantitative", sigma2, None, weights)
            assert p is not None
            assert 0.0 < p <= 1.0

        def test_empty_genotype(self):
            """Zero variants returns None."""
            geno = np.empty((100, 0))
            residuals = np.zeros(100)
            mu_hat = np.full(100, 0.5)
            p = compute_acat_v(geno, residuals, "binary", 1.0, mu_hat, np.array([]))
            assert p is None

        def test_monomorphic_variants_skipped(self):
            """All-zero genotype columns (monomorphic) are skipped."""
            n = 50
            geno = np.zeros((n, 3))  # all monomorphic
            residuals = np.random.default_rng(1).normal(0, 1, n)
            mu_hat = np.full(n, 0.5)
            weights = np.ones(3)

            p = compute_acat_v(geno, residuals, "binary", 1.0, mu_hat, weights)
            assert p is None  # no valid per-variant p-values

        def test_single_variant(self):
            """Single variant: ACAT-V returns per-variant p-value directly."""
            rng = np.random.default_rng(99)
            n = 100
            geno = rng.choice([0, 1], size=(n, 1), p=[0.9, 0.1]).astype(float)
            mu_hat = np.full(n, 0.3)
            residuals = rng.binomial(1, 0.3, n).astype(float) - mu_hat
            weights = np.ones(1)

            p = compute_acat_v(geno, residuals, "binary", 1.0, mu_hat, weights)
            # Single valid p-value: cauchy_combination returns pass-through
            assert p is not None
            assert 0.0 < p <= 1.0

        def test_significant_signal_detected(self):
            """ACAT-V detects a strong per-variant signal."""
            rng = np.random.default_rng(7)
            n = 500
            # Create one causal variant with strong effect
            geno = np.zeros((n, 5))
            geno[:, 0] = rng.binomial(1, 0.1, n)  # causal
            for j in range(1, 5):
                geno[:, j] = rng.binomial(1, 0.05, n)  # noise

            # Phenotype depends on first variant
            mu_hat = np.full(n, 0.3)
            phenotype = (geno[:, 0] * 3.0 + rng.normal(0, 1, n)) > 1.5
            residuals = phenotype.astype(float) - mu_hat
            weights = np.ones(5)

            p = compute_acat_v(geno, residuals, "binary", 1.0, mu_hat, weights)
            assert p is not None
            # With strong causal variant, p should be small
            assert p < 0.05

        def test_weights_affect_result(self):
            """Different weights produce different ACAT-V p-values."""
            rng = np.random.default_rng(55)
            n, m = 200, 5
            geno = rng.choice([0, 1, 2], size=(n, m), p=[0.85, 0.12, 0.03])
            mu_hat = np.full(n, 0.5)
            residuals = rng.normal(0, 1, n)
            sigma2 = 1.0

            p_uniform = compute_acat_v(geno, residuals, "quantitative", sigma2, mu_hat, np.ones(m))
            p_weighted = compute_acat_v(
                geno, residuals, "quantitative", sigma2, mu_hat,
                np.array([10.0, 1.0, 1.0, 1.0, 1.0])
            )
            # Both should be valid
            assert p_uniform is not None
            assert p_weighted is not None
            # Different weights should give different results (not guaranteed but very likely)
            # We don't assert inequality since it's theoretically possible they match

        def test_acat_v_in_acat_o(self):
            """ACAT-V p-value included in ACAT-O when present in extra."""
            from variantcentrifuge.association.tests.acat import compute_acat_o

            # Simulate: SKAT p=0.05, burden p=0.10, acat_v p=0.001
            # ACAT-O with ACAT-V should be more significant than without
            pvals_without = {"skat": 0.05, "burden": 0.10}
            pvals_with = {"skat": 0.05, "burden": 0.10, "acat_v": 0.001}

            p_without = compute_acat_o(pvals_without)
            p_with = compute_acat_o(pvals_with)

            assert p_without is not None
            assert p_with is not None
            # Adding a very significant ACAT-V should make omnibus more significant
            assert p_with < p_without

        def test_pure_python_skat_stores_acat_v_in_extra(self):
            """End-to-end: PurePythonSKATTest.run() -> extra['acat_v_p'] is set."""
            import numpy as np
            from variantcentrifuge.association.tests.skat_python import PurePythonSKATTest
            from variantcentrifuge.association.base import AssociationConfig

            rng = np.random.default_rng(42)
            n_samples, n_variants = 80, 6

            # Synthetic data: binary trait
            geno = rng.choice([0, 1, 2], size=(n_samples, n_variants),
                              p=[0.8, 0.15, 0.05]).astype(float)
            phenotype = rng.binomial(1, 0.3, n_samples).astype(float)
            covariates = np.ones((n_samples, 1))  # intercept only

            config = AssociationConfig(trait_type="binary")

            test = PurePythonSKATTest()
            test.fit_null(phenotype, covariates, config)
            result = test.run(geno, config)

            # ACAT-V p-value must be stored in extra
            assert "acat_v_p" in result.extra, (
                "PurePythonSKATTest.run() must store 'acat_v_p' in result.extra"
            )
            # Value is either a float in (0, 1] or None (if all variants monomorphic)
            acat_v_p = result.extra["acat_v_p"]
            if acat_v_p is not None:
                assert 0.0 < acat_v_p <= 1.0, f"acat_v_p={acat_v_p} out of range"
    ```

    Mark all tests with `@pytest.mark.unit`.

    Run `make ci-check` after creating the test file.
  </action>
  <verify>
    `pytest tests/unit/test_acat_v.py -v` — all tests pass, including
    `test_pure_python_skat_stores_acat_v_in_extra`.
    `make ci-check` — full CI passes.
  </verify>
  <done>
    test_acat_v.py covers: binary/quantitative traits, mu_hat=None for quantitative,
    edge cases (empty, monomorphic, single variant), signal detection, weight effects,
    ACAT-O integration, and end-to-end wiring from PurePythonSKATTest.run() to
    extra["acat_v_p"].
    All tests pass. Full CI clean.
  </done>
</task>

</tasks>

<verification>
1. `make ci-check` passes with no errors.
2. `python -c "from variantcentrifuge.association.tests.acat import compute_acat_v; print('OK')"` succeeds.
3. `pytest tests/unit/test_acat_v.py -v` — all ACAT-V tests pass.
4. `pytest tests/ -k "acat" -v` — all ACAT tests (existing + new) pass.
5. ACAT-V p-value appears in SKAT result extra and feeds into ACAT-O.
</verification>

<success_criteria>
- compute_acat_v() computes per-variant score test p-values combined via Cauchy,
  with mu_hat: np.ndarray | None and single-pass loop implementation.
- PurePythonSKATTest.run() stores acat_v_p in TestResult.extra.
- ACAT-O omnibus includes ACAT-V when available (inserted before compute_acat_o() call).
- acat_v_p column appears in association output.
- All unit tests pass including new ACAT-V tests and end-to-end wiring test.
</success_criteria>

<output>
After completion, create `.planning/phases/25-python-default-backends-and-quick-wins/25-02-SUMMARY.md`
</output>
