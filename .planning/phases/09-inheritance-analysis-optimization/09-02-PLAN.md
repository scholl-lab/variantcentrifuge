---
phase: 09-inheritance-analysis-optimization
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - variantcentrifuge/inheritance/vectorized_deducer.py
  - variantcentrifuge/inheritance/analyzer.py
autonomous: true

must_haves:
  truths:
    - "Pass 1 pattern deduction runs on entire DataFrame at once using NumPy boolean masks, not per-row"
    - "All inheritance patterns (de novo, AD, AR, X-linked recessive/dominant, mitochondrial, single-sample) are correctly deduced by vectorized code"
    - "Golden file comparison passes after vectorization (clinically equivalent output)"
    - "Edge cases (missing genotypes, no pedigree, single sample) produce identical results"
  artifacts:
    - path: "variantcentrifuge/inheritance/vectorized_deducer.py"
      provides: "Vectorized Pass 1 pattern deduction using NumPy boolean masks"
      min_lines: 200
      contains: "np.select"
    - path: "variantcentrifuge/inheritance/analyzer.py"
      provides: "Updated orchestrator calling vectorized_deduce_patterns instead of df.apply"
      contains: "vectorized_deduce_patterns"
  key_links:
    - from: "variantcentrifuge/inheritance/analyzer.py"
      to: "variantcentrifuge/inheritance/vectorized_deducer.py"
      via: "import and call vectorized_deduce_patterns"
      pattern: "from .vectorized_deducer import vectorized_deduce_patterns"
    - from: "variantcentrifuge/inheritance/vectorized_deducer.py"
      to: "variantcentrifuge/inheritance/comp_het_vectorized.py"
      via: "reuses GENOTYPE_ENCODING and encode_genotypes"
      pattern: "from .comp_het_vectorized import"
---

<objective>
Vectorize Pass 1: Replace df.apply(deduce_patterns_for_variant) with NumPy boolean mask operations.

Purpose: Pass 1 is the primary bottleneck (df.apply calls Python interpreter per-row). Vectorizing it with NumPy boolean masks should achieve 10-100x speedup. This is the highest-impact change in the entire phase.

Output: New vectorized_deducer.py module with vectorized pattern deduction, analyzer.py updated to use it.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-inheritance-analysis-optimization/09-CONTEXT.md
@.planning/phases/09-inheritance-analysis-optimization/09-RESEARCH.md
@.planning/phases/09-inheritance-analysis-optimization/09-01-SUMMARY.md
@variantcentrifuge/inheritance/analyzer.py
@variantcentrifuge/inheritance/deducer.py
@variantcentrifuge/inheritance/comp_het_vectorized.py
@variantcentrifuge/genotype_utils.py
@variantcentrifuge/ped_reader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vectorized_deducer.py with NumPy boolean mask pattern deduction</name>
  <files>variantcentrifuge/inheritance/vectorized_deducer.py</files>
  <action>
Create `variantcentrifuge/inheritance/vectorized_deducer.py` implementing vectorized Pass 1.

**Architecture:**

```python
def vectorized_deduce_patterns(df, pedigree_data, sample_list) -> list[list[str]]:
    """
    Vectorized inheritance pattern deduction for ALL variants at once.
    Returns list of pattern lists (one per variant), matching the output
    format of the original deduce_patterns_for_variant.
    """
```

**Implementation steps (follow this order):**

1. **Genotype matrix encoding** (reuse from comp_het_vectorized.py):
   - Import `encode_genotypes` and `GENOTYPE_ENCODING` from comp_het_vectorized.py
   - Build a (n_variants x n_samples) int8 matrix: `gt_matrix[:, sample_idx]`
   - Encode ALL sample columns at once before any pattern checks
   - Handle samples not in DataFrame columns (fill with -1 for missing)

2. **Initialize result structure:**
   - `n_variants = len(df)`
   - `patterns_per_variant: list[list[str]] = [[] for _ in range(n_variants)]`
   - This matches the return type of the original (list of pattern lists)

3. **Handle single sample / no pedigree (matches deduce_single_sample_patterns):**
   - If `not pedigree_data or len(sample_list) == 1`:
     - For each sample, create masks: missing_mask (gt == -1), ref_mask (gt == 0), hom_alt_mask (gt == 2), het_mask (gt == 1)
     - Apply: ref -> "reference", hom_alt -> "homozygous", het -> "unknown"
     - For variants with no pattern from any sample, append "unknown"
     - Return early

4. **Per-sample vectorized pattern deduction (matches deduce_patterns_for_sample):**
   - For each sample_id in sample_list:
     - Skip if sample_id not in pedigree_data
     - Get sample genotype column: `sample_gts = gt_matrix[:, sample_idx]`
     - Create `has_variant_mask = sample_gts > 0` (het or hom_alt)
     - Get parent IDs from pedigree: `father_id, mother_id = get_parents(sample_id, pedigree_data)`
     - Get affected status: `affected = is_affected(sample_id, pedigree_data)`

   **a. De novo check (vectorized):**
   - If both parents in sample_list:
     - `father_gts = gt_matrix[:, father_idx]`
     - `mother_gts = gt_matrix[:, mother_idx]`
     - `de_novo_mask = has_variant_mask & (father_gts == 0) & (mother_gts == 0)`
     - For indices in np.where(de_novo_mask)[0]: append "de_novo"
   - If one parent has missing GT (-1) and sample has variant and sample is affected:
     - `de_novo_candidate_mask = has_variant_mask & affected & ((father_gts == -1) | (mother_gts == -1))`
     - Note: only when both parents are in sample_list but have missing GTs
     - For indices: append "de_novo_candidate"

   **b. Dominant check (vectorized, matches check_dominant_pattern):**
   - Only for affected samples
   - `father_has_variant = father_gts > 0` (where father exists)
   - `mother_has_variant = mother_gts > 0` (where mother exists)
   - Check if parent is affected: scalar lookup from pedigree_data
   - Classic AD: `(father_has_variant & father_affected) | (mother_has_variant & mother_affected)` -> "autosomal_dominant"
   - Parent has variant but not affected: `(father_has_variant & ~father_affected) | (mother_has_variant & ~mother_affected)` -> "autosomal_dominant_possible"
   - If parent data incomplete (missing GTs): -> "autosomal_dominant_possible"
   - Apply only where has_variant_mask is True

   **c. Recessive check (vectorized, matches check_recessive_pattern):**
   - Only for affected samples with hom_alt genotype
   - `hom_alt_mask = sample_gts == 2`
   - Both parents carriers: `(father_gts > 0) & (mother_gts > 0)` -> "autosomal_recessive"
   - Incomplete parent data consistent with recessive: -> "autosomal_recessive_possible"
   - Apply only where `hom_alt_mask & affected`

   **d. X-linked check (vectorized, matches check_x_linked_patterns):**
   - Get chromosome array: `chrom_array = df['CHROM'].values` (handle categorical with .astype(str) if needed)
   - `x_mask = np.isin(chrom_array, ['X', 'CHRX', '23', 'x', 'chrX', 'chrx'])`
   - Get sex from pedigree_data[sample_id]
   - For males (sex=="1"): check x_linked_recessive logic (affected + has variant + mother carrier)
   - For females (sex=="2"): check x_linked_recessive (affected + hom_alt + both parents have variant) and x_linked_dominant
   - Apply XLR/XLD/possible patterns only where x_mask is True
   - IMPORTANT: Replicate the full logic from check_x_linked_recessive and check_x_linked_dominant including father-can't-pass-X-to-son check

   **e. Mitochondrial check (vectorized, matches check_mitochondrial_pattern):**
   - `mt_mask = np.isin(chrom_array, ['MT', 'M', 'CHRM', 'CHRMT', 'mt', 'chrM', 'chrMT'])`
   - If mother in sample_list and mother GT not missing: maternal variant -> True
   - If no mother data: default True (matches original)
   - Apply only where mt_mask & has_variant_mask

   **f. Fallback (matches original behavior):**
   - For variants where sample has variant but no patterns were added:
     - If affected: append "unknown"
     - If not affected: append "carrier"

5. **Deduplication per variant:**
   - For each variant's pattern list, remove duplicates while preserving order (matches original)

**Critical correctness rules:**
- Use bitwise operators (&, |, ~) on NumPy arrays, NEVER logical (and, or, not)
- Use .isin() for categorical-safe chromosome comparison, not ==
- Handle -1 (missing) genotypes: never treat them as ref (0) or variant (>0)
- When checking "parent_data_complete", a parent GT of -1 means incomplete
- Patterns are accumulated per-sample per-variant (a variant can get "de_novo" from one sample and "carrier" from another)
- Encode genotypes ONCE before all pattern checks (not per sample)

**Readability requirements (per 09-CONTEXT.md):**
- Clear variable names: `de_novo_mask` not `m1`, `father_gts` not `fg`
- Comments explaining each genetic logic block
- Step-by-step operations, not single dense expressions
- Docstrings on all functions
  </action>
  <verify>
    Run: `python -c "from variantcentrifuge.inheritance.vectorized_deducer import vectorized_deduce_patterns; print('Import OK')"` -- imports without error
    Run: `make lint` -- no linting errors
    Run: `make typecheck` -- no new type errors
  </verify>
  <done>vectorized_deducer.py exists with vectorized pattern deduction covering all inheritance patterns, imports cleanly, passes lint</done>
</task>

<task type="auto">
  <name>Task 2: Wire vectorized Pass 1 into analyzer.py and validate with golden files</name>
  <files>variantcentrifuge/inheritance/analyzer.py</files>
  <action>
Update `variantcentrifuge/inheritance/analyzer.py` to use the vectorized deducer:

1. Add import at top:
   ```python
   from .vectorized_deducer import vectorized_deduce_patterns
   ```

2. Replace Pass 1 in `analyze_inheritance()` (lines 84-88):
   **Before:**
   ```python
   df["_inheritance_patterns"] = df.apply(
       lambda row: deduce_patterns_for_variant(row.to_dict(), pedigree_data, sample_list), axis=1
   )
   ```
   **After:**
   ```python
   df["_inheritance_patterns"] = vectorized_deduce_patterns(df, pedigree_data, sample_list)
   ```
   Note: vectorized_deduce_patterns returns a list of lists, which pandas will store as object dtype column -- same as the original.

3. Keep the import of `deduce_patterns_for_variant` from deducer.py for now (parallel_analyzer.py still uses it, will be updated in Plan 04).

4. Run golden file validation:
   ```bash
   python scripts/validate_inheritance.py compare
   ```
   If any scenario fails, debug and fix the vectorized code until ALL scenarios pass.

5. Run full test suite:
   ```bash
   pytest tests/test_inheritance/ -v
   pytest -m unit
   ```
   Fix any failures -- the vectorized code must produce clinically equivalent output.

**Do NOT change parallel_analyzer.py in this plan** -- it will be updated in Plan 04 after all vectorization is complete.
  </action>
  <verify>
    Run: `python scripts/validate_inheritance.py compare` -- exit code 0, all scenarios match
    Run: `pytest tests/test_inheritance/ -v` -- all tests pass
    Run: `pytest -m unit` -- no regressions
    Run: `make lint && make typecheck` -- clean
  </verify>
  <done>analyzer.py uses vectorized Pass 1, all golden file scenarios pass, all existing tests pass, no regressions</done>
</task>

</tasks>

<verification>
1. `python scripts/validate_inheritance.py compare` exits with code 0 (clinically equivalent output)
2. `pytest tests/test_inheritance/ -v` -- all tests pass including golden file tests
3. `pytest -m unit` -- no regressions in any unit tests
4. `make lint && make typecheck` -- clean
5. Manual inspection: `grep "df.apply.*deduce_patterns" variantcentrifuge/inheritance/analyzer.py` returns no matches (old code removed)
</verification>

<success_criteria>
- df.apply(deduce_patterns_for_variant) replaced with vectorized_deduce_patterns in analyzer.py
- All golden file scenarios produce clinically equivalent output
- All existing inheritance tests pass without modification
- Code is readable with clear variable names and genetic logic comments
</success_criteria>

<output>
After completion, create `.planning/phases/09-inheritance-analysis-optimization/09-02-SUMMARY.md`
</output>
