---
phase: 09-inheritance-analysis-optimization
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - variantcentrifuge/inheritance/analyzer.py
autonomous: true

must_haves:
  truths:
    - "Pass 2 compound het result application uses vectorized column operations, not itertuples loop"
    - "Pass 3 prioritization loop is optimized with batch operations where possible"
    - "Golden file comparison passes after both Pass 2 and Pass 3 changes"
  artifacts:
    - path: "variantcentrifuge/inheritance/analyzer.py"
      provides: "Vectorized Pass 2 application and optimized Pass 3"
      contains: "variant_keys ="
  key_links:
    - from: "variantcentrifuge/inheritance/analyzer.py"
      to: "variantcentrifuge/inheritance/comp_het_vectorized.py"
      via: "comp het results applied via vectorized column ops"
      pattern: "comp_het_results_by_gene"
---

<objective>
Vectorize Pass 2 (compound het result application) and optimize Pass 3 (prioritization) in analyzer.py.

Purpose: Pass 2 currently uses an itertuples loop to apply compound het results (lines 128-133). Pass 3 uses an itertuples loop for prioritization (lines 138-186). Vectorizing these completes the full three-pass optimization.

Output: Updated analyzer.py with vectorized Pass 2 and optimized Pass 3.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-inheritance-analysis-optimization/09-CONTEXT.md
@.planning/phases/09-inheritance-analysis-optimization/09-02-SUMMARY.md
@variantcentrifuge/inheritance/analyzer.py
@variantcentrifuge/inheritance/comp_het.py
@variantcentrifuge/inheritance/comp_het_vectorized.py
@variantcentrifuge/inheritance/prioritizer.py
@variantcentrifuge/inheritance/segregation_checker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vectorize Pass 2 compound het result application</name>
  <files>variantcentrifuge/inheritance/analyzer.py</files>
  <action>
Replace the itertuples loop in Pass 2 (lines 128-133 of analyzer.py) with vectorized operations:

**Current code:**
```python
for row in df.itertuples(index=True):
    variant_key = create_variant_key(row)
    gene = getattr(row, "GENE", "")
    if gene in comp_het_results_by_gene and variant_key in comp_het_results_by_gene[gene]:
        df.at[row.Index, "_comp_het_info"] = comp_het_results_by_gene[gene][variant_key]
```

**Vectorized replacement:**

1. Create variant keys for ALL rows at once (vectorized string concatenation):
   ```python
   variant_keys = (
       df['CHROM'].astype(str) + ':' +
       df['POS'].astype(str) + ':' +
       df['REF'].astype(str) + '>' +
       df['ALT'].astype(str)
   )
   ```

2. Create a flat lookup dict: `{(gene, variant_key): comp_het_info}` from comp_het_results_by_gene

3. Get genes array: `genes = df['GENE'].astype(str).values`

4. Apply comp het results in batch per-gene:
   ```python
   for gene, gene_results in comp_het_results_by_gene.items():
       gene_mask = genes == gene  # or use .isin() if GENE is categorical
       gene_variant_keys = variant_keys[gene_mask]
       for vk, info in gene_results.items():
           vk_mask = gene_variant_keys == vk
           if vk_mask.any():
               matching_indices = df.index[gene_mask][vk_mask]
               for idx in matching_indices:
                   df.at[idx, '_comp_het_info'] = info
   ```

   Note: We still need per-index assignment for the dict values (can't vectorize dict storage in DataFrame cells), but the key lookup is now vectorized instead of per-row.

5. Alternative approach if gene count is small: build a mapping dict `{variant_key: info}` keyed by gene+variant_key, then apply with a single Series.map() call. Choose whichever is cleaner.

**Validate:** Run `python scripts/validate_inheritance.py compare` after this change.
  </action>
  <verify>
    Run: `python scripts/validate_inheritance.py compare` -- exit code 0
    Run: `pytest tests/test_inheritance/ -v` -- all pass
    Run: `grep "itertuples" variantcentrifuge/inheritance/analyzer.py` -- should NOT match in the Pass 2 section (only Pass 3 if not yet changed)
  </verify>
  <done>Pass 2 itertuples loop replaced with vectorized variant key lookup and batch application</done>
</task>

<task type="auto">
  <name>Task 2: Optimize Pass 3 prioritization</name>
  <files>variantcentrifuge/inheritance/analyzer.py</files>
  <action>
Optimize Pass 3 (lines 138-186 of analyzer.py). Pass 3 is harder to fully vectorize because it calls `calculate_segregation_score()` (which takes a row dict) and `create_inheritance_details()` (which takes a Series) per variant. However, we can still optimize significantly:

**Strategy: Keep the loop but eliminate expensive operations inside it.**

1. **Pre-compute variant keys** (already done in Task 1, reuse the `variant_keys` Series)

2. **Pre-extract _inheritance_patterns and _comp_het_info into lists** to avoid repeated df.at[] lookups:
   ```python
   all_inheritance_patterns = df['_inheritance_patterns'].tolist()
   all_comp_het_info = df['_comp_het_info'].tolist()
   ```

3. **Pre-compute whether segregation is needed** (scalar, outside loop):
   ```python
   needs_segregation = bool(pedigree_data and len(pedigree_data) > 1)
   ```

4. **Batch the loop** using enumerate with pre-extracted data:
   ```python
   inheritance_patterns_result = []
   inheritance_details_result = []

   for idx_pos, (df_idx, row_series) in enumerate(df.iterrows()):
       patterns_list = list(all_inheritance_patterns[idx_pos] or [])
       comp_info = all_comp_het_info[idx_pos]

       # Add comp het patterns (same logic as current)
       if comp_info:
           for _sample_id, info in comp_info.items():
               if info.get("is_compound_het"):
                   comp_het_type = info.get("comp_het_type", "compound_heterozygous")
                   if comp_het_type != "not_compound_heterozygous":
                       if comp_het_type not in patterns_list:
                           patterns_list.append(comp_het_type)

       # Segregation
       segregation_results = None
       if needs_segregation:
           row_dict = row_series.to_dict()
           segregation_results = calculate_segregation_score(
               patterns_list, row_dict, pedigree_data, sample_list
           )

       # Prioritize
       best_pattern, confidence = prioritize_patterns(patterns_list, segregation_results)

       # Create details
       details = create_inheritance_details(
           row_series, best_pattern, patterns_list, confidence,
           comp_info, pedigree_data, sample_list, segregation_results,
       )

       inheritance_patterns_result.append(best_pattern)
       inheritance_details_result.append(json.dumps(details))

   # Assign results in bulk (avoids per-row df.at[] overhead)
   df['Inheritance_Pattern'] = inheritance_patterns_result
   df['Inheritance_Details'] = inheritance_details_result
   ```

   Key optimizations vs current code:
   - Pre-extract column data to lists (avoids repeated df.at[] lookups in loop)
   - Accumulate results in lists, assign in bulk at end (avoids per-row df.at[] writes)
   - Use df.iterrows() since we need Series for create_inheritance_details anyway
   - The segregation_checker.calculate_segregation_score is inherently per-variant (uses row dict + pedigree conditionals) -- leave it scalar for now

5. **If segregation is not needed** (most common case: no pedigree or single-sample), skip the row_dict creation entirely for a significant speedup.

**Validate:** Run golden file comparison and full test suite after changes.

Note on full vectorization of Pass 3: The segregation checker and create_inheritance_details are complex per-variant functions with many conditional paths. Attempting to vectorize them would risk clinical correctness for marginal gain (Pass 3 is not the bottleneck -- Pass 1 was). Per 09-CONTEXT.md: "Partial vectorization is acceptable if a specific pass has sections too complex to vectorize fully."
  </action>
  <verify>
    Run: `python scripts/validate_inheritance.py compare` -- exit code 0
    Run: `pytest tests/test_inheritance/ -v` -- all pass
    Run: `pytest -m unit` -- no regressions
    Run: `make lint && make typecheck` -- clean
  </verify>
  <done>Pass 3 optimized with pre-extracted data and bulk assignment, golden files still match, all tests pass</done>
</task>

</tasks>

<verification>
1. `python scripts/validate_inheritance.py compare` exits with code 0 after both Pass 2 and Pass 3 changes
2. `pytest tests/test_inheritance/ -v` -- all tests pass
3. `pytest -m unit` -- no regressions
4. `make lint && make typecheck` -- clean
5. Pass 2 no longer uses itertuples for comp het application
6. Pass 3 uses bulk list accumulation + assignment instead of per-row df.at[] writes
</verification>

<success_criteria>
- Pass 2 comp het application vectorized (no itertuples loop for variant key matching)
- Pass 3 optimized with pre-extraction and bulk assignment
- Golden file validation passes for all scenarios
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/09-inheritance-analysis-optimization/09-03-SUMMARY.md`
</output>
