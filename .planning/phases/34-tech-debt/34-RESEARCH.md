# Phase 34: Tech Debt - Research

**Researched:** 2026-02-24
**Domain:** Association subsystem: config mapping, COAST validation, column naming, diagnostics documentation
**Confidence:** HIGH

## Summary

Phase 34 addresses four internal correctness and consistency issues in the association subsystem. All changes are code-level fixes — no new user-facing features. The research confirmed the exact current state of each issue through direct codebase inspection.

**TD-02 (config mapping):** `create_stages_from_config()` in `pipeline.py` builds a minimal `argparse.Namespace` from a config dict, but does NOT map `perform_association` or `perform_gene_burden` keys to the namespace. Since `build_pipeline_stages()` checks `hasattr(args, "perform_gene_burden")` and `hasattr(args, "perform_association")`, passing a config dict with these keys set to `True` silently omits the stages.

**TD-03 (COAST golden values):** A golden value infrastructure already exists. `tests/unit/test_coast_python_comparison.py` has 5 hardcoded R golden scenarios (`_R_GOLDEN_SCENARIO_*` constants) generated by `scripts/generate_coast_golden.R`. The current tests use synthetic data (different RNG from R, so no exact matching), validating statistical behavior only (direction of signal, not magnitude). The CONTEXT decision is that these tests compare Python output against R golden values from GCKD testing data with 10% relative tolerance. The existing infrastructure supports this; the task is to run `generate_coast_golden.R` against the GCKD VCF (present in `testing/gckd_all.GRCh37.annotated.vcf.gz`) and add hardcoded Python-vs-R assertions with 10% tolerance.

**TD-04 (column naming):** The engine in `engine.py` produces `{test_name}_p_value` (e.g., `fisher_p_value`, `skat_p_value`, `coast_p_value`). The CONTEXT requires renaming to `{test_name}_pvalue` (no underscore before "value"), plus `acat_o_corrected_p_value` → `acat_o_qvalue`. SKAT-O specifically: when `skat_method=SKATO`, the test name is still "skat" (hardcoded in `PurePythonSKATTest.name` and `RSKATTest.name`), so output is `skat_p_value` regardless. To get `skat_o_pvalue` for SKATO runs, either the test name must be dynamically set to "skat_o" when method=SKATO, or the engine must inspect `skat_method` from extra. This is a broader change than a simple rename.

**TD-05 (lambda_GC documentation):** `diagnostics.py` computes `lambda_GC` for ALL test types including Fisher. `compute_lambda_gc()` has comments about inflation but does NOT document the Fisher exemption from correction or the over-correction risk. The fix is purely docstring/comment additions.

**Primary recommendation:** Address in order TD-02 (simple fix), TD-05 (pure docs), TD-04 (mechanical rename + SKAT-O name routing), then TD-03 (needs R execution + golden capture).

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Python standard library | 3.10+ | `argparse.Namespace` manipulation | Already used in pipeline.py |
| pytest | existing | Integration test for TD-02 | Existing test framework |
| numpy | existing | COAST golden value generation (Python side) | Already used throughout |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| R + AllelicSeries | offline | COAST golden value generation | TD-03 R script execution only |

### Alternatives Considered
None — all changes operate within existing code and dependencies.

**Installation:**
No new packages needed.

## Architecture Patterns

### Recommended Project Structure
No structural changes. All modifications are within existing files.

### Pattern 1: Config Key Mapping in create_stages_from_config()
**What:** Add the two missing config key → namespace attribute mappings.
**When to use:** Whenever a config dict key must activate a stage, it needs an explicit line in the mapper.
**Example:**
```python
# Source: variantcentrifuge/pipeline.py, create_stages_from_config()
# CURRENT (missing the critical mappings):
args.pca = config.get("pca")
# USE THE EXISTING build_pipeline_stages function
return build_pipeline_stages(args)

# FIXED (add before the return):
args.perform_gene_burden = config.get("perform_gene_burden", False)
args.perform_association = config.get("perform_association", False)
args.no_stats = config.get("no_stats", False)  # also check if needed
```

### Pattern 2: Dynamic test name for SKAT-O in PurePythonSKATTest / RSKATTest
**What:** Make `name` property return "skat_o" when `skat_method=SKATO`, "skat" otherwise.
**When to use:** When the column name must reflect the actual statistical method used.
**Problem:** `name` is a property that returns a constant — the method isn't known at construction time, it comes from `AssociationConfig` which is passed to `run()`.
**Alternative approach:** Post-process in the engine: if `skat_method` in extra is "SKATO", rename the `skat_p_value` column to `skat_o_pvalue` in the output DataFrame. This avoids changing the test name property and keeps the engine output logic clean.
**Simpler alternative (recommended):** Change the `name` property to "skat_o" only in a new SKAT-O specific test wrapper, or add a flag to `PurePythonSKATTest.__init__` if `skat_method` is known early.
**Note from CONTEXT:** The decision says `skat_o_pvalue` as column name when `skat_method=SKATO` — this requires the column renaming to happen somewhere. The cleanest place is the engine or the test class.

### Pattern 3: Column rename convention for TD-04
**What:** Change column name suffix `_p_value` → `_pvalue` and `acat_o_corrected_p_value` → `acat_o_qvalue`.
**Where to change:**
1. `engine.py` line 538: `row[f"{test_name}_p_value"]` → `row[f"{test_name}_pvalue"]`
2. `engine.py` line 562-563: `row["acat_o_p_value"]` → `row["acat_o_pvalue"]`, `row["acat_o_corrected_p_value"]` → `row["acat_o_qvalue"]`
3. `diagnostics.py`: column lookup `f"{tid}_p_value"` → `f"{tid}_pvalue"`, and update "acat_o" special case
4. All test files referencing old column names (substantial scope — see Common Pitfalls)
5. `analysis_stages.py` line 2767: `c.endswith("_corrected_p_value")` → `c.endswith("_qvalue")`
6. Engine docstring in `engine.py` lines 11-31

### Pattern 4: lambda_GC documentation in diagnostics.py
**What:** Add docstring additions to `compute_lambda_gc()` explaining Fisher exemption and over-correction risk.
**Where:** `variantcentrifuge/association/diagnostics.py`, `compute_lambda_gc()` function docstring.
**Content to add:**
```python
# NOTE: Fisher's exact test p-values should NOT be GC-corrected.
# Fisher's exact test is exact (not asymptotic) — applying lambda_GC correction
# would be statistically invalid and would introduce bias. Only score-based
# asymptotic tests (SKAT, burden) benefit from lambda_GC correction.
#
# Threshold guidance:
#   lambda_GC > 1.2 = significant inflation, investigate population stratification
#   lambda_GC > 1.0 in large studies may reduce power (over-correction risk,
#   2025 literature on GC correction in large cohorts).
```

### Anti-Patterns to Avoid
- **Backward-compatibility aliases:** CONTEXT explicitly says clean break — do NOT add deprecated column names.
- **Unit tests for config mapping TD-02:** CONTEXT says integration tests only.
- **Committing the R script output:** CONTEXT says the R script does not need to be committed.
- **Exhaustive threshold table:** CONTEXT says keep lambda_GC comments concise, no full threshold table.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Column rename across all rows | Custom column name registry | Direct string replacement in engine.py | The engine generates all columns; change at the source |
| SKAT-O name routing | External lookup table | Dynamic test name or engine post-processing | Test name drives column name; change at the source |
| COAST R comparison | New comparison framework | Extend existing test_coast_python_comparison.py | Infrastructure already exists |

**Key insight:** All column naming flows from `engine.py`'s `run_all()` method and the test `name` property. Change at the source; don't add mapping layers.

## Common Pitfalls

### Pitfall 1: Column name scope — more than just the engine
**What goes wrong:** Changing `_p_value` to `_pvalue` in engine.py but missing references in diagnostics.py, analysis_stages.py, and tests.
**Why it happens:** The column names are used in multiple places with no central registry.
**How to avoid:** Search exhaustively before and after:
  - `engine.py`: generates columns
  - `diagnostics.py`: reads `{tid}_p_value` for lambda_GC computation (line 345)
  - `analysis_stages.py` line 2767: reads `_corrected_p_value` suffix
  - All test files (see list below)
**Warning signs:** Tests fail with `KeyError` or `assert "fisher_pvalue" in result.columns` fails.

Files with column name references that need updating:
- `variantcentrifuge/association/engine.py` (produces them)
- `variantcentrifuge/association/diagnostics.py` (reads them)
- `variantcentrifuge/stages/analysis_stages.py` (reads `_corrected_p_value` suffix)
- `tests/unit/test_association_engine.py` (asserts on column names)
- `tests/unit/test_association_diagnostics.py` (uses `fisher_p_value`, `acat_o_p_value`, `acat_o_corrected_p_value`)
- `tests/unit/test_association_fisher.py` (asserts on `fisher_p_value`)
- `tests/unit/test_association_stage.py` (asserts on `fisher_p_value`)
- `tests/unit/test_engine_skat_integration.py` (asserts on `skat_p_value`, `acat_o_p_value`, `acat_o_corrected_p_value`)
- `tests/unit/test_coast.py` (asserts on `coast_p_value`, `coast_skat_p_value`)
- `tests/unit/test_coast_partial_category.py` (uses `skat_p_value`)

### Pitfall 2: SKAT-O test name is not determined at construction time
**What goes wrong:** Trying to make `PurePythonSKATTest.name` return "skat_o" conditionally, but `name` is called before `run()` so `skat_method` is not yet known.
**Why it happens:** The test name property is used for engine registry lookup and column prefix — it needs to be stable. The `skat_method` is in `AssociationConfig`, not the test object.
**How to avoid:** The cleanest approach: change name property to always return "skat" for SKAT method, "skat_o" for SKATO. Pass `skat_method` at construction time (store as `self._skat_method`). The engine constructs tests via `AssociationEngine.from_names()` which doesn't pass method. Alternative: the engine detects SKATO method from `config.skat_method` and renames the output column post-hoc.
**Recommendation:** Store `skat_method` in `AssociationConfig` and check it at `check_dependencies()`/`prepare()` time. OR: engine post-processing that renames `skat_pvalue` → `skat_o_pvalue` when `skat_method` column value is "SKATO". The engine already has access to `config` at run time.

### Pitfall 3: create_stages_from_config missing mappings
**What goes wrong:** Config dict has `"perform_association": True` but stage is never added.
**Root cause confirmed:** Lines 352-373 in `pipeline.py` — the function creates an `argparse.Namespace` but does not set `perform_association` or `perform_gene_burden` attributes.
**How to avoid:** Add two lines before the return statement. Also audit for other potentially missing config keys (`no_stats`, `no_metadata`, `excel`, `igv_report` etc.) — some appear to be mapped (args.xlsx, args.html_report) while others might be missing.

### Pitfall 4: COAST R golden tests currently use statistical behavior, not exact comparison
**What goes wrong:** Misunderstanding that the existing R golden tests in `test_coast_python_comparison.py` already do Python-vs-R comparison with specific tolerances.
**Reality:** Current tests hardcode R golden values for 5 synthetic scenarios, but only check that:
  - Null scenarios: Python omnibus p > 0.01
  - Signal scenario: Python omnibus p < 0.20
These are loose statistical behavior checks, NOT 10% relative tolerance comparisons.
**TD-03 requirement:** Generate R values from GCKD data (real data, not synthetic), add a new test class that hardcodes those values and asserts Python output is within 10% relative difference.
**How to avoid confusion:** Add a new test class (e.g., `TestCOASTGCKDGoldenComparison`) separate from existing tests, with the hardcoded GCKD-derived golden values.

### Pitfall 5: Lambda_GC is computed for Fisher in diagnostics but not corrected
**What goes wrong:** Thinking lambda_GC is currently APPLIED to Fisher p-values.
**Reality:** `compute_lambda_gc()` COMPUTES the statistic for Fisher, but does NOT apply correction. The function only computes the diagnostic value. There is no code path that divides Fisher p-values by a lambda_GC factor anywhere. Lambda_GC is diagnostic-only.
**Implication for TD-05:** The documentation needed is clarifying that lambda_GC IS computed for Fisher (for diagnostics), but should NOT be used for correction of Fisher p-values. This is already partially correct behavior — just undocumented.

## Code Examples

### Fix: create_stages_from_config() missing mappings
```python
# Source: variantcentrifuge/pipeline.py, create_stages_from_config()
# Add before: return build_pipeline_stages(args)

args.perform_gene_burden = config.get("perform_gene_burden", False)
args.perform_association = config.get("perform_association", False)
args.no_stats = config.get("no_stats", False)
args.no_metadata = config.get("no_metadata", False)
```

### Fix: Engine column naming (TD-04)
```python
# Source: variantcentrifuge/association/engine.py, _build_results_dataframe()
# Change line 538:
row[f"{test_name}_pvalue"] = res.p_value  # was: f"{test_name}_p_value"

# Change lines 562-565:
row["acat_o_pvalue"] = acat_res.p_value if acat_res is not None else None  # was: acat_o_p_value
row["acat_o_qvalue"] = (  # was: acat_o_corrected_p_value
    acat_res.corrected_p_value if acat_res is not None else None
)
```

### Fix: Diagnostics column lookup (TD-04)
```python
# Source: variantcentrifuge/association/diagnostics.py, write_diagnostics()
# Change line 345:
col = f"{tid}_pvalue"  # was: f"{tid}_p_value"

# Change line 339:
if "acat_o_pvalue" in results_df.columns and "acat_o" not in all_test_ids:  # was: acat_o_p_value
```

### Fix: SKAT-O column name routing (TD-04)
```python
# Option A: Engine post-processing in run_all() after building rows
# After row["skat_pvalue"] = res.p_value is written:
if row.get("skat_method") == "SKATO":
    row["skat_o_pvalue"] = row.pop("skat_pvalue")

# Option B: PurePythonSKATTest.name property becomes dynamic
# (requires storing skat_method at construction time)
```

### Docstring addition: compute_lambda_gc() (TD-05)
```python
# Source: variantcentrifuge/association/diagnostics.py
def compute_lambda_gc(p_values: list[float | None]) -> float | None:
    """
    Compute genomic inflation factor (lambda_GC) from a list of p-values.
    ...
    Notes
    -----
    Fisher's exact test p-values should NOT be lambda_GC-corrected. Fisher's
    exact test is non-asymptotic (exact), so applying GC correction would be
    statistically invalid. This function computes lambda_GC for ALL tests
    (diagnostic use only). Apply correction only to score-based asymptotic
    tests (SKAT, burden).

    Interpretation:
    - lambda_GC near 1.0: well-calibrated
    - lambda_GC > 1.2: significant inflation — investigate population
      stratification or cryptic relatedness
    - Caution: in large studies, GC correction can over-correct and reduce
      power for true associations (see Devlin & Roeder 1999, Gorroochurn 2025).
    """
```

### Integration test: create_stages_from_config (TD-02)
```python
# New integration test verifying stages activate when config keys are set
def test_create_stages_from_config_activates_association_stage():
    """Config with perform_association=True must include AssociationAnalysisStage."""
    from variantcentrifuge.pipeline import create_stages_from_config
    from variantcentrifuge.stages.analysis_stages import AssociationAnalysisStage

    config = {"perform_association": True, "output_dir": "/tmp"}
    stages = create_stages_from_config(config)
    stage_types = [type(s) for s in stages]
    assert AssociationAnalysisStage in stage_types, (
        "AssociationAnalysisStage not in stages when perform_association=True"
    )
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| R COAST backend (COASTTest) | Python COAST backend (PurePythonCOASTTest) | Phase 24/25 | R backend deprecated, to be removed in v0.17.0 |
| Generic `_p_value` suffix | (planned) `_pvalue` suffix | Phase 34 | Cleaner column names, no double underscore |
| `acat_o_corrected_p_value` | (planned) `acat_o_qvalue` | Phase 34 | Clearer semantics (q-value = BH-corrected p) |

**Deprecated/outdated:**
- `COASTTest` (R backend): marked deprecated in `__init__`, will be removed v0.17.0. TD-03 does NOT use the R COAST backend for the golden comparison — it uses R AllelicSeries package output as reference values, compared against the Python backend output.

## Open Questions

1. **SKAT-O naming mechanism**
   - What we know: `PurePythonSKATTest.name` always returns "skat"; engine column is always `skat_pvalue`
   - What's unclear: Whether TD-04 requires changing the test name property or doing post-hoc column rename in the engine
   - Recommendation: Use engine post-processing (rename `skat_pvalue` → `skat_o_pvalue` when `skat_method` column is "SKATO"). This is simpler than changing the name property and avoids registry complications.

2. **GCKD COAST golden value generation**
   - What we know: GCKD data is in `testing/gckd_all.GRCh37.annotated.vcf.gz`; existing R script `scripts/generate_coast_golden.R` uses synthetic data
   - What's unclear: Whether TD-03 requires a new R script that runs on GCKD data or extending the existing one
   - Recommendation: Extend the existing R script with a GCKD section, OR run the pipeline on GCKD data to get Python outputs, then run R on the same variants. The CONTEXT says "run R AllelicSeries package on GCKD testing data" — this means extracting variant data from the pipeline run and feeding it to R directly.

3. **Completeness of create_stages_from_config audit**
   - What we know: `perform_association` and `perform_gene_burden` are definitely missing
   - What's unclear: Whether other config keys are also missing (e.g., `no_stats`, `igv_report` naming mismatch — function sets `args.igv_report` but `build_pipeline_stages` checks `args.igv`)
   - Recommendation: Audit ALL config key mappings in the function, comparing against what `build_pipeline_stages` checks.

## Sources

### Primary (HIGH confidence)
- Direct inspection of `variantcentrifuge/pipeline.py` (lines 270-373) — config mapping bug confirmed
- Direct inspection of `variantcentrifuge/association/engine.py` (lines 11-583) — current column naming
- Direct inspection of `variantcentrifuge/association/diagnostics.py` (lines 41-80, 300-371) — lambda_GC implementation
- Direct inspection of `variantcentrifuge/association/tests/skat_python.py` (lines 96-99) — test name "skat" always
- Direct inspection of `tests/unit/test_coast_python_comparison.py` — existing R golden infrastructure

### Secondary (MEDIUM confidence)
- Testing data inspection: `testing/v016_coast_realdata/01_sift_polyphen/association_results.association.tsv.gz` — confirms current column name `coast_p_value`
- Grep of all test files for column name references — comprehensive but manual pattern search

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Config mapping bug (TD-02): HIGH — directly confirmed in source code
- COAST golden infrastructure (TD-03): HIGH — test file and R script inspected directly
- Column naming scope (TD-04): HIGH — engine and diagnostics confirmed; test file list is comprehensive but may miss some
- Lambda_GC documentation (TD-05): HIGH — diagnostics.py inspected directly

**Research date:** 2026-02-24
**Valid until:** 2026-03-24 (stable codebase, 30 days)
