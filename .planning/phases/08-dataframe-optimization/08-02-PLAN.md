---
phase: 08-dataframe-optimization
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - variantcentrifuge/inheritance/analyzer.py
  - variantcentrifuge/inheritance/parallel_analyzer.py
  - variantcentrifuge/gene_burden.py
  - variantcentrifuge/helpers.py
  - variantcentrifuge/stages/analysis_stages.py
  - variantcentrifuge/stages/output_stages.py
  - variantcentrifuge/stats_engine.py
  - variantcentrifuge/annotator.py
autonomous: true

must_haves:
  truths:
    - "iterrows replaced with itertuples in all hot-path iteration sites"
    - "Column access uses getattr(row, 'COL', default) pattern for itertuples namedtuple"
    - "All existing tests pass with identical output after itertuples conversion"
    - "pd.NA-safe comparisons used where categorical columns are compared"
  artifacts:
    - path: "variantcentrifuge/inheritance/analyzer.py"
      provides: "itertuples in Pass 2 (line 128), Pass 3 (line 138), summary (line 305), report (line 381), vectorized apply (line 447)"
      contains: "itertuples"
    - path: "variantcentrifuge/gene_burden.py"
      provides: "itertuples in grouped iteration (lines 265, 273)"
      contains: "itertuples"
    - path: "variantcentrifuge/helpers.py"
      provides: "itertuples in hot-path helper functions (lines 251, 926)"
      contains: "itertuples"
  key_links:
    - from: "variantcentrifuge/inheritance/analyzer.py"
      to: "variantcentrifuge/dataframe_optimizer.py"
      via: "Columns already sanitized at load time by Plan 01"
      pattern: "getattr.*row"
---

<objective>
Replace all iterrows() calls with itertuples() across hot-path modules for 10-14x iteration speedup, and add pd.NA-safe comparison patterns for categorical columns.

Purpose: iterrows is the single largest iteration bottleneck in the pipeline. itertuples returns namedtuples instead of Series objects, avoiding per-row Series construction overhead. Column names were sanitized at load time (Plan 01), so itertuples attribute access works safely. Categorical dtypes from Plan 01 require pd.NA-safe comparisons to prevent boolean mask breakage.

Output: All hot-path iterrows sites converted to itertuples with correct attribute access patterns. pd.NA-safe comparisons added at categorical column comparison sites.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-dataframe-optimization/08-CONTEXT.md
@.planning/phases/08-dataframe-optimization/08-RESEARCH.md
@.planning/phases/08-dataframe-optimization/08-01-SUMMARY.md
@variantcentrifuge/inheritance/analyzer.py
@variantcentrifuge/gene_burden.py
@variantcentrifuge/helpers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert iterrows to itertuples in inheritance analysis and gene burden hot paths</name>
  <files>
    variantcentrifuge/inheritance/analyzer.py
    variantcentrifuge/inheritance/parallel_analyzer.py
    variantcentrifuge/gene_burden.py
  </files>
  <action>
**CRITICAL: These are clinical analysis hot paths. Output must remain byte-identical. Use diff-based validation approach.**

For each iterrows site, apply this mechanical transformation:

```python
# BEFORE:
for idx, row in df.iterrows():
    val = row["COLUMN"]        # or row.get("COLUMN", "")
    df.at[idx, "TARGET"] = x

# AFTER:
for row in df.itertuples(index=True):
    val = getattr(row, "COLUMN", "")   # getattr for safe access
    df.at[row.Index, "TARGET"] = x     # row.Index replaces idx
```

**Important conversion rules:**
- `row["COL"]` -> `getattr(row, "COL", "")` (handles missing columns gracefully)
- `row.get("COL", default)` -> `getattr(row, "COL", default)` (identical semantics)
- `idx` from `for idx, row` -> `row.Index` (add `index=True` to itertuples, which is default)
- For functions that receive `row` as a Series argument (e.g., `create_variant_key(row)`): these functions expect dict-like access. Create a helper that wraps the namedtuple row for such calls, OR refactor the function to accept individual fields. Check `create_variant_key` - if it uses `row["CHROM"]` etc., pass individual args instead.

**Sites to convert in `analyzer.py`:**
1. Line 128: Pass 2 compound het application - `for idx, row in df.iterrows()` -> itertuples. Uses `create_variant_key(row)` and `row.get("GENE", "")`.
2. Line 138: Pass 3 prioritization - `for idx, row in df.iterrows()` -> itertuples. Accesses `row["_inheritance_patterns"]`, `row["_comp_het_info"]`.
3. Line 305: `get_analysis_summary` - `for _, row in df.iterrows()` -> itertuples. Accesses `row["Inheritance_Details"]`, `row["Inheritance_Pattern"]`.
4. Line 381: `export_inheritance_report` - `for _, row in df.iterrows()` -> itertuples. Uses `row.get()` on many columns.
5. Line 447: vectorized analysis apply loop - `for idx, row in df.iterrows()` -> itertuples.

**Sites to convert in `parallel_analyzer.py`:**
1. Line 242: compound het application - same pattern as analyzer.py line 128
2. Line 254: prioritization - same pattern as analyzer.py line 138

**Sites to convert in `gene_burden.py`:**
1. Line 265: `for _i, row in grouped.iterrows()` -> itertuples
2. Line 273: `for _, row in grouped.iterrows()` -> itertuples

**For `create_variant_key` calls:** Check its implementation. If it takes a row Series and accesses dict-style, the simplest fix is to keep passing a row but use `df.iloc` or modify `create_variant_key` to accept a namedtuple (check if it uses `row["CHROM"]` style - if so, add overload or use `getattr`).

**pd.NA-safe comparisons:** Search for direct `==` comparisons on columns that may be categorical (IMPACT, FILTER, EFFECT, GENE, CHROM). Add `.fillna("")` or `.fillna(False)` before boolean comparisons. Key sites:
- `df["Inheritance_Pattern"] == "de_novo"` -> `df["Inheritance_Pattern"].eq("de_novo").fillna(False)`
- Any `mask = df["COL"] == "value"` pattern

Do NOT convert iterrows in non-hot-path code (pseudonymizer.py, ped_reader.py, build_pm5_lookup.py) - those are cold paths not worth the risk.
  </action>
  <verify>
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -m pytest tests/test_inheritance/ -v -x --timeout=120`
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -m pytest tests/ -m "gene_burden" -v -x --timeout=120`
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -m pytest tests/unit/ -v -x --timeout=60`
  </verify>
  <done>
    All iterrows calls in analyzer.py (5 sites), parallel_analyzer.py (2 sites), and gene_burden.py (2 sites) replaced with itertuples. All inheritance and gene burden tests pass with identical behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert iterrows to itertuples in helpers, stats_engine, annotator, and stage files</name>
  <files>
    variantcentrifuge/helpers.py
    variantcentrifuge/stats_engine.py
    variantcentrifuge/annotator.py
    variantcentrifuge/stages/analysis_stages.py
    variantcentrifuge/stages/output_stages.py
  </files>
  <action>
Apply the same iterrows -> itertuples mechanical transformation to remaining hot-path sites:

**`helpers.py`:**
1. Line 251: `for idx, row in df.iterrows()` -> itertuples
2. Line 926: `for _, row in df.iterrows()` -> itertuples

**`stats_engine.py`:**
1. Line 286: `for _, row in self.results["dataset"].iterrows()` -> itertuples

**`annotator.py`:**
1. Line 483: `for _index, row in df.iterrows()` -> itertuples

**`stages/analysis_stages.py`:**
1. Line 125: `for _, row in sample_entries.iterrows()` -> itertuples
2. Line 316: `for _idx, row in df.iterrows()` -> itertuples
3. Line 352: `for idx, row in df.iterrows()` -> itertuples

**`stages/output_stages.py`:**
1. Line 518: `for _, row in df.iterrows()` -> itertuples. This one builds tab-separated lines for link insertion. Convert: `"\t".join(str(val) for val in row)` -> use `row[1:]` (skip Index) and join.

Same conversion rules as Task 1. Use `getattr(row, "COL", default)` for attribute access, `row.Index` for index.

**pd.NA-safe comparisons:** Scan all modified files for direct `==` comparisons on potentially categorical columns and add `.fillna()` protection. Key patterns to find:
- `df["IMPACT"] == "HIGH"` or similar
- `df["FILTER"] == "PASS"`
- `df["CHROM"] == "X"` or similar

Also search for `isin()` calls on categorical columns - these are generally NA-safe but verify.
  </action>
  <verify>
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -m pytest tests/unit/ -v -x --timeout=60`
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -m pytest tests/integration/ -v -x --timeout=120 -k "not slow"`
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -c "import variantcentrifuge.helpers; import variantcentrifuge.stats_engine; import variantcentrifuge.annotator; print('imports OK')"`
  </verify>
  <done>
    All iterrows calls in helpers.py (2 sites), stats_engine.py (1 site), annotator.py (1 site), analysis_stages.py (3 sites), and output_stages.py (1 site) replaced with itertuples. All unit and integration tests pass.
  </done>
</task>

</tasks>

<verification>
- `grep -rn "iterrows" variantcentrifuge/ --include="*.py" | grep -v "test_" | grep -v "__pycache__"` shows ONLY non-hot-path sites (pseudonymizer.py, ped_reader.py, build_pm5_lookup.py, comp_het.py, analyze_variants.py)
- `python -m pytest tests/ -v -x --timeout=180 -k "not slow and not performance"` all pass
- No `iterrows` remains in: analyzer.py, parallel_analyzer.py, gene_burden.py, helpers.py, stats_engine.py, annotator.py, analysis_stages.py, output_stages.py
</verification>

<success_criteria>
- 14 iterrows sites converted to itertuples across 8 files
- All attribute access uses getattr(row, "COL", default) pattern
- pd.NA-safe comparisons added where categorical columns are compared
- All existing tests pass with zero behavioral changes
- Cold-path iterrows (pseudonymizer, ped_reader, build_pm5_lookup) intentionally left unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/08-dataframe-optimization/08-02-SUMMARY.md`
</output>
