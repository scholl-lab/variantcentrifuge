---
phase: 37-association-resource-management-memory-streaming
plan: 03
type: execute
wave: 2
depends_on: ["37-02"]
files_modified:
  - variantcentrifuge/stages/analysis_stages.py
  - variantcentrifuge/association/engine.py
  - tests/unit/test_streaming_matrix.py
autonomous: true

must_haves:
  truths:
    - "Genotype matrices are built per-gene on demand (lazy), not all at once before engine.run_all()"
    - "Each matrix is discarded after the gene's tests complete — peak memory is O(1 gene) not O(all genes)"
    - "The lazy builder is picklable for ProcessPoolExecutor parallel path"
    - "MAC check and sample mask logic remain correct (same results as before)"
    - "Sequential engine path uses lazy per-gene building; parallel path builds eagerly per-batch before submission (avoids pickling both builder and matrix)"
  artifacts:
    - path: "variantcentrifuge/stages/analysis_stages.py"
      provides: "_GenotypeMatrixBuilder dataclass and builder creation loop"
      contains: "_GenotypeMatrixBuilder"
    - path: "variantcentrifuge/association/engine.py"
      provides: "Builder invocation in gene loop with matrix discard"
      contains: "_genotype_matrix_builder"
    - path: "tests/unit/test_streaming_matrix.py"
      provides: "Tests for lazy builder pattern, pickling, and memory discard"
  key_links:
    - from: "variantcentrifuge/stages/analysis_stages.py"
      to: "variantcentrifuge/association/engine.py"
      via: "gene_data['_genotype_matrix_builder'] callback"
      pattern: "_genotype_matrix_builder"
    - from: "variantcentrifuge/association/engine.py"
      to: "variantcentrifuge/association/genotype_matrix.py"
      via: "builder.__call__() invokes build_genotype_matrix"
      pattern: "build_genotype_matrix"
---

<objective>
Stream genotype matrix construction per-gene so matrices are built on demand and discarded after test execution (PERF-06).

Purpose: Currently all 5K+ genotype matrices are pre-built in a loop before engine.run_all(), consuming 16+ GB peak memory. This fix stores a lazy builder callback per gene instead of the matrix itself. The engine calls the builder just before running tests, then discards the matrix after. Peak memory drops from O(all_genes x matrix_size) to O(1 x matrix_size).

Output: _GenotypeMatrixBuilder picklable dataclass in analysis_stages.py; engine.py consumes builder in both sequential and parallel paths; matrices discarded after use.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-association-resource-management-memory-streaming/37-RESEARCH.md
@.planning/phases/37-association-resource-management-memory-streaming/37-02-SUMMARY.md

@variantcentrifuge/stages/analysis_stages.py
@variantcentrifuge/association/engine.py
@variantcentrifuge/association/genotype_matrix.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create _GenotypeMatrixBuilder and replace pre-build loop with builder creation</name>
  <files>
    variantcentrifuge/stages/analysis_stages.py
  </files>
  <action>
1. **Create the _GenotypeMatrixBuilder dataclass** near the top of analysis_stages.py (after imports, before stage classes). This must be at MODULE level (not nested) so it's picklable:

```python
@dataclass
class _GenotypeMatrixBuilder:
    """Picklable lazy builder for per-gene genotype matrices (PERF-06).

    Instead of pre-building all matrices, this callable is stored in gene_data
    and invoked by the engine just before running tests. The matrix is discarded
    after test execution, keeping peak memory at O(1 gene).
    """
    gene_df: pd.DataFrame
    vcf_samples: list[str]
    gt_columns: list[str]
    is_binary: bool
    missing_site_threshold: float
    missing_sample_threshold: float
    phenotype_vector: "np.ndarray | None"
    covariate_matrix: "np.ndarray | None"

    def __call__(self) -> dict[str, Any]:
        """Build genotype matrix and apply sample mask + MAC check.

        Returns dict with keys: genotype_matrix, variant_mafs,
        phenotype_vector, covariate_matrix, gt_warnings, mac_filtered.
        """
        from ..association.genotype_matrix import build_genotype_matrix

        if self.gene_df.empty:
            n_samples = len(self.vcf_samples)
            return {
                "genotype_matrix": np.zeros((n_samples, 0), dtype=float),
                "variant_mafs": np.zeros(0, dtype=float),
                "phenotype_vector": self.phenotype_vector,
                "covariate_matrix": self.covariate_matrix,
                "gt_warnings": [],
                "mac_filtered": False,
            }

        geno, mafs, sample_mask, gt_warnings = build_genotype_matrix(
            self.gene_df,
            self.vcf_samples,
            self.gt_columns,
            is_binary=self.is_binary,
            missing_site_threshold=self.missing_site_threshold,
            missing_sample_threshold=self.missing_sample_threshold,
            phenotype_vector=self.phenotype_vector,
        )

        # Apply sample mask to phenotype and covariates
        pv = self.phenotype_vector
        cm = self.covariate_matrix
        if not all(sample_mask):
            mask_arr = np.array(sample_mask, dtype=bool)
            pv = pv[mask_arr] if pv is not None else None
            cm = cm[mask_arr] if cm is not None else None
            geno = geno[mask_arr]

        # Per-gene MAC check: skip regression if < 5 minor allele copies
        mac_filtered = False
        total_mac = int(geno.sum()) if geno.size > 0 else 0
        if total_mac < 5:
            geno = np.zeros((geno.shape[0], 0), dtype=float)
            mafs = np.zeros(0, dtype=float)
            mac_filtered = True

        return {
            "genotype_matrix": geno,
            "variant_mafs": mafs,
            "phenotype_vector": pv,
            "covariate_matrix": cm,
            "gt_warnings": gt_warnings,
            "mac_filtered": mac_filtered,
        }
```

The builder encapsulates ALL logic currently in the matrix building loop (lines 2601-2714): build, mask, MAC check. The engine receives a fully processed result.

2. **Replace the pre-build loop** (lines ~2593-2714) in AssociationAnalysisStage._process():

Current code builds ALL matrices in a `for gene_data in gene_burden_data:` loop and stores them directly in gene_data dicts.

Replace with a loop that creates builders instead:

```python
gt_source_df = df_with_per_sample_gt if df_with_per_sample_gt is not None else df
gt_columns_for_matrix = _find_per_sample_gt_columns(gt_source_df)
if needs_regression and gt_columns_for_matrix and vcf_samples_list:
    is_binary = assoc_config.trait_type == "binary"
    _gene_groups = gt_source_df.groupby("GENE")
    for gene_data in gene_burden_data:
        gene_name = gene_data.get("GENE", "")
        try:
            gene_df = _gene_groups.get_group(gene_name)
        except KeyError:
            gene_df = gt_source_df.iloc[0:0]

        # Store lazy builder instead of pre-built matrix (PERF-06)
        builder = _GenotypeMatrixBuilder(
            gene_df=gene_df,
            vcf_samples=vcf_samples_list,
            gt_columns=gt_columns_for_matrix,
            is_binary=is_binary,
            missing_site_threshold=assoc_config.missing_site_threshold,
            missing_sample_threshold=assoc_config.missing_sample_threshold,
            phenotype_vector=phenotype_vector,
            covariate_matrix=covariate_matrix,
        )
        gene_data["_genotype_matrix_builder"] = builder

        # Phase 23: Extract functional annotation columns for CADD/REVEL weight schemes
        # (This stays here — annotation extraction is cheap and needed regardless)
        if assoc_config.variant_weights in ("cadd", "revel", "combined"):
            # ... keep existing CADD/REVEL/effect annotation code unchanged ...
            pass

        gene_data["vcf_samples"] = vcf_samples_list

        # Phase 23: gene_df for COAST annotation column access
        if any(t in test_names for t in ("coast",)):
            gene_data["gene_df"] = gene_df
```

IMPORTANT: The CADD/REVEL annotation extraction code (lines ~2651-2710) and the gene_df storage for COAST (lines ~2716-2720) must be PRESERVED in the builder creation loop. Only the matrix building + sample mask + MAC check moves into the builder. Copy the annotation extraction code verbatim.

Also IMPORTANT: The `gene_data["phenotype_vector"]` and `gene_data["covariate_matrix"]` assignments that currently happen inside the loop (lines 2712-2713) should still happen for genes that DON'T use the builder (e.g., Fisher-only). For genes with builders, the builder's __call__ returns them. The engine should set these from the builder result.

For the parallel path: The builder captures `gene_df` (a DataFrame slice) which will be pickled when sent to worker processes. This is the same data that would have been in `gene_data["genotype_matrix"]` before — same pickle size. For the parallel path, to avoid pickling gene_df + builder, the engine should call the builder BEFORE submitting to workers. See Task 2.
  </action>
  <verify>
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -c "from variantcentrifuge.stages.analysis_stages import _GenotypeMatrixBuilder; print('Builder class importable')" && make lint`
  </verify>
  <done>
    _GenotypeMatrixBuilder dataclass exists at module level in analysis_stages.py. Pre-build loop replaced with builder creation loop. Annotation extraction preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Engine consumes builder in sequential and parallel paths with matrix discard</name>
  <files>
    variantcentrifuge/association/engine.py
    tests/unit/test_streaming_matrix.py
  </files>
  <action>
1. **Modify engine.py sequential path** (lines ~416-424):

Before each gene's test execution, check for and invoke the builder:

```python
# Sequential gene loop
for gene_data in sorted_data:
    gene = gene_data.get("GENE", "")

    # PERF-06: Invoke lazy builder if present
    if "_genotype_matrix_builder" in gene_data and "genotype_matrix" not in gene_data:
        builder = gene_data.pop("_genotype_matrix_builder")
        result = builder()
        gene_data["genotype_matrix"] = result["genotype_matrix"]
        gene_data["variant_mafs"] = result["variant_mafs"]
        gene_data["phenotype_vector"] = result["phenotype_vector"]
        gene_data["covariate_matrix"] = result["covariate_matrix"]
        for w in result.get("gt_warnings", []):
            logger.warning(f"Gene {gene}: {w}")
        if result.get("mac_filtered"):
            logger.debug(
                f"Gene {gene}: MAC < 5 — regression will report NA"
            )

    for test_name, test in self._tests.items():
        result = test.run(gene, gene_data, self._config)
        results_by_test[test_name][gene] = result
        logger.debug(
            f"Gene {gene} | {test_name}: p={result.p_value}, OR={result.effect_size}"
        )

    # PERF-06: Discard matrix after all tests for this gene complete
    gene_data.pop("genotype_matrix", None)
    gene_data.pop("variant_mafs", None)
    # Keep phenotype_vector and covariate_matrix — they're shared references, not per-gene
```

2. **Modify engine.py parallel path** (lines ~370-414):

For the parallel path, matrices must be built BEFORE pickling to avoid pickling the builder's gene_df DataFrame AND the matrix. Build matrices eagerly for the parallel batch, then discard after workers return:

```python
# Parallel path: build matrices eagerly before submitting to workers
# (builders capture gene_df which would be large to pickle alongside matrix)
for gd in remaining:
    if "_genotype_matrix_builder" in gd and "genotype_matrix" not in gd:
        builder = gd.pop("_genotype_matrix_builder")
        result = builder()
        gd["genotype_matrix"] = result["genotype_matrix"]
        gd["variant_mafs"] = result["variant_mafs"]
        gd["phenotype_vector"] = result["phenotype_vector"]
        gd["covariate_matrix"] = result["covariate_matrix"]
        gene = gd.get("GENE", "")
        for w in result.get("gt_warnings", []):
            logger.warning(f"Gene {gene}: {w}")

args_list = [
    (gd.get("GENE", ""), gd, pickled_tests, self._config) for gd in remaining
]
with concurrent.futures.ProcessPoolExecutor(...) as executor:
    for gene, gene_results in executor.map(_run_gene_worker, args_list):
        ...

# PERF-06: Discard matrices after parallel batch completes
for gd in remaining:
    gd.pop("genotype_matrix", None)
    gd.pop("variant_mafs", None)
```

Note: In the parallel path, we lose the per-gene lazy benefit because all matrices for the batch are built before submission. However, the discard after completion still reduces steady-state memory. The sequential path (default, most common) gets the full per-gene streaming benefit.

A future optimization could batch the parallel path into chunks of N genes, building matrices per-chunk. This is out of scope for this plan.

3. **Create tests** in `tests/unit/test_streaming_matrix.py`:

```python
"""Tests for streaming genotype matrix construction (PERF-06)."""
import pickle

import numpy as np
import pandas as pd
import pytest


@pytest.mark.unit
class TestGenotypeMatrixBuilder:
    """Test the lazy builder dataclass."""

    def test_builder_is_picklable(self):
        """Builder must be picklable for ProcessPoolExecutor."""
        from variantcentrifuge.stages.analysis_stages import _GenotypeMatrixBuilder

        df = pd.DataFrame({
            "GEN_0__GT": ["0/1", "0/0"],
            "GEN_1__GT": ["1/1", "0/1"],
            "GENE": ["A", "A"],
        })
        builder = _GenotypeMatrixBuilder(
            gene_df=df,
            vcf_samples=["S1", "S2"],
            gt_columns=["GEN_0__GT", "GEN_1__GT"],
            is_binary=True,
            missing_site_threshold=0.1,
            missing_sample_threshold=0.5,
            phenotype_vector=np.array([1, 0]),
            covariate_matrix=None,
        )
        # Must survive pickle round-trip
        restored = pickle.loads(pickle.dumps(builder))
        result = restored()
        assert "genotype_matrix" in result
        assert "variant_mafs" in result
        assert isinstance(result["genotype_matrix"], np.ndarray)

    def test_builder_empty_gene(self):
        """Empty gene_df returns zero-column matrix."""
        from variantcentrifuge.stages.analysis_stages import _GenotypeMatrixBuilder

        df = pd.DataFrame({
            "GEN_0__GT": pd.Series([], dtype=str),
            "GEN_1__GT": pd.Series([], dtype=str),
            "GENE": pd.Series([], dtype=str),
        })
        builder = _GenotypeMatrixBuilder(
            gene_df=df,
            vcf_samples=["S1", "S2"],
            gt_columns=["GEN_0__GT", "GEN_1__GT"],
            is_binary=True,
            missing_site_threshold=0.1,
            missing_sample_threshold=0.5,
            phenotype_vector=np.array([1, 0]),
            covariate_matrix=None,
        )
        result = builder()
        assert result["genotype_matrix"].shape[1] == 0

    def test_builder_mac_filter(self):
        """Builder filters genes with MAC < 5."""
        from variantcentrifuge.stages.analysis_stages import _GenotypeMatrixBuilder

        # All ref genotypes -> MAC=0
        df = pd.DataFrame({
            "GEN_0__GT": ["0/0"],
            "GEN_1__GT": ["0/0"],
            "GENE": ["A"],
        })
        builder = _GenotypeMatrixBuilder(
            gene_df=df,
            vcf_samples=["S1", "S2"],
            gt_columns=["GEN_0__GT", "GEN_1__GT"],
            is_binary=True,
            missing_site_threshold=0.1,
            missing_sample_threshold=0.5,
            phenotype_vector=np.array([1, 0]),
            covariate_matrix=None,
        )
        result = builder()
        assert result["mac_filtered"] is True
        assert result["genotype_matrix"].shape[1] == 0


@pytest.mark.unit
class TestEngineBuilderConsumption:
    """Test that engine correctly invokes and discards builders."""

    def test_matrix_discarded_after_sequential_run(self):
        """After engine.run_all, gene_data dicts should not hold matrices.

        Uses logistic_burden (a matrix-consuming test type) to verify the
        builder is actually invoked and then the matrix is discarded.
        """
        from variantcentrifuge.association.engine import AssociationEngine
        from variantcentrifuge.association.config import AssociationConfig
        from variantcentrifuge.stages.analysis_stages import _GenotypeMatrixBuilder

        config = AssociationConfig(gene_burden_mode="samples", trait_type="binary")
        engine = AssociationEngine.from_names(["logistic_burden"], config)

        # Create a builder that produces a valid (but MAC-filtered) matrix
        df = pd.DataFrame({
            "GEN_0__GT": ["0/0"],
            "GEN_1__GT": ["0/0"],
            "GENE": ["TestGene"],
        })
        builder = _GenotypeMatrixBuilder(
            gene_df=df,
            vcf_samples=["S1", "S2"],
            gt_columns=["GEN_0__GT", "GEN_1__GT"],
            is_binary=True,
            missing_site_threshold=0.1,
            missing_sample_threshold=0.5,
            phenotype_vector=np.array([1, 0]),
            covariate_matrix=None,
        )

        gene_data = [
            {
                "GENE": "TestGene",
                "case_alleles": 5,
                "control_alleles": 10,
                "case_total": 20,
                "control_total": 40,
                "_genotype_matrix_builder": builder,
            }
        ]
        result_df = engine.run_all(gene_data)
        assert result_df is not None
        # Verify matrix keys are not lingering after run
        assert "genotype_matrix" not in gene_data[0]
        assert "_genotype_matrix_builder" not in gene_data[0]
```

Mark all tests with `@pytest.mark.unit`.
  </action>
  <verify>
    `cd /mnt/c/development/scholl-lab/variantcentrifuge && python -m pytest tests/unit/test_streaming_matrix.py -v && python -m pytest tests/ -m "not slow and not integration" -x -q 2>&1 | tail -20 && make ci-check`
  </verify>
  <done>
    Engine invokes _genotype_matrix_builder in sequential path (per-gene) and parallel path (pre-batch). Matrices discarded after test execution. All tests pass. ci-check clean.
  </done>
</task>

</tasks>

<verification>
1. `grep -n "_GenotypeMatrixBuilder" variantcentrifuge/stages/analysis_stages.py` — class definition exists at module level
2. `grep -n "_genotype_matrix_builder" variantcentrifuge/association/engine.py` — builder consumed in both sequential and parallel paths
3. `grep -n 'pop("genotype_matrix"' variantcentrifuge/association/engine.py` — matrix discarded after use
4. `python -m pytest tests/unit/test_streaming_matrix.py -v` passes
5. `python -m pytest tests/ -m "not slow and not integration" -x -q` passes (no regressions)
6. `make ci-check` passes
</verification>

<success_criteria>
- Genotype matrices are built per-gene via _GenotypeMatrixBuilder.__call__(), not pre-built in a bulk loop
- Builder is picklable (dataclass at module level, no lambdas)
- Sequential engine path: build per-gene, discard after tests
- Parallel engine path: build eagerly before submission, discard after workers return
- MAC check and sample mask logic produce identical results to before
- Peak memory for matrix construction is O(1 gene) in sequential path
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/37-association-resource-management-memory-streaming/37-03-SUMMARY.md`
</output>
