<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ report_name }}</title>

    <!-- External Dependencies -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.4.1/css/buttons.dataTables.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">

    <script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.1/js/dataTables.buttons.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.1/js/buttons.colVis.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; background-color: #f4f7f9; }
        .container { max-width: 95%; margin: 0 auto; padding: 20px; }
        header { background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); color: white; padding: 1.5rem; margin-bottom: 2rem; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        header h1 { margin: 0; font-size: 28px; font-weight: 600; }
        header p { margin: 5px 0 0; opacity: 0.9; font-size: 14px; }
        .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); grid-gap: 20px; margin-bottom: 20px; }
        .stats-card { background-color: #fff; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); padding: 20px; text-align: center; border-left: 5px solid #007bff; }
        .stats-card h3 { margin-top: 0; color: #6c757d; font-size: 1rem; text-transform: uppercase; letter-spacing: 0.5px; }
        .stats-card p { margin: 0; font-size: 2.25rem; font-weight: 700; color: #343a40; }
        .chart-container { background-color: white; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); padding: 20px; margin-bottom: 20px; height: 450px; }
        .filters-section, .dataTables_wrapper { background-color: white; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); padding: 20px; margin-bottom: 20px; }
        .filters-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); grid-gap: 20px; }
        .filter-control label { display: block; margin-bottom: 8px; font-weight: 600; font-size: 14px; }
        .filter-control input, .filter-control select { width: 100%; box-sizing: border-box; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; }
        .slider-container { padding: 20px 10px; }
        .slider-values { display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #6c757d; }
        .noUi-target { border: 1px solid #ced4da; box-shadow: none; }
        .noUi-connect { background: #007bff; }
        .missing-values-control { margin-top: 8px; font-size: 12px; }
        .missing-values-control label { display: flex; align-items: center; cursor: pointer; }
        .missing-values-control input[type="checkbox"] { margin-right: 6px; }
        .btn-reset { background-color: #6c757d; color: white; border: none; border-radius: 4px; padding: 10px 18px; cursor: pointer; margin-top: 15px; font-weight: 600; }
        .btn-reset:hover { background-color: #5a6268; }
        /* Custom styles for compact table appearance - matching individual reports */
        #variants-table {
            font-size: 13px; /* Reduce from browser default, typically 16px */
            width: 100% !important; /* Ensure the table always takes full width */
        }
        #variants-table th {
            white-space: normal !important; /* Allow header text to wrap */
            word-wrap: break-word;
            text-align: left; /* Ensure consistent alignment */
            vertical-align: middle; /* Better vertical alignment for wrapped headers */
            line-height: 1.3; /* Slightly adjust line-height for wrapped headers */
        }

        /* Further refine padding for the compact style */
        #variants-table.compact th,
        #variants-table.compact td {
            padding: 4px 6px; /* Tighter padding than default compact style */
        }
        #variants-table td {
            text-align: left; /* Ensure consistent alignment */
            vertical-align: top; /* Align content to the top of the cell */
            line-height: 1.3; /* Slightly adjust line-height for cell content */
        }

        /* Generic DataTable styling as fallback */
        table.dataTable { width: 100% !important; border-collapse: collapse !important; font-size: 13px; }
        table.dataTable thead th { background-color: #e9ecef; border-bottom: 2px solid #dee2e6; white-space: normal !important; word-wrap: break-word; text-align: left; vertical-align: middle; line-height: 1.3; }
        table.dataTable.compact th, table.dataTable.compact td { padding: 4px 6px; }
        table.dataTable td { text-align: left; vertical-align: top; line-height: 1.3; }
        footer { text-align: center; margin-top: 30px; padding: 20px; font-size: 12px; color: #777; }
        
        /* Link styling from individual reports */
        .link-icon { text-decoration: none; margin-right: 3px; color: #007bff; font-size: 0.9em; }
        .standard-link { text-decoration: underline; color: #007bff; display: inline-block; }
        .standard-link:hover { color: #0056b3; }
        
        /* IGV link styling */
        .igv-individual-link {
            margin-right: 5px;
            text-decoration: underline;
            color: #0066cc;
            display: inline-block;
            white-space: nowrap;
        }
        .igv-individual-link .link-icon {
            color: #5cb85c; /* Green color for IGV links */
        }
        
        /* Hover-expand functionality from individual reports */
        .hover-expand-cell { position: relative; }
        .hover-expand-content { display: inline-block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: bottom; }
        .hover-expand-content.can-expand { cursor: help; }
        .hover-expand-content.expanded { 
            position: absolute; top: 0; left: 0; width: auto; max-width: 400px; min-width: 100%; 
            white-space: normal; word-wrap: break-word; overflow: visible; 
            background-color: #FFFFE0; border: 1px solid #666; padding: 5px; z-index: 1000; 
            box-shadow: 3px 3px 8px rgba(0,0,0,0.2); border-radius: 3px; 
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>{{ report_name }}</h1>
            <p>Generated on {{ generation_date }}</p>
        </header>

        <div class="dashboard">
            <div class="stats-card"><h3>Total Samples</h3><p id="total-samples">...</p></div>
            <div class="stats-card"><h3>Unique Genes</h3><p id="total-genes">...</p></div>
            <div class="stats-card"><h3>Total Variants (in cohort)</h3><p id="total-variants">...</p></div>
            <div class="stats-card"><h3>Variants Displayed</h3><p id="filtered-variants">...</p></div>
        </div>

        <div class="chart-container">
            <div id="gene-plot" style="width: 100%; height: 100%;"></div>
        </div>

        <div class="filters-section">
            <h2>Filters</h2>
            <div id="custom-filters" class="filters-grid"></div>
            <button id="reset-filters" class="btn-reset">Reset All Filters</button>
        </div>

        <div class="dataTables_wrapper">
            <table id="variants-table" class="display compact" style="width:100%"></table>
        </div>

        <footer>
            <p>Created with VariantCentrifuge</p>
        </footer>
    </div>

<script>
$(document).ready(function() {
    // Debug logging infrastructure
    const urlParams = new URLSearchParams(window.location.search);
    window.COHORT_DEBUG = urlParams.get('debug') === '1' || window.COHORT_DEBUG === true;
    
    function debugLog(message, data = null) {
        if (window.COHORT_DEBUG) {
            if (data !== null) {
                console.log(`[FILTER-DEBUG] ${message}`, data);
            } else {
                console.log(`[FILTER-DEBUG] ${message}`);
            }
        }
    }
    
    function debugGroup(title, callback) {
        if (window.COHORT_DEBUG) {
            console.group(`[FILTER-DEBUG] ${title}`);
            callback();
            console.groupEnd();
        }
    }
    
    debugLog('=== COHORT REPORT FILTER DEBUGGING ENABLED ===');
    debugLog('To disable: window.COHORT_DEBUG = false; or remove ?debug=1 from URL');
    debugLog('');

    // Parse embedded JSON data directly from the template
    const variantsData = JSON.parse('{{ variants_json | safe }}');
    const summaryData = JSON.parse('{{ summary_json | safe }}');
    const columnMetadata = JSON.parse('{{ column_metadata_json | safe }}');
    let dataTable;
    
    debugLog('Data loaded:', {
        'variants': variantsData?.length || 0,
        'columns': columnMetadata?.length || 0,
        'summary': Object.keys(summaryData || {}).length
    });

    // Initialize the dashboard with summary statistics
    initializeDashboard(summaryData);

    // Create the gene frequency plot
    createGenePlot(summaryData.gene_summary);

    // Initialize the data table with variant data
    initializeTable(variantsData);

    // Set up filtering capabilities
    initializeFilters(variantsData);

    // If any errors occur during parsing, notify the user
    window.addEventListener('error', function(event) {
        console.error("Error loading data:", event.error);
        document.body.innerHTML = `<div class="container"><h1>Error Loading Report</h1><p>There was an error loading the report data: ${event.error.message}</p></div>`;
    });

    // --- INITIALIZATION FUNCTIONS ---
    function initializeDashboard(summary) {
        $('#total-samples').text(summary.unique_samples);
        $('#total-genes').text(summary.unique_genes);
        $('#total-variants').text(summary.total_variants);
        $('#filtered-variants').text(summary.total_variants);
    }

    function initializeTable(data) {
        if (!data || data.length === 0) {
            console.error('No data available for table initialization');
            return;
        }

        console.log('Table data sample:', data[0]);  // Debug log to check data structure
        console.log('Column metadata:', columnMetadata);

        // Ensure data is properly formatted as array of objects
        if (typeof data === 'string') {
            try {
                data = JSON.parse(data);
            } catch (e) {
                console.error('Failed to parse data string:', e);
            }
        }

        const firstRow = data[0];
        if (!firstRow) {
            console.error('No rows in data');
            return;
        }

        // Build column definitions from metadata
        const columns = [];
        const columnDefs = [];
        const hiddenColumns = [];
        
        columnMetadata.forEach((colMeta, index) => {
            const colName = colMeta.name;
            
            // Basic column definition
            const columnDef = {
                title: colMeta.display_name,
                data: colName,
                render: function(data, type, row) {
                    if (data === null || data === undefined || data === '') return '';
                    
                    // Handle IGV link columns
                    if (colMeta.is_igv_link_column && data && Array.isArray(data)) {
                        if (data.length === 0) {
                            return 'N/A';
                        }
                        
                        let igvLinksHtml = '';
                        data.forEach((igvLinkDetail, idx) => {
                            if (idx > 0) igvLinksHtml += ' ';
                            igvLinksHtml += `<a href="${igvLinkDetail.report_path}" target="_blank" class="igv-individual-link" title="IGV report for ${igvLinkDetail.sample_id}">
                                               <span class="link-icon">🔗</span>${igvLinkDetail.sample_id}
                                             </a>`;
                        });
                        return igvLinksHtml;
                    }
                    
                    // Handle standard link columns
                    if (colMeta.is_link && data) {
                        const linkText = colMeta.link_info.display_text || colMeta.display_name;
                        return `<a href="${data}" target="_blank" class="standard-link" title="${data}">
                                  <span class="link-icon">🔗</span>${linkText}
                                </a>`;
                    }
                    
                    // Handle hover-expand columns
                    if (colMeta.needs_truncation) {
                        // For genetic notation (like HGVS), we need to preserve '>' characters
                        // while still protecting against XSS for other content
                        if (colName === 'HGVS_C' || colName === 'HGVS_P' ||
                            colName === 'GT' || colName === 'ID') {
                            // Replace < with &lt; but leave > as is for genetic notation
                            const safeData = data.replace(/</g, '&lt;');
                            return `<span class="hover-expand-content" style="max-width:${colMeta.max_width}px;">${safeData}</span>`;
                        } else {
                            // Standard HTML escaping for other content
                            const escapedData = $('<div>').text(data).html();
                            return `<span class="hover-expand-content" style="max-width:${colMeta.max_width}px;">${escapedData}</span>`;
                        }
                    }
                    
                    // Format numeric values with precision for AF columns
                    if (colName.includes('AF') && !isNaN(parseFloat(data))) {
                        return parseFloat(data).toFixed(4);
                    }

                    return data;
                }
            };
            
            columns.push(columnDef);
            
            // Track hidden columns
            if (colMeta.is_hidden_default) {
                hiddenColumns.push(index);
            }
            
            // Add hover-expand cell creation
            if (colMeta.needs_truncation) {
                columnDefs.push({
                    targets: index,
                    createdCell: function (td, cellData, rowData, row, col) {
                        $(td).addClass('hover-expand-cell');
                    }
                });
            }
        });
        
        // Add column visibility definition for hidden columns
        if (hiddenColumns.length > 0) {
            columnDefs.push({
                targets: hiddenColumns,
                visible: false
            });
        }

        // Destroy existing DataTable if it exists
        if ($.fn.DataTable.isDataTable('#variants-table')) {
            $('#variants-table').DataTable().destroy();
            $('#variants-table').empty();
        }

        // Initialize the DataTable
        dataTable = $('#variants-table').DataTable({
            data: data,
            columns: columns,
            columnDefs: columnDefs,
            autoWidth: false, // Prevent automatic width calculation which can cause misalignment
            dom: 'lBfrtip', // Add length menu (l) and Buttons (B) to the DOM - matching individual template
            buttons: [
                {
                    extend: 'colvis',
                    text: 'Show/Hide Columns',
                    className: 'ml-2'
                },
                'csvHtml5', 
                'excelHtml5'
            ],
            scrollX: true, // Enable horizontal scrolling
            deferRender: true,
            pageLength: 10, // Match individual template default
            lengthMenu: [[10, 25, 50, 100, -1], [10, 25, 50, 100, "All"]], // Match individual template options
            order: [],
            drawCallback: function(settings) {
                // Force column width adjustment
                this.api().columns.adjust();
                
                // Check which cells need hover-expand functionality
                $('.hover-expand-content', this.api().table().body()).each(function() {
                    var $this = $(this);
                    if (this.offsetWidth < this.scrollWidth || this.offsetHeight < this.scrollHeight) {
                        $this.addClass('can-expand');
                        $this.attr('title', 'Hover to see full content');
                    } else {
                        $this.removeClass('can-expand');
                        $this.removeAttr('title');
                    }
                });
            }
        });

        // Event delegation for hover-expand functionality
        $('#variants-table tbody')
        .on('mouseenter', 'td.hover-expand-cell span.hover-expand-content.can-expand', function() {
            $(this).addClass('expanded');
        })
        .on('mouseleave', 'td.hover-expand-cell span.hover-expand-content.expanded', function() {
            $(this).removeClass('expanded');
        });

        // This is the key event listener for dynamic updates
        dataTable.on('draw.dt', function() {
            const filteredData = dataTable.rows({ search: 'applied' }).data().toArray();
            updateDashboardAndPlot(filteredData);
        });

        // Initial stats update
        updateDashboardAndPlot(data);
    }

    function createGenePlot(geneData) {
        if (!geneData || !Array.isArray(geneData) || geneData.length === 0) {
            console.warn('No gene data available for plot');
            document.getElementById('gene-plot').innerHTML =
                '<div style="text-align:center;padding:40px;">No gene data available</div>';
            return;
        }

        console.log('Gene data for plot:', geneData); // Debug log to check data structure

        // Ensure we have the right structure
        const validGeneData = geneData.filter(g => g && g.Gene && g.SampleCount);

        if (validGeneData.length === 0) {
            // If no valid gene data, try to build it from the variant data
            try {
                const variantsData = dataTable ? dataTable.data().toArray() : [];
                if (variantsData.length > 0) {
                    // Extract gene data from variant data
                    const geneCounts = {};
                    variantsData.forEach(row => {
                        if (row.Gene) {
                            if (!geneCounts[row.Gene]) {
                                geneCounts[row.Gene] = new Set();
                            }
                            if (row.SampleID) {
                                geneCounts[row.Gene].add(row.SampleID);
                            }
                        }
                    });

                    const reconstructedGeneData = Object.entries(geneCounts)
                        .map(([Gene, samples]) => ({
                            Gene,
                            SampleCount: samples.size,
                            VariantCount: 0 // We don't have this info
                        }))
                        .sort((a, b) => b.SampleCount - a.SampleCount);

                    if (reconstructedGeneData.length > 0) {
                        return createGenePlot(reconstructedGeneData);
                    }
                }
            } catch (e) {
                console.error('Failed to reconstruct gene data:', e);
            }

            document.getElementById('gene-plot').innerHTML =
                '<div style="text-align:center;padding:40px;">No gene data available</div>';
            return;
        }

        const topGenes = validGeneData.slice(0, 20); // Top 20 genes
        const plotData = [{
            y: topGenes.map(g => g.Gene).reverse(),
            x: topGenes.map(g => g.SampleCount).reverse(),
            type: 'bar',
            orientation: 'h',
            marker: { color: 'rgba(0, 123, 255, 0.7)' }
        }];

        const layout = {
            title: 'Top 20 Recurrently Mutated Genes (by Sample Count)',
            margin: { l: 150, r: 20, t: 40, b: 40 },  // Increased left margin for gene names
            xaxis: { title: 'Number of Samples' },
            yaxis: { automargin: true }
        };

        Plotly.newPlot('gene-plot', plotData, layout, {responsive: true});

        // Add click event to filter table
        const plotElement = document.getElementById('gene-plot');
        plotElement.on('plotly_click', function(data) {
            const geneName = data.points[0].y;
            $('#filter-Gene').val(geneName).trigger('keyup');
        });
    }

    function initializeFilters(data) {
        if (!data || data.length === 0) return;

        const columns = dataTable.columns().header().toArray().map(th => $(th).text());
        const filtersContainer = $('#custom-filters');

        // Define common genomic missing values
        const MISSING_VALUES = new Set(['', 'N/A', 'NA', '.', 'Unknown', 'null', 'undefined']);

        // Function to determine if a column should be excluded from filtering
        function shouldSkipColumnFilter(colName, data) {
            // Check column metadata first (most reliable method)
            if (columnMetadata && Array.isArray(columnMetadata)) {
                const colMeta = columnMetadata.find(meta => meta.name === colName);
                if (colMeta) {
                    // Skip if it's marked as a link column
                    if (colMeta.is_link || colMeta.is_igv_link_column) {
                        return true;
                    }
                }
            }
            
            // Skip IGV links column by name
            if (colName === 'igv_links' || colName === 'IGV Report Links') {
                return true;
            }
            
            // Skip columns with obvious link/URL names
            const name = colName.toLowerCase();
            if (name.includes('url') || name.includes('link') || name.includes('href')) {
                return true;
            }
            
            // Check if column contains URLs by sampling some values
            if (data && data.length > 0) {
                const sampleSize = Math.min(10, data.length);
                const sampleValues = data.slice(0, sampleSize);
                let urlCount = 0;
                
                for (const row of sampleValues) {
                    const val = typeof row === 'object' ? row[colName] : null;
                    if (val && typeof val === 'string' && 
                        (val.startsWith('http://') || val.startsWith('https://') || val.startsWith('ftp://'))) {
                        urlCount++;
                    }
                }
                
                // If more than 50% of sampled values are URLs, skip this column
                if (urlCount > sampleSize * 0.5) {
                    return true;
                }
            }
            
            return false;
        }

        // Smart column pattern detection for genomic data
        function getColumnType(colName) {
            const name = colName.toUpperCase();
            debugLog(`Pattern matching for column: "${colName}" (uppercase: "${name}")`);
            
            // Force numeric columns based on comprehensive genomic patterns
            // Handle both underscore and space separators
            
            // AF columns (allele frequency): "AF 1", "AF_1", "AF EXAC", etc.
            if (name.startsWith('AF ') || name.startsWith('AF_') || name === 'AF') {
                debugLog(`✓ AF pattern matched → NUMERIC`);
                return 'numeric';
            }
            // AD columns (allelic depth): "AD 1", "AD_1", "AD 2", etc.
            if (name.startsWith('AD ') || name.startsWith('AD_') || name === 'AD') {
                debugLog(`✓ AD pattern matched → NUMERIC`);
                return 'numeric';
            }
            // AC columns (allele count): "AC 1", "AC_1", "*_AC", "* AC", etc.
            if (name.startsWith('AC ') || name.startsWith('AC_') || name === 'AC' || 
                name.endsWith(' AC') || name.endsWith('_AC')) {
                debugLog(`✓ AC pattern matched → NUMERIC`);
                return 'numeric';
            }
            
            // Score columns with various patterns
            if (name.includes(' SCORE') || name.includes('_SCORE') || name.includes('SCORE') || 
                name.endsWith(' SCORE') || name.endsWith('_SCORE') || name.endsWith('SCORE')) {
                debugLog(`✓ SCORE pattern matched → NUMERIC`);
                return 'numeric';
            }
            
            // PHRED score columns: "CADD PHRED", "CADD_PHRED", "QUAL PHRED", etc.
            if (name.includes(' PHRED') || name.includes('_PHRED') || name.includes('PHRED')) {
                debugLog(`✓ PHRED pattern matched → NUMERIC`);
                return 'numeric';
            }
            
            // Database score columns: "dbNSFP *", "dbNSFP_*", CADD, REVEL, etc.
            // But exclude clnsig columns which contain text classifications
            if ((name.startsWith('DBNSFP ') || name.startsWith('DBNSFP_')) && 
                !name.includes('CLNSIG')) {
                return 'numeric';
            }
            if (name.includes('CADD') || name.includes('REVEL') || 
                name.includes('SIFT') || name.includes('POLYPHEN')) {
                return 'numeric';
            }
            
            // Splice score columns: "splice *", "splice_*", "spidex *", etc.
            if (name.startsWith('SPLICE ') || name.startsWith('SPLICE_') || 
                name.includes('SPIDEX') || name.includes('DBSCSNV') || 
                name.includes(' ADA ') || name.includes('_ADA_') ||
                name.includes(' RF ') || name.includes('_RF_') ||
                name.includes(' ZSCORE') || name.includes('_ZSCORE')) {
                return 'numeric';
            }
            
            // Count columns: "* count", "*_count", "*COUNT", etc.
            if (name.includes(' COUNT') || name.includes('_COUNT') || name.includes('COUNT') ||
                name.endsWith(' COUNT') || name.endsWith('_COUNT')) {
                debugLog(`✓ COUNT pattern matched → NUMERIC`);
                return 'numeric';
            }
            
            // Position and quality columns
            if (name === 'POS' || name.includes(' POS') || name.includes('_POS') || name.includes('POS ') ||
                name === 'QUAL' || name.includes(' QUAL') || name.includes('_QUAL') || name.includes('QUAL ')) {
                return 'numeric';
            }
            
            // Depth columns: DP, "* DP", "*_DP"
            if (name === 'DP' || name.includes(' DP') || name.includes('_DP') || 
                name.endsWith(' DP') || name.endsWith('_DP')) {
                return 'numeric';
            }
            
            // Impact severity and other numeric columns
            if (name === 'IMPACT_SEVERITY' || name === 'IMPACT SEVERITY') {
                return 'numeric';
            }
            
            // gnomAD and population frequency columns
            if (name.includes('GNOMAD') || name.includes('EXAC') || name.includes('1000G')) {
                return 'numeric';
            }
            
            // Percentage columns
            if (name.includes(' PERC') || name.includes('_PERC') || name.includes('PERC')) {
                return 'numeric';
            }
            
            // Position columns (AA POS, etc.)
            if ((name.includes(' POS') || name.includes('_POS')) && 
                !name.includes('ID') && !name.includes('CHROM')) {
                return 'numeric';
            }
            
            // Length columns (AA LEN, etc.)
            if (name.includes(' LEN') || name.includes('_LEN') || name.endsWith('LEN')) {
                return 'numeric';
            }
            
            // Force text columns (non-numeric even if they contain numbers)
            if (name.includes('ID') || name === 'CHROM' || name === 'REF' || name === 'ALT' ||
                name.includes('CLASS') || name.includes('CLNSIG') || name.includes('EFFECT') ||
                name.includes('GENE') || name.includes('FEATURE') || name.includes('HGVS') ||
                name === 'GT' || name.includes('GENOTYPE') || name.includes('ANNOTATION') ||
                name === 'FILTER' || name === 'IMPACT') {
                debugLog(`✓ TEXT pattern matched → TEXT`);
                return 'text';
            }
            
            debugLog(`✗ No pattern matched → AUTO (will analyze data)`);
            return 'auto'; // Let data analysis decide
        }

        columns.forEach((colName, colIndex) => {
            debugGroup(`Processing Column: "${colName}" (index ${colIndex})`, () => {
                // Skip filter creation for link columns (IGV links, URLs, etc.)
                if (shouldSkipColumnFilter(colName, data)) {
                    debugLog(`❌ SKIPPED - Link column detected`);
                    console.log(`Skipping filter creation for link column: ${colName}`);
                    return;
                }
                
                // Get all raw values for this column
                const allValues = data.map(row => {
                    const val = typeof row === 'object' ? row[colName] : row[colIndex];
                    return val;
                });
                
                // Sample first 5 values for debugging
                const sampleValues = allValues.slice(0, 5);
                debugLog(`Data sample (first 5 values):`, sampleValues);

                // Separate missing and valid values
                const nonMissingValues = allValues.filter(v => 
                    v !== null && v !== undefined && !MISSING_VALUES.has(String(v).trim())
                );
                
                const numericValues = nonMissingValues.filter(v => !isNaN(parseFloat(v)) && isFinite(parseFloat(v)));
                const missingCount = allValues.length - nonMissingValues.length;
                const numericCount = numericValues.length;
                const totalCount = allValues.length;
                
                debugLog(`Data analysis:`, {
                    'total_values': totalCount,
                    'non_missing': nonMissingValues.length,
                    'numeric_values': numericCount,
                    'missing_values': missingCount,
                    'numeric_percentage': nonMissingValues.length > 0 ? Math.round((numericCount / nonMissingValues.length) * 100) : 0
                });

                // Determine column type
                const columnType = getColumnType(colName);
                let filterType = 'text'; // Default fallback
                
                debugLog(`Pattern result: "${columnType}"`);

                if (columnType === 'numeric') {
                    filterType = 'numeric'; // Force numeric based on column name
                    debugLog(`→ Filter type: NUMERIC (forced by pattern)`);
                } else if (columnType === 'text') {
                    filterType = 'text'; // Force text based on column name
                    debugLog(`→ Filter type: TEXT (forced by pattern)`);
                } else if (columnType === 'auto') {
                    // Auto-detect: require 70% of non-missing values to be numeric
                    if (nonMissingValues.length > 0 && 
                        (numericCount / nonMissingValues.length) >= 0.7 &&
                        numericCount >= 3) {
                        filterType = 'numeric';
                        debugLog(`→ Filter type: NUMERIC (auto-detected: ${numericCount}/${nonMissingValues.length} values are numeric)`);
                    } else {
                        // Check if suitable for categorical dropdown (≤25 unique values)
                        const uniqueValues = [...new Set(nonMissingValues.map(v => String(v).trim()))];
                        if (uniqueValues.length > 0 && uniqueValues.length <= 25) {
                            filterType = 'categorical';
                            debugLog(`→ Filter type: CATEGORICAL (${uniqueValues.length} unique values)`);
                        } else {
                            filterType = 'text';
                            debugLog(`→ Filter type: TEXT (too many unique values: ${uniqueValues.length})`);
                        }
                    }
                }

            // For categorical, prepare unique values for dropdown
            let uniqueValues = [];
            if (filterType === 'categorical') {
                uniqueValues = [...new Set(nonMissingValues.map(v => String(v).trim()))].sort();
            }

                let filterControlHtml;
                if (filterType === 'numeric' && numericCount > 0) {
                    debugLog(`✅ Creating NUMERIC slider filter (${numericCount} numeric values found)`);
                // Calculate min and max from numeric values only
                const numericFloats = numericValues.map(v => parseFloat(v));
                const min = Math.min(...numericFloats);
                const max = Math.max(...numericFloats);

                // Create label with value counts
                const valueInfo = missingCount > 0 ? 
                    `${colName} (${numericCount} values, ${missingCount} missing)` : 
                    `${colName} (${numericCount} values)`;

                filterControlHtml = `
                    <div class="filter-control">
                        <label for="filter-${colName}">${valueInfo}</label>
                        <div id="slider-${colName}" class="slider-container"></div>
                        <div class="slider-values">
                            <span id="min-val-${colName}">${min.toFixed(4)}</span>
                            <span id="max-val-${colName}">${max.toFixed(4)}</span>
                        </div>
                        ${missingCount > 0 ? `
                        <div class="missing-values-control">
                            <label>
                                <input type="checkbox" id="include-missing-${colName}" data-column="${colIndex}" checked>
                                Include missing values (N/A, ., etc.)
                            </label>
                        </div>` : ''}
                    </div>`;
                } else if (filterType === 'numeric' && numericCount === 0) {
                    debugLog(`❌ NUMERIC filter skipped - no numeric values found, falling back to text`);
                    filterType = 'text'; // Fallback to text if no numeric values
                } else if (filterType === 'categorical' && uniqueValues.length > 0) {
                    debugLog(`✅ Creating CATEGORICAL dropdown filter (${uniqueValues.length} unique values)`);
                    // Create dropdown with unique values
                const categoryInfo = missingCount > 0 ? 
                    `${colName} (${uniqueValues.length} categories, ${missingCount} missing)` : 
                    `${colName} (${uniqueValues.length} categories)`;

                const optionsHtml = uniqueValues.map(value => 
                    `<option value="${value}">${value}</option>`
                ).join('');

                filterControlHtml = `
                    <div class="filter-control">
                        <label for="filter-${colName}">${categoryInfo}</label>
                        <select id="filter-${colName}" data-column="${colIndex}" class="category-dropdown">
                            <option value="">All</option>
                            ${optionsHtml}
                        </select>
                        ${missingCount > 0 ? `
                        <div class="missing-values-control">
                            <label>
                                <input type="checkbox" id="include-missing-${colName}" data-column="${colIndex}" checked>
                                Include missing values (N/A, ., etc.)
                            </label>
                        </div>` : ''}
                    </div>`;
                } else {
                    debugLog(`✅ Creating TEXT input filter (fallback)`);
                    // Default text input
                    filterControlHtml = `
                        <div class="filter-control">
                            <label for="filter-${colName}">${colName}</label>
                            <input type="text" id="filter-${colName}" placeholder="Filter ${colName}..." data-column="${colIndex}">
                        </div>`;
                }
                
                debugLog(`📄 Appending filter HTML to container`);
                filtersContainer.append(filterControlHtml);
                
                debugLog(`🎯 FINAL RESULT: ${filterType.toUpperCase()} filter created for "${colName}"`);
            }); // End debugGroup

            if (filterType === 'numeric' && numericCount > 0) {
                const slider = document.getElementById(`slider-${colName}`);
                const minValEl = document.getElementById(`min-val-${colName}`);
                const maxValEl = document.getElementById(`max-val-${colName}`);
                const includeMissingCheckbox = document.getElementById(`include-missing-${colName}`);

                // Use the pre-calculated min and max
                const numericFloats = numericValues.map(v => parseFloat(v));
                const min = Math.min(...numericFloats);
                const max = Math.max(...numericFloats);

                try {
                    noUiSlider.create(slider, {
                        start: [min, max],
                        connect: true,
                        range: { 'min': min, 'max': max },
                        format: {
                            to: val => parseFloat(val).toFixed(4),
                            from: val => Number(val)
                        }
                    });

                    // Combined filter function that handles both slider and missing values
                    function applyNumericFilter() {
                        const sliderValues = slider.noUiSlider.get();
                        const includeMissing = includeMissingCheckbox ? includeMissingCheckbox.checked : false;
                        const minRange = parseFloat(sliderValues[0]);
                        const maxRange = parseFloat(sliderValues[1]);

                        // Remove any existing filters for this column
                        $.fn.dataTable.ext.search = $.fn.dataTable.ext.search.filter(f => 
                            !f.toString().includes(`colIndex-${colIndex}`)
                        );

                        // Add new filter function
                        $.fn.dataTable.ext.search.push(
                            function filterNumericColumn(settings, data, dataIndex) {
                                if (settings.nTable.id !== 'variants-table') return true;
                                
                                const cellValue = data[colIndex];
                                
                                // Check if value is missing
                                if (cellValue === null || cellValue === undefined || 
                                    MISSING_VALUES.has(String(cellValue).trim())) {
                                    return includeMissing;
                                }
                                
                                // Check if value is numeric and within range
                                const numVal = parseFloat(cellValue);
                                if (isNaN(numVal) || !isFinite(numVal)) {
                                    return includeMissing; // Treat invalid numbers as missing
                                }
                                
                                return numVal >= minRange && numVal <= maxRange;
                            }
                        );
                        
                        // Mark function for identification (for removal)
                        $.fn.dataTable.ext.search[$.fn.dataTable.ext.search.length - 1].columnIndex = colIndex;
                        
                        dataTable.draw();
                    }

                    // Slider change handler
                    slider.noUiSlider.on('update', function (values) {
                        minValEl.textContent = values[0];
                        maxValEl.textContent = values[1];
                        applyNumericFilter();
                    });

                    // Missing values checkbox handler
                    if (includeMissingCheckbox) {
                        includeMissingCheckbox.addEventListener('change', applyNumericFilter);
                    }

                } catch (err) {
                    console.warn(`Failed to create slider for ${colName}:`, err);
                    // Fallback to text input if slider creation fails
                    const fallbackHtml = `
                        <div class="filter-control">
                            <label for="filter-${colName}">${colName} (fallback)</label>
                            <input type="text" id="filter-${colName}" placeholder="Filter ${colName}..." data-column="${colIndex}">
                        </div>`;
                    $(`#slider-${colName}`).closest('.filter-control').replaceWith(fallbackHtml);
                }
            } else if (filterType === 'categorical' && uniqueValues.length > 0) {
                // Handle categorical dropdown filtering
                const dropdown = document.getElementById(`filter-${colName}`);
                const includeMissingCheckbox = document.getElementById(`include-missing-${colName}`);

                function applyCategoricalFilter() {
                    const selectedValue = dropdown.value;
                    const includeMissing = includeMissingCheckbox ? includeMissingCheckbox.checked : false;

                    // Remove any existing filters for this column
                    $.fn.dataTable.ext.search = $.fn.dataTable.ext.search.filter(f => 
                        !f.toString().includes(`colIndex-${colIndex}`)
                    );

                    // Only add filter if a specific category is selected
                    if (selectedValue !== '') {
                        $.fn.dataTable.ext.search.push(
                            function filterCategoricalColumn(settings, data, dataIndex) {
                                if (settings.nTable.id !== 'variants-table') return true;
                                
                                const cellValue = data[colIndex];
                                
                                // Check if value is missing
                                if (cellValue === null || cellValue === undefined || 
                                    MISSING_VALUES.has(String(cellValue).trim())) {
                                    return includeMissing;
                                }
                                
                                // Check if value matches selected category
                                return String(cellValue).trim() === selectedValue;
                            }
                        );
                        
                        // Mark function for identification (for removal)
                        $.fn.dataTable.ext.search[$.fn.dataTable.ext.search.length - 1].columnIndex = colIndex;
                    } else if (!includeMissing && missingCount > 0) {
                        // "All" selected but exclude missing values
                        $.fn.dataTable.ext.search.push(
                            function filterCategoricalColumn(settings, data, dataIndex) {
                                if (settings.nTable.id !== 'variants-table') return true;
                                
                                const cellValue = data[colIndex];
                                
                                // Exclude missing values when "All" is selected but includeMissing is false
                                return !(cellValue === null || cellValue === undefined || 
                                        MISSING_VALUES.has(String(cellValue).trim()));
                            }
                        );
                        
                        $.fn.dataTable.ext.search[$.fn.dataTable.ext.search.length - 1].columnIndex = colIndex;
                    }
                    
                    dataTable.draw();
                }

                // Dropdown change handler
                dropdown.addEventListener('change', applyCategoricalFilter);

                // Missing values checkbox handler
                if (includeMissingCheckbox) {
                    includeMissingCheckbox.addEventListener('change', applyCategoricalFilter);
                }
            }
        });

        // Text filter event handlers
        $('.filter-control input[type="text"]').on('keyup change', function() {
            dataTable.column($(this).data('column')).search(this.value).draw();
        });

        // Reset button
        $('#reset-filters').on('click', function() {
            // Reset text inputs
            filtersContainer.find('input[type="text"]').val('');
            dataTable.columns().search('').draw();
            
            // Reset sliders
            document.querySelectorAll('.slider-container').forEach(sliderEl => {
                if (sliderEl.noUiSlider) {
                    sliderEl.noUiSlider.reset();
                }
            });
            
            // Reset dropdowns to "All" (empty value)
            filtersContainer.find('.category-dropdown').val('');
            
            // Reset missing value checkboxes to checked (default)
            filtersContainer.find('input[type="checkbox"][id^="include-missing-"]').prop('checked', true);
            
            // Clear all custom filters (numeric and categorical)
            $.fn.dataTable.ext.search = $.fn.dataTable.ext.search.filter(f => 
                !f.hasOwnProperty('columnIndex')
            );
            
            // Redraw table
            dataTable.draw();
        });
    }

    // --- DYNAMIC UPDATE FUNCTIONS ---
    function updateDashboardAndPlot(filteredData) {
        if (!filteredData || filteredData.length === 0) {
            // Update dashboard with zeros
            $('#filtered-variants').text('0');
            // Clear the plot
            try {
                Plotly.restyle('gene-plot', {x: [[]], y: [[]]});
            } catch (e) {
                console.warn('Failed to clear plot:', e);
            }
            return;
        }

        // Update dashboard cards
        $('#filtered-variants').text(filteredData.length);

        // Check for valid gene data before trying to update plot
        let hasGeneData = filteredData.some(row => row && row.Gene);
        let hasSampleIDs = filteredData.some(row => row && row.SampleID);

        if (!hasGeneData || !hasSampleIDs) {
            console.warn('Data is missing Gene or SampleID columns');
            return;
        }

        try {
            // Recalculate and update plot
            const geneCounts = filteredData.reduce((acc, row) => {
                const gene = row.Gene;
                if (!gene || gene === 'Unknown') return acc;

                if (!acc[gene]) {
                    acc[gene] = new Set();
                }

                if (row.SampleID) {
                    acc[gene].add(row.SampleID);
                }

                return acc;
            }, {});

            const geneSummary = Object.entries(geneCounts)
                .filter(([gene, samples]) => gene && samples.size > 0)
                .map(([gene, samples]) => ({
                    Gene: gene,
                    SampleCount: samples.size
                }))
                .sort((a, b) => b.SampleCount - a.SampleCount)
                .slice(0, 20);

            if (geneSummary.length > 0) {
                const plotUpdate = {
                    y: [geneSummary.map(g => g.Gene).reverse()],
                    x: [geneSummary.map(g => g.SampleCount).reverse()]
                };
                Plotly.restyle('gene-plot', plotUpdate);
            } else {
                Plotly.restyle('gene-plot', {x: [[]], y: [[]]});
            }
        } catch (e) {
            console.error('Error updating plot:', e);
        }
    }
});
</script>

</body>
</html>
